
Freedom-KL25Z_FRDM_KL25ZDemo.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000410  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00004870  00000410  00000410  00010410  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init_array   00000004  00004c80  00004c80  00014c80  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .fini_array   00000004  00004c84  00004c84  00014c84  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .isr_vector_ram 00000410  1ffff000  1ffff000  0002f000  2**0
                  ALLOC
  5 .data         00000088  1ffff410  00004c88  0001f410  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          000004f8  1ffff498  00004d10  0001f498  2**2
                  ALLOC
  7 ._user_heap_stack 00000080  1ffff990  00004d10  0001f990  2**0
                  ALLOC
  8 .ARM.attributes 0000002a  00000000  00000000  0001f498  2**0
                  CONTENTS, READONLY
  9 .debug_info   000075ad  00000000  00000000  0001f4c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001e86  00000000  00000000  00026a6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000720  00000000  00000000  000288f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000558  00000000  00000000  00029015  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00003640  00000000  00000000  0002956d  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00001f71  00000000  00000000  0002cbad  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .comment      0000007c  00000000  00000000  0002eb1e  2**0
                  CONTENTS, READONLY
 16 .debug_frame  00001380  00000000  00000000  0002eb9c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000410 <__do_global_dtors_aux>:
     410:	b510      	push	{r4, lr}
     412:	4c06      	ldr	r4, [pc, #24]	; (42c <__do_global_dtors_aux+0x1c>)
     414:	7823      	ldrb	r3, [r4, #0]
     416:	2b00      	cmp	r3, #0
     418:	d107      	bne.n	42a <__do_global_dtors_aux+0x1a>
     41a:	4b05      	ldr	r3, [pc, #20]	; (430 <__do_global_dtors_aux+0x20>)
     41c:	2b00      	cmp	r3, #0
     41e:	d002      	beq.n	426 <__do_global_dtors_aux+0x16>
     420:	4804      	ldr	r0, [pc, #16]	; (434 <__do_global_dtors_aux+0x24>)
     422:	e000      	b.n	426 <__do_global_dtors_aux+0x16>
     424:	bf00      	nop
     426:	2301      	movs	r3, #1
     428:	7023      	strb	r3, [r4, #0]
     42a:	bd10      	pop	{r4, pc}
     42c:	1ffff498 	.word	0x1ffff498
     430:	00000000 	.word	0x00000000
     434:	00004c68 	.word	0x00004c68

00000438 <frame_dummy>:
     438:	4b04      	ldr	r3, [pc, #16]	; (44c <frame_dummy+0x14>)
     43a:	b510      	push	{r4, lr}
     43c:	2b00      	cmp	r3, #0
     43e:	d003      	beq.n	448 <frame_dummy+0x10>
     440:	4903      	ldr	r1, [pc, #12]	; (450 <frame_dummy+0x18>)
     442:	4804      	ldr	r0, [pc, #16]	; (454 <frame_dummy+0x1c>)
     444:	e000      	b.n	448 <frame_dummy+0x10>
     446:	bf00      	nop
     448:	bd10      	pop	{r4, pc}
     44a:	46c0      	nop			; (mov r8, r8)
     44c:	00000000 	.word	0x00000000
     450:	1ffff49c 	.word	0x1ffff49c
     454:	00004c68 	.word	0x00004c68

00000458 <__udivsi3>:
     458:	2200      	movs	r2, #0
     45a:	0843      	lsrs	r3, r0, #1
     45c:	428b      	cmp	r3, r1
     45e:	d374      	bcc.n	54a <__udivsi3+0xf2>
     460:	0903      	lsrs	r3, r0, #4
     462:	428b      	cmp	r3, r1
     464:	d35f      	bcc.n	526 <__udivsi3+0xce>
     466:	0a03      	lsrs	r3, r0, #8
     468:	428b      	cmp	r3, r1
     46a:	d344      	bcc.n	4f6 <__udivsi3+0x9e>
     46c:	0b03      	lsrs	r3, r0, #12
     46e:	428b      	cmp	r3, r1
     470:	d328      	bcc.n	4c4 <__udivsi3+0x6c>
     472:	0c03      	lsrs	r3, r0, #16
     474:	428b      	cmp	r3, r1
     476:	d30d      	bcc.n	494 <__udivsi3+0x3c>
     478:	22ff      	movs	r2, #255	; 0xff
     47a:	0209      	lsls	r1, r1, #8
     47c:	ba12      	rev	r2, r2
     47e:	0c03      	lsrs	r3, r0, #16
     480:	428b      	cmp	r3, r1
     482:	d302      	bcc.n	48a <__udivsi3+0x32>
     484:	1212      	asrs	r2, r2, #8
     486:	0209      	lsls	r1, r1, #8
     488:	d065      	beq.n	556 <__udivsi3+0xfe>
     48a:	0b03      	lsrs	r3, r0, #12
     48c:	428b      	cmp	r3, r1
     48e:	d319      	bcc.n	4c4 <__udivsi3+0x6c>
     490:	e000      	b.n	494 <__udivsi3+0x3c>
     492:	0a09      	lsrs	r1, r1, #8
     494:	0bc3      	lsrs	r3, r0, #15
     496:	428b      	cmp	r3, r1
     498:	d301      	bcc.n	49e <__udivsi3+0x46>
     49a:	03cb      	lsls	r3, r1, #15
     49c:	1ac0      	subs	r0, r0, r3
     49e:	4152      	adcs	r2, r2
     4a0:	0b83      	lsrs	r3, r0, #14
     4a2:	428b      	cmp	r3, r1
     4a4:	d301      	bcc.n	4aa <__udivsi3+0x52>
     4a6:	038b      	lsls	r3, r1, #14
     4a8:	1ac0      	subs	r0, r0, r3
     4aa:	4152      	adcs	r2, r2
     4ac:	0b43      	lsrs	r3, r0, #13
     4ae:	428b      	cmp	r3, r1
     4b0:	d301      	bcc.n	4b6 <__udivsi3+0x5e>
     4b2:	034b      	lsls	r3, r1, #13
     4b4:	1ac0      	subs	r0, r0, r3
     4b6:	4152      	adcs	r2, r2
     4b8:	0b03      	lsrs	r3, r0, #12
     4ba:	428b      	cmp	r3, r1
     4bc:	d301      	bcc.n	4c2 <__udivsi3+0x6a>
     4be:	030b      	lsls	r3, r1, #12
     4c0:	1ac0      	subs	r0, r0, r3
     4c2:	4152      	adcs	r2, r2
     4c4:	0ac3      	lsrs	r3, r0, #11
     4c6:	428b      	cmp	r3, r1
     4c8:	d301      	bcc.n	4ce <__udivsi3+0x76>
     4ca:	02cb      	lsls	r3, r1, #11
     4cc:	1ac0      	subs	r0, r0, r3
     4ce:	4152      	adcs	r2, r2
     4d0:	0a83      	lsrs	r3, r0, #10
     4d2:	428b      	cmp	r3, r1
     4d4:	d301      	bcc.n	4da <__udivsi3+0x82>
     4d6:	028b      	lsls	r3, r1, #10
     4d8:	1ac0      	subs	r0, r0, r3
     4da:	4152      	adcs	r2, r2
     4dc:	0a43      	lsrs	r3, r0, #9
     4de:	428b      	cmp	r3, r1
     4e0:	d301      	bcc.n	4e6 <__udivsi3+0x8e>
     4e2:	024b      	lsls	r3, r1, #9
     4e4:	1ac0      	subs	r0, r0, r3
     4e6:	4152      	adcs	r2, r2
     4e8:	0a03      	lsrs	r3, r0, #8
     4ea:	428b      	cmp	r3, r1
     4ec:	d301      	bcc.n	4f2 <__udivsi3+0x9a>
     4ee:	020b      	lsls	r3, r1, #8
     4f0:	1ac0      	subs	r0, r0, r3
     4f2:	4152      	adcs	r2, r2
     4f4:	d2cd      	bcs.n	492 <__udivsi3+0x3a>
     4f6:	09c3      	lsrs	r3, r0, #7
     4f8:	428b      	cmp	r3, r1
     4fa:	d301      	bcc.n	500 <__udivsi3+0xa8>
     4fc:	01cb      	lsls	r3, r1, #7
     4fe:	1ac0      	subs	r0, r0, r3
     500:	4152      	adcs	r2, r2
     502:	0983      	lsrs	r3, r0, #6
     504:	428b      	cmp	r3, r1
     506:	d301      	bcc.n	50c <__udivsi3+0xb4>
     508:	018b      	lsls	r3, r1, #6
     50a:	1ac0      	subs	r0, r0, r3
     50c:	4152      	adcs	r2, r2
     50e:	0943      	lsrs	r3, r0, #5
     510:	428b      	cmp	r3, r1
     512:	d301      	bcc.n	518 <__udivsi3+0xc0>
     514:	014b      	lsls	r3, r1, #5
     516:	1ac0      	subs	r0, r0, r3
     518:	4152      	adcs	r2, r2
     51a:	0903      	lsrs	r3, r0, #4
     51c:	428b      	cmp	r3, r1
     51e:	d301      	bcc.n	524 <__udivsi3+0xcc>
     520:	010b      	lsls	r3, r1, #4
     522:	1ac0      	subs	r0, r0, r3
     524:	4152      	adcs	r2, r2
     526:	08c3      	lsrs	r3, r0, #3
     528:	428b      	cmp	r3, r1
     52a:	d301      	bcc.n	530 <__udivsi3+0xd8>
     52c:	00cb      	lsls	r3, r1, #3
     52e:	1ac0      	subs	r0, r0, r3
     530:	4152      	adcs	r2, r2
     532:	0883      	lsrs	r3, r0, #2
     534:	428b      	cmp	r3, r1
     536:	d301      	bcc.n	53c <__udivsi3+0xe4>
     538:	008b      	lsls	r3, r1, #2
     53a:	1ac0      	subs	r0, r0, r3
     53c:	4152      	adcs	r2, r2
     53e:	0843      	lsrs	r3, r0, #1
     540:	428b      	cmp	r3, r1
     542:	d301      	bcc.n	548 <__udivsi3+0xf0>
     544:	004b      	lsls	r3, r1, #1
     546:	1ac0      	subs	r0, r0, r3
     548:	4152      	adcs	r2, r2
     54a:	1a41      	subs	r1, r0, r1
     54c:	d200      	bcs.n	550 <__udivsi3+0xf8>
     54e:	4601      	mov	r1, r0
     550:	4152      	adcs	r2, r2
     552:	4610      	mov	r0, r2
     554:	4770      	bx	lr
     556:	e7ff      	b.n	558 <__udivsi3+0x100>
     558:	b501      	push	{r0, lr}
     55a:	2000      	movs	r0, #0
     55c:	f000 f8f0 	bl	740 <__aeabi_idiv0>
     560:	bd02      	pop	{r1, pc}
     562:	46c0      	nop			; (mov r8, r8)

00000564 <__aeabi_uidivmod>:
     564:	2900      	cmp	r1, #0
     566:	d0f7      	beq.n	558 <__udivsi3+0x100>
     568:	e776      	b.n	458 <__udivsi3>
     56a:	4770      	bx	lr

0000056c <__divsi3>:
     56c:	4603      	mov	r3, r0
     56e:	430b      	orrs	r3, r1
     570:	d47f      	bmi.n	672 <__divsi3+0x106>
     572:	2200      	movs	r2, #0
     574:	0843      	lsrs	r3, r0, #1
     576:	428b      	cmp	r3, r1
     578:	d374      	bcc.n	664 <__divsi3+0xf8>
     57a:	0903      	lsrs	r3, r0, #4
     57c:	428b      	cmp	r3, r1
     57e:	d35f      	bcc.n	640 <__divsi3+0xd4>
     580:	0a03      	lsrs	r3, r0, #8
     582:	428b      	cmp	r3, r1
     584:	d344      	bcc.n	610 <__divsi3+0xa4>
     586:	0b03      	lsrs	r3, r0, #12
     588:	428b      	cmp	r3, r1
     58a:	d328      	bcc.n	5de <__divsi3+0x72>
     58c:	0c03      	lsrs	r3, r0, #16
     58e:	428b      	cmp	r3, r1
     590:	d30d      	bcc.n	5ae <__divsi3+0x42>
     592:	22ff      	movs	r2, #255	; 0xff
     594:	0209      	lsls	r1, r1, #8
     596:	ba12      	rev	r2, r2
     598:	0c03      	lsrs	r3, r0, #16
     59a:	428b      	cmp	r3, r1
     59c:	d302      	bcc.n	5a4 <__divsi3+0x38>
     59e:	1212      	asrs	r2, r2, #8
     5a0:	0209      	lsls	r1, r1, #8
     5a2:	d065      	beq.n	670 <__divsi3+0x104>
     5a4:	0b03      	lsrs	r3, r0, #12
     5a6:	428b      	cmp	r3, r1
     5a8:	d319      	bcc.n	5de <__divsi3+0x72>
     5aa:	e000      	b.n	5ae <__divsi3+0x42>
     5ac:	0a09      	lsrs	r1, r1, #8
     5ae:	0bc3      	lsrs	r3, r0, #15
     5b0:	428b      	cmp	r3, r1
     5b2:	d301      	bcc.n	5b8 <__divsi3+0x4c>
     5b4:	03cb      	lsls	r3, r1, #15
     5b6:	1ac0      	subs	r0, r0, r3
     5b8:	4152      	adcs	r2, r2
     5ba:	0b83      	lsrs	r3, r0, #14
     5bc:	428b      	cmp	r3, r1
     5be:	d301      	bcc.n	5c4 <__divsi3+0x58>
     5c0:	038b      	lsls	r3, r1, #14
     5c2:	1ac0      	subs	r0, r0, r3
     5c4:	4152      	adcs	r2, r2
     5c6:	0b43      	lsrs	r3, r0, #13
     5c8:	428b      	cmp	r3, r1
     5ca:	d301      	bcc.n	5d0 <__divsi3+0x64>
     5cc:	034b      	lsls	r3, r1, #13
     5ce:	1ac0      	subs	r0, r0, r3
     5d0:	4152      	adcs	r2, r2
     5d2:	0b03      	lsrs	r3, r0, #12
     5d4:	428b      	cmp	r3, r1
     5d6:	d301      	bcc.n	5dc <__divsi3+0x70>
     5d8:	030b      	lsls	r3, r1, #12
     5da:	1ac0      	subs	r0, r0, r3
     5dc:	4152      	adcs	r2, r2
     5de:	0ac3      	lsrs	r3, r0, #11
     5e0:	428b      	cmp	r3, r1
     5e2:	d301      	bcc.n	5e8 <__divsi3+0x7c>
     5e4:	02cb      	lsls	r3, r1, #11
     5e6:	1ac0      	subs	r0, r0, r3
     5e8:	4152      	adcs	r2, r2
     5ea:	0a83      	lsrs	r3, r0, #10
     5ec:	428b      	cmp	r3, r1
     5ee:	d301      	bcc.n	5f4 <__divsi3+0x88>
     5f0:	028b      	lsls	r3, r1, #10
     5f2:	1ac0      	subs	r0, r0, r3
     5f4:	4152      	adcs	r2, r2
     5f6:	0a43      	lsrs	r3, r0, #9
     5f8:	428b      	cmp	r3, r1
     5fa:	d301      	bcc.n	600 <__divsi3+0x94>
     5fc:	024b      	lsls	r3, r1, #9
     5fe:	1ac0      	subs	r0, r0, r3
     600:	4152      	adcs	r2, r2
     602:	0a03      	lsrs	r3, r0, #8
     604:	428b      	cmp	r3, r1
     606:	d301      	bcc.n	60c <__divsi3+0xa0>
     608:	020b      	lsls	r3, r1, #8
     60a:	1ac0      	subs	r0, r0, r3
     60c:	4152      	adcs	r2, r2
     60e:	d2cd      	bcs.n	5ac <__divsi3+0x40>
     610:	09c3      	lsrs	r3, r0, #7
     612:	428b      	cmp	r3, r1
     614:	d301      	bcc.n	61a <__divsi3+0xae>
     616:	01cb      	lsls	r3, r1, #7
     618:	1ac0      	subs	r0, r0, r3
     61a:	4152      	adcs	r2, r2
     61c:	0983      	lsrs	r3, r0, #6
     61e:	428b      	cmp	r3, r1
     620:	d301      	bcc.n	626 <__divsi3+0xba>
     622:	018b      	lsls	r3, r1, #6
     624:	1ac0      	subs	r0, r0, r3
     626:	4152      	adcs	r2, r2
     628:	0943      	lsrs	r3, r0, #5
     62a:	428b      	cmp	r3, r1
     62c:	d301      	bcc.n	632 <__divsi3+0xc6>
     62e:	014b      	lsls	r3, r1, #5
     630:	1ac0      	subs	r0, r0, r3
     632:	4152      	adcs	r2, r2
     634:	0903      	lsrs	r3, r0, #4
     636:	428b      	cmp	r3, r1
     638:	d301      	bcc.n	63e <__divsi3+0xd2>
     63a:	010b      	lsls	r3, r1, #4
     63c:	1ac0      	subs	r0, r0, r3
     63e:	4152      	adcs	r2, r2
     640:	08c3      	lsrs	r3, r0, #3
     642:	428b      	cmp	r3, r1
     644:	d301      	bcc.n	64a <__divsi3+0xde>
     646:	00cb      	lsls	r3, r1, #3
     648:	1ac0      	subs	r0, r0, r3
     64a:	4152      	adcs	r2, r2
     64c:	0883      	lsrs	r3, r0, #2
     64e:	428b      	cmp	r3, r1
     650:	d301      	bcc.n	656 <__divsi3+0xea>
     652:	008b      	lsls	r3, r1, #2
     654:	1ac0      	subs	r0, r0, r3
     656:	4152      	adcs	r2, r2
     658:	0843      	lsrs	r3, r0, #1
     65a:	428b      	cmp	r3, r1
     65c:	d301      	bcc.n	662 <__divsi3+0xf6>
     65e:	004b      	lsls	r3, r1, #1
     660:	1ac0      	subs	r0, r0, r3
     662:	4152      	adcs	r2, r2
     664:	1a41      	subs	r1, r0, r1
     666:	d200      	bcs.n	66a <__divsi3+0xfe>
     668:	4601      	mov	r1, r0
     66a:	4152      	adcs	r2, r2
     66c:	4610      	mov	r0, r2
     66e:	4770      	bx	lr
     670:	e05d      	b.n	72e <__divsi3+0x1c2>
     672:	0fca      	lsrs	r2, r1, #31
     674:	d000      	beq.n	678 <__divsi3+0x10c>
     676:	4249      	negs	r1, r1
     678:	1003      	asrs	r3, r0, #32
     67a:	d300      	bcc.n	67e <__divsi3+0x112>
     67c:	4240      	negs	r0, r0
     67e:	4053      	eors	r3, r2
     680:	2200      	movs	r2, #0
     682:	469c      	mov	ip, r3
     684:	0903      	lsrs	r3, r0, #4
     686:	428b      	cmp	r3, r1
     688:	d32d      	bcc.n	6e6 <__divsi3+0x17a>
     68a:	0a03      	lsrs	r3, r0, #8
     68c:	428b      	cmp	r3, r1
     68e:	d312      	bcc.n	6b6 <__divsi3+0x14a>
     690:	22fc      	movs	r2, #252	; 0xfc
     692:	0189      	lsls	r1, r1, #6
     694:	ba12      	rev	r2, r2
     696:	0a03      	lsrs	r3, r0, #8
     698:	428b      	cmp	r3, r1
     69a:	d30c      	bcc.n	6b6 <__divsi3+0x14a>
     69c:	0189      	lsls	r1, r1, #6
     69e:	1192      	asrs	r2, r2, #6
     6a0:	428b      	cmp	r3, r1
     6a2:	d308      	bcc.n	6b6 <__divsi3+0x14a>
     6a4:	0189      	lsls	r1, r1, #6
     6a6:	1192      	asrs	r2, r2, #6
     6a8:	428b      	cmp	r3, r1
     6aa:	d304      	bcc.n	6b6 <__divsi3+0x14a>
     6ac:	0189      	lsls	r1, r1, #6
     6ae:	d03a      	beq.n	726 <__divsi3+0x1ba>
     6b0:	1192      	asrs	r2, r2, #6
     6b2:	e000      	b.n	6b6 <__divsi3+0x14a>
     6b4:	0989      	lsrs	r1, r1, #6
     6b6:	09c3      	lsrs	r3, r0, #7
     6b8:	428b      	cmp	r3, r1
     6ba:	d301      	bcc.n	6c0 <__divsi3+0x154>
     6bc:	01cb      	lsls	r3, r1, #7
     6be:	1ac0      	subs	r0, r0, r3
     6c0:	4152      	adcs	r2, r2
     6c2:	0983      	lsrs	r3, r0, #6
     6c4:	428b      	cmp	r3, r1
     6c6:	d301      	bcc.n	6cc <__divsi3+0x160>
     6c8:	018b      	lsls	r3, r1, #6
     6ca:	1ac0      	subs	r0, r0, r3
     6cc:	4152      	adcs	r2, r2
     6ce:	0943      	lsrs	r3, r0, #5
     6d0:	428b      	cmp	r3, r1
     6d2:	d301      	bcc.n	6d8 <__divsi3+0x16c>
     6d4:	014b      	lsls	r3, r1, #5
     6d6:	1ac0      	subs	r0, r0, r3
     6d8:	4152      	adcs	r2, r2
     6da:	0903      	lsrs	r3, r0, #4
     6dc:	428b      	cmp	r3, r1
     6de:	d301      	bcc.n	6e4 <__divsi3+0x178>
     6e0:	010b      	lsls	r3, r1, #4
     6e2:	1ac0      	subs	r0, r0, r3
     6e4:	4152      	adcs	r2, r2
     6e6:	08c3      	lsrs	r3, r0, #3
     6e8:	428b      	cmp	r3, r1
     6ea:	d301      	bcc.n	6f0 <__divsi3+0x184>
     6ec:	00cb      	lsls	r3, r1, #3
     6ee:	1ac0      	subs	r0, r0, r3
     6f0:	4152      	adcs	r2, r2
     6f2:	0883      	lsrs	r3, r0, #2
     6f4:	428b      	cmp	r3, r1
     6f6:	d301      	bcc.n	6fc <__divsi3+0x190>
     6f8:	008b      	lsls	r3, r1, #2
     6fa:	1ac0      	subs	r0, r0, r3
     6fc:	4152      	adcs	r2, r2
     6fe:	d2d9      	bcs.n	6b4 <__divsi3+0x148>
     700:	0843      	lsrs	r3, r0, #1
     702:	428b      	cmp	r3, r1
     704:	d301      	bcc.n	70a <__divsi3+0x19e>
     706:	004b      	lsls	r3, r1, #1
     708:	1ac0      	subs	r0, r0, r3
     70a:	4152      	adcs	r2, r2
     70c:	1a41      	subs	r1, r0, r1
     70e:	d200      	bcs.n	712 <__divsi3+0x1a6>
     710:	4601      	mov	r1, r0
     712:	4663      	mov	r3, ip
     714:	4152      	adcs	r2, r2
     716:	105b      	asrs	r3, r3, #1
     718:	4610      	mov	r0, r2
     71a:	d301      	bcc.n	720 <__divsi3+0x1b4>
     71c:	4240      	negs	r0, r0
     71e:	2b00      	cmp	r3, #0
     720:	d500      	bpl.n	724 <__divsi3+0x1b8>
     722:	4249      	negs	r1, r1
     724:	4770      	bx	lr
     726:	4663      	mov	r3, ip
     728:	105b      	asrs	r3, r3, #1
     72a:	d300      	bcc.n	72e <__divsi3+0x1c2>
     72c:	4240      	negs	r0, r0
     72e:	b501      	push	{r0, lr}
     730:	2000      	movs	r0, #0
     732:	f000 f805 	bl	740 <__aeabi_idiv0>
     736:	bd02      	pop	{r1, pc}

00000738 <__aeabi_idivmod>:
     738:	2900      	cmp	r1, #0
     73a:	d0f8      	beq.n	72e <__divsi3+0x1c2>
     73c:	e716      	b.n	56c <__divsi3>
     73e:	4770      	bx	lr

00000740 <__aeabi_idiv0>:
     740:	4770      	bx	lr
     742:	46c0      	nop			; (mov r8, r8)

00000744 <out_char>:
 
}
/********************************************************************/
void
out_char (char ch)
{
     744:	b580      	push	{r7, lr}
     746:	b082      	sub	sp, #8
     748:	af00      	add	r7, sp, #0
     74a:	0002      	movs	r2, r0
     74c:	1dfb      	adds	r3, r7, #7
     74e:	701a      	strb	r2, [r3, #0]
  if (TERM_PORT_NUM == 0)
    uart0_putchar(UART0_BASE_PTR, ch);
     750:	1dfb      	adds	r3, r7, #7
     752:	781b      	ldrb	r3, [r3, #0]
     754:	4a04      	ldr	r2, [pc, #16]	; (768 <out_char+0x24>)
     756:	0019      	movs	r1, r3
     758:	0010      	movs	r0, r2
     75a:	f001 fc31 	bl	1fc0 <uart0_putchar>
  else if (TERM_PORT_NUM == 1)
    uart_putchar(UART1_BASE_PTR, ch);
  else
    uart_putchar(UART2_BASE_PTR, ch);
  
}
     75e:	46c0      	nop			; (mov r8, r8)
     760:	46bd      	mov	sp, r7
     762:	b002      	add	sp, #8
     764:	bd80      	pop	{r7, pc}
     766:	46c0      	nop			; (mov r8, r8)
     768:	4006a000 	.word	0x4006a000

0000076c <printk_putc>:
#define IS_FMT_n(a)     (a & FMT_n)

/********************************************************************/
static void
printk_putc (int c, int *count, PRINTK_INFO *info)
{
     76c:	b580      	push	{r7, lr}
     76e:	b084      	sub	sp, #16
     770:	af00      	add	r7, sp, #0
     772:	60f8      	str	r0, [r7, #12]
     774:	60b9      	str	r1, [r7, #8]
     776:	607a      	str	r2, [r7, #4]
    switch (info->dest)
     778:	687b      	ldr	r3, [r7, #4]
     77a:	681b      	ldr	r3, [r3, #0]
     77c:	2b01      	cmp	r3, #1
     77e:	d002      	beq.n	786 <printk_putc+0x1a>
     780:	2b02      	cmp	r3, #2
     782:	d007      	beq.n	794 <printk_putc+0x28>
        case DEST_STRING:
            *(info->loc) = (unsigned char)c;
            ++(info->loc);
            break;
        default:
            break;
     784:	e011      	b.n	7aa <printk_putc+0x3e>
            info->func((char)c);
     786:	687b      	ldr	r3, [r7, #4]
     788:	685b      	ldr	r3, [r3, #4]
     78a:	68fa      	ldr	r2, [r7, #12]
     78c:	b2d2      	uxtb	r2, r2
     78e:	0010      	movs	r0, r2
     790:	4798      	blx	r3
            break;
     792:	e00a      	b.n	7aa <printk_putc+0x3e>
            *(info->loc) = (unsigned char)c;
     794:	687b      	ldr	r3, [r7, #4]
     796:	689b      	ldr	r3, [r3, #8]
     798:	68fa      	ldr	r2, [r7, #12]
     79a:	b2d2      	uxtb	r2, r2
     79c:	701a      	strb	r2, [r3, #0]
            ++(info->loc);
     79e:	687b      	ldr	r3, [r7, #4]
     7a0:	689b      	ldr	r3, [r3, #8]
     7a2:	1c5a      	adds	r2, r3, #1
     7a4:	687b      	ldr	r3, [r7, #4]
     7a6:	609a      	str	r2, [r3, #8]
            break;
     7a8:	46c0      	nop			; (mov r8, r8)
    }
    *count += 1;
     7aa:	68bb      	ldr	r3, [r7, #8]
     7ac:	681b      	ldr	r3, [r3, #0]
     7ae:	1c5a      	adds	r2, r3, #1
     7b0:	68bb      	ldr	r3, [r7, #8]
     7b2:	601a      	str	r2, [r3, #0]
}
     7b4:	46c0      	nop			; (mov r8, r8)
     7b6:	46bd      	mov	sp, r7
     7b8:	b004      	add	sp, #16
     7ba:	bd80      	pop	{r7, pc}

000007bc <printk_mknumstr>:

/********************************************************************/
static int
printk_mknumstr (char *numstr, void *nump, int neg, int radix)
{
     7bc:	b580      	push	{r7, lr}
     7be:	b08c      	sub	sp, #48	; 0x30
     7c0:	af00      	add	r7, sp, #0
     7c2:	60f8      	str	r0, [r7, #12]
     7c4:	60b9      	str	r1, [r7, #8]
     7c6:	607a      	str	r2, [r7, #4]
     7c8:	603b      	str	r3, [r7, #0]
    unsigned int ua,ub,uc;

    int nlen;
    char *nstrp;

    nlen = 0;
     7ca:	2300      	movs	r3, #0
     7cc:	61fb      	str	r3, [r7, #28]
    nstrp = numstr;
     7ce:	68fb      	ldr	r3, [r7, #12]
     7d0:	61bb      	str	r3, [r7, #24]
    *nstrp++ = '\0';
     7d2:	69bb      	ldr	r3, [r7, #24]
     7d4:	1c5a      	adds	r2, r3, #1
     7d6:	61ba      	str	r2, [r7, #24]
     7d8:	2200      	movs	r2, #0
     7da:	701a      	strb	r2, [r3, #0]

    if (neg)
     7dc:	687b      	ldr	r3, [r7, #4]
     7de:	2b00      	cmp	r3, #0
     7e0:	d032      	beq.n	848 <printk_mknumstr+0x8c>
    {
        a = *(int *)nump;
     7e2:	68bb      	ldr	r3, [r7, #8]
     7e4:	681b      	ldr	r3, [r3, #0]
     7e6:	62fb      	str	r3, [r7, #44]	; 0x2c
        if (a == 0)
     7e8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     7ea:	2b00      	cmp	r3, #0
     7ec:	d128      	bne.n	840 <printk_mknumstr+0x84>
        {
            *nstrp = '0';
     7ee:	69bb      	ldr	r3, [r7, #24]
     7f0:	2230      	movs	r2, #48	; 0x30
     7f2:	701a      	strb	r2, [r3, #0]
            ++nlen;
     7f4:	69fb      	ldr	r3, [r7, #28]
     7f6:	3301      	adds	r3, #1
     7f8:	61fb      	str	r3, [r7, #28]
            goto done;
     7fa:	e057      	b.n	8ac <printk_mknumstr+0xf0>
        }
        while (a != 0)
        {
            b = (int)a / (int)radix;
     7fc:	6839      	ldr	r1, [r7, #0]
     7fe:	6af8      	ldr	r0, [r7, #44]	; 0x2c
     800:	f7ff feb4 	bl	56c <__divsi3>
     804:	0003      	movs	r3, r0
     806:	617b      	str	r3, [r7, #20]
            c = (int)a - ((int)b * (int)radix);
     808:	697b      	ldr	r3, [r7, #20]
     80a:	683a      	ldr	r2, [r7, #0]
     80c:	4353      	muls	r3, r2
     80e:	6afa      	ldr	r2, [r7, #44]	; 0x2c
     810:	1ad3      	subs	r3, r2, r3
     812:	62bb      	str	r3, [r7, #40]	; 0x28
            if (c < 0)
     814:	6abb      	ldr	r3, [r7, #40]	; 0x28
     816:	2b00      	cmp	r3, #0
     818:	da04      	bge.n	824 <printk_mknumstr+0x68>
            {
                c = ~c + 1 + '0';
     81a:	6abb      	ldr	r3, [r7, #40]	; 0x28
     81c:	2230      	movs	r2, #48	; 0x30
     81e:	1ad3      	subs	r3, r2, r3
     820:	62bb      	str	r3, [r7, #40]	; 0x28
     822:	e002      	b.n	82a <printk_mknumstr+0x6e>
            }
            else
            {
                c = c + '0';
     824:	6abb      	ldr	r3, [r7, #40]	; 0x28
     826:	3330      	adds	r3, #48	; 0x30
     828:	62bb      	str	r3, [r7, #40]	; 0x28
            }
            a = b;
     82a:	697b      	ldr	r3, [r7, #20]
     82c:	62fb      	str	r3, [r7, #44]	; 0x2c
            *nstrp++ = (char)c;
     82e:	69bb      	ldr	r3, [r7, #24]
     830:	1c5a      	adds	r2, r3, #1
     832:	61ba      	str	r2, [r7, #24]
     834:	6aba      	ldr	r2, [r7, #40]	; 0x28
     836:	b2d2      	uxtb	r2, r2
     838:	701a      	strb	r2, [r3, #0]
            ++nlen;
     83a:	69fb      	ldr	r3, [r7, #28]
     83c:	3301      	adds	r3, #1
     83e:	61fb      	str	r3, [r7, #28]
        while (a != 0)
     840:	6afb      	ldr	r3, [r7, #44]	; 0x2c
     842:	2b00      	cmp	r3, #0
     844:	d1da      	bne.n	7fc <printk_mknumstr+0x40>
     846:	e031      	b.n	8ac <printk_mknumstr+0xf0>
        }
    }
    else
    {
        ua = *(unsigned int *)nump;
     848:	68bb      	ldr	r3, [r7, #8]
     84a:	681b      	ldr	r3, [r3, #0]
     84c:	627b      	str	r3, [r7, #36]	; 0x24
        if (ua == 0)
     84e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     850:	2b00      	cmp	r3, #0
     852:	d128      	bne.n	8a6 <printk_mknumstr+0xea>
        {
            *nstrp = '0';
     854:	69bb      	ldr	r3, [r7, #24]
     856:	2230      	movs	r2, #48	; 0x30
     858:	701a      	strb	r2, [r3, #0]
            ++nlen;
     85a:	69fb      	ldr	r3, [r7, #28]
     85c:	3301      	adds	r3, #1
     85e:	61fb      	str	r3, [r7, #28]
            goto done;
     860:	e024      	b.n	8ac <printk_mknumstr+0xf0>
        }
        while (ua != 0)
        {
            ub = (unsigned int)ua / (unsigned int)radix;
     862:	683b      	ldr	r3, [r7, #0]
     864:	0019      	movs	r1, r3
     866:	6a78      	ldr	r0, [r7, #36]	; 0x24
     868:	f7ff fdf6 	bl	458 <__udivsi3>
     86c:	0003      	movs	r3, r0
     86e:	613b      	str	r3, [r7, #16]
            uc = (unsigned int)ua - ((unsigned int)ub * (unsigned int)radix);
     870:	683b      	ldr	r3, [r7, #0]
     872:	693a      	ldr	r2, [r7, #16]
     874:	4353      	muls	r3, r2
     876:	6a7a      	ldr	r2, [r7, #36]	; 0x24
     878:	1ad3      	subs	r3, r2, r3
     87a:	623b      	str	r3, [r7, #32]
            if (uc < 10)
     87c:	6a3b      	ldr	r3, [r7, #32]
     87e:	2b09      	cmp	r3, #9
     880:	d803      	bhi.n	88a <printk_mknumstr+0xce>
            {
                uc = uc + '0';
     882:	6a3b      	ldr	r3, [r7, #32]
     884:	3330      	adds	r3, #48	; 0x30
     886:	623b      	str	r3, [r7, #32]
     888:	e002      	b.n	890 <printk_mknumstr+0xd4>
            }
            else
            {
                uc = uc - 10 + 'A';
     88a:	6a3b      	ldr	r3, [r7, #32]
     88c:	3337      	adds	r3, #55	; 0x37
     88e:	623b      	str	r3, [r7, #32]
            }
            ua = ub;
     890:	693b      	ldr	r3, [r7, #16]
     892:	627b      	str	r3, [r7, #36]	; 0x24
            *nstrp++ = (char)uc;
     894:	69bb      	ldr	r3, [r7, #24]
     896:	1c5a      	adds	r2, r3, #1
     898:	61ba      	str	r2, [r7, #24]
     89a:	6a3a      	ldr	r2, [r7, #32]
     89c:	b2d2      	uxtb	r2, r2
     89e:	701a      	strb	r2, [r3, #0]
            ++nlen;
     8a0:	69fb      	ldr	r3, [r7, #28]
     8a2:	3301      	adds	r3, #1
     8a4:	61fb      	str	r3, [r7, #28]
        while (ua != 0)
     8a6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
     8a8:	2b00      	cmp	r3, #0
     8aa:	d1da      	bne.n	862 <printk_mknumstr+0xa6>
        }
    }
    done:
    return nlen;
     8ac:	69fb      	ldr	r3, [r7, #28]
}
     8ae:	0018      	movs	r0, r3
     8b0:	46bd      	mov	sp, r7
     8b2:	b00c      	add	sp, #48	; 0x30
     8b4:	bd80      	pop	{r7, pc}

000008b6 <printk_pad_zero>:

/********************************************************************/
static void
printk_pad_zero (int curlen, int field_width, int *count, PRINTK_INFO *info)
{
     8b6:	b580      	push	{r7, lr}
     8b8:	b086      	sub	sp, #24
     8ba:	af00      	add	r7, sp, #0
     8bc:	60f8      	str	r0, [r7, #12]
     8be:	60b9      	str	r1, [r7, #8]
     8c0:	607a      	str	r2, [r7, #4]
     8c2:	603b      	str	r3, [r7, #0]
    int i;

    for (i = curlen; i < field_width; i++)
     8c4:	68fb      	ldr	r3, [r7, #12]
     8c6:	617b      	str	r3, [r7, #20]
     8c8:	e008      	b.n	8dc <printk_pad_zero+0x26>
    {
        printk_putc('0',count, info);
     8ca:	683a      	ldr	r2, [r7, #0]
     8cc:	687b      	ldr	r3, [r7, #4]
     8ce:	0019      	movs	r1, r3
     8d0:	2030      	movs	r0, #48	; 0x30
     8d2:	f7ff ff4b 	bl	76c <printk_putc>
    for (i = curlen; i < field_width; i++)
     8d6:	697b      	ldr	r3, [r7, #20]
     8d8:	3301      	adds	r3, #1
     8da:	617b      	str	r3, [r7, #20]
     8dc:	697a      	ldr	r2, [r7, #20]
     8de:	68bb      	ldr	r3, [r7, #8]
     8e0:	429a      	cmp	r2, r3
     8e2:	dbf2      	blt.n	8ca <printk_pad_zero+0x14>
    }
}
     8e4:	46c0      	nop			; (mov r8, r8)
     8e6:	46bd      	mov	sp, r7
     8e8:	b006      	add	sp, #24
     8ea:	bd80      	pop	{r7, pc}

000008ec <printk_pad_space>:

/********************************************************************/
static void
printk_pad_space (int curlen, int field_width, int *count, PRINTK_INFO *info)
{
     8ec:	b580      	push	{r7, lr}
     8ee:	b086      	sub	sp, #24
     8f0:	af00      	add	r7, sp, #0
     8f2:	60f8      	str	r0, [r7, #12]
     8f4:	60b9      	str	r1, [r7, #8]
     8f6:	607a      	str	r2, [r7, #4]
     8f8:	603b      	str	r3, [r7, #0]
    int i;

    for (i = curlen; i < field_width; i++)
     8fa:	68fb      	ldr	r3, [r7, #12]
     8fc:	617b      	str	r3, [r7, #20]
     8fe:	e008      	b.n	912 <printk_pad_space+0x26>
    {
        printk_putc(' ',count, info);
     900:	683a      	ldr	r2, [r7, #0]
     902:	687b      	ldr	r3, [r7, #4]
     904:	0019      	movs	r1, r3
     906:	2020      	movs	r0, #32
     908:	f7ff ff30 	bl	76c <printk_putc>
    for (i = curlen; i < field_width; i++)
     90c:	697b      	ldr	r3, [r7, #20]
     90e:	3301      	adds	r3, #1
     910:	617b      	str	r3, [r7, #20]
     912:	697a      	ldr	r2, [r7, #20]
     914:	68bb      	ldr	r3, [r7, #8]
     916:	429a      	cmp	r2, r3
     918:	dbf2      	blt.n	900 <printk_pad_space+0x14>
    }
}
     91a:	46c0      	nop			; (mov r8, r8)
     91c:	46bd      	mov	sp, r7
     91e:	b006      	add	sp, #24
     920:	bd80      	pop	{r7, pc}
	...

00000924 <printk>:

/********************************************************************/
int
printk (PRINTK_INFO *info, const char *fmt, va_list ap)
{
     924:	b580      	push	{r7, lr}
     926:	b09c      	sub	sp, #112	; 0x70
     928:	af00      	add	r7, sp, #0
     92a:	60f8      	str	r0, [r7, #12]
     92c:	60b9      	str	r1, [r7, #8]
     92e:	607a      	str	r2, [r7, #4]
    char vstr[33];
    char *vstrp;
    int vlen;

    int done;
    int count = 0;
     930:	2300      	movs	r3, #0
     932:	61bb      	str	r3, [r7, #24]

    /*
     * Start parsing apart the format string and display appropriate
     * formats and data.
     */
    for (p = (char *)fmt; (c = *p) != 0; p++)
     934:	68bb      	ldr	r3, [r7, #8]
     936:	66fb      	str	r3, [r7, #108]	; 0x6c
     938:	e281      	b.n	e3e <printk+0x51a>
         * All formats begin with a '%' marker.  Special chars like
         * '\n' or '\t' are normally converted to the appropriate
         * character by the __compiler__.  Thus, no need for this
         * routine to account for the '\' character.
         */
        if (c != '%')
     93a:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     93c:	2b25      	cmp	r3, #37	; 0x25
     93e:	d019      	beq.n	974 <printk+0x50>
            /*
             * This needs to be replaced with something like
             * 'out_char()' or call an OS routine.
             */
#ifndef UNIX_DEBUG
            if (c != '\n')
     940:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     942:	2b0a      	cmp	r3, #10
     944:	d007      	beq.n	956 <printk+0x32>
            {
                printk_putc(c, &count, info);
     946:	68fa      	ldr	r2, [r7, #12]
     948:	2318      	movs	r3, #24
     94a:	18f9      	adds	r1, r7, r3
     94c:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     94e:	0018      	movs	r0, r3
     950:	f7ff ff0c 	bl	76c <printk_putc>

            /*
             * By using 'continue', the next iteration of the loop
             * is used, skipping the code that follows.
             */
            continue;
     954:	e270      	b.n	e38 <printk+0x514>
                printk_putc(0x0D /* CR */, &count, info);
     956:	68fa      	ldr	r2, [r7, #12]
     958:	2318      	movs	r3, #24
     95a:	18fb      	adds	r3, r7, r3
     95c:	0019      	movs	r1, r3
     95e:	200d      	movs	r0, #13
     960:	f7ff ff04 	bl	76c <printk_putc>
                printk_putc(0x0A /* LF */, &count, info);
     964:	68fa      	ldr	r2, [r7, #12]
     966:	2318      	movs	r3, #24
     968:	18fb      	adds	r3, r7, r3
     96a:	0019      	movs	r1, r3
     96c:	200a      	movs	r0, #10
     96e:	f7ff fefd 	bl	76c <printk_putc>
            continue;
     972:	e261      	b.n	e38 <printk+0x514>
        }

        /*
         * First check for specification modifier flags.
         */
        flags_used = 0;
     974:	2300      	movs	r3, #0
     976:	65fb      	str	r3, [r7, #92]	; 0x5c
        done = FALSE;
     978:	2300      	movs	r3, #0
     97a:	663b      	str	r3, [r7, #96]	; 0x60
        while (!done)
     97c:	e02b      	b.n	9d6 <printk+0xb2>
        {
            switch (/* c = */ *++p)
     97e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     980:	3301      	adds	r3, #1
     982:	66fb      	str	r3, [r7, #108]	; 0x6c
     984:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     986:	781b      	ldrb	r3, [r3, #0]
     988:	3b20      	subs	r3, #32
     98a:	2b10      	cmp	r3, #16
     98c:	d81d      	bhi.n	9ca <printk+0xa6>
     98e:	009a      	lsls	r2, r3, #2
     990:	4bd5      	ldr	r3, [pc, #852]	; (ce8 <printk+0x3c4>)
     992:	18d3      	adds	r3, r2, r3
     994:	681b      	ldr	r3, [r3, #0]
     996:	469f      	mov	pc, r3
            {
                case '-':
                    flags_used |= FLAGS_MINUS;
     998:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     99a:	2201      	movs	r2, #1
     99c:	4313      	orrs	r3, r2
     99e:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
     9a0:	e019      	b.n	9d6 <printk+0xb2>
                case '+':
                    flags_used |= FLAGS_PLUS;
     9a2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     9a4:	2202      	movs	r2, #2
     9a6:	4313      	orrs	r3, r2
     9a8:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
     9aa:	e014      	b.n	9d6 <printk+0xb2>
                case ' ':
                    flags_used |= FLAGS_SPACE;
     9ac:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     9ae:	2204      	movs	r2, #4
     9b0:	4313      	orrs	r3, r2
     9b2:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
     9b4:	e00f      	b.n	9d6 <printk+0xb2>
                case '0':
                    flags_used |= FLAGS_ZERO;
     9b6:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     9b8:	2208      	movs	r2, #8
     9ba:	4313      	orrs	r3, r2
     9bc:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
     9be:	e00a      	b.n	9d6 <printk+0xb2>
                case '#':
                    flags_used |= FLAGS_POUND;
     9c0:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     9c2:	2210      	movs	r2, #16
     9c4:	4313      	orrs	r3, r2
     9c6:	65fb      	str	r3, [r7, #92]	; 0x5c
                    break;
     9c8:	e005      	b.n	9d6 <printk+0xb2>
                default:
                    /* we've gone one char too far */
                    --p;
     9ca:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     9cc:	3b01      	subs	r3, #1
     9ce:	66fb      	str	r3, [r7, #108]	; 0x6c
                    done = TRUE;
     9d0:	2301      	movs	r3, #1
     9d2:	663b      	str	r3, [r7, #96]	; 0x60
                    break;
     9d4:	46c0      	nop			; (mov r8, r8)
        while (!done)
     9d6:	6e3b      	ldr	r3, [r7, #96]	; 0x60
     9d8:	2b00      	cmp	r3, #0
     9da:	d0d0      	beq.n	97e <printk+0x5a>
        }

        /*
         * Next check for minimum field width.
         */
        field_width = 0;
     9dc:	2300      	movs	r3, #0
     9de:	65bb      	str	r3, [r7, #88]	; 0x58
        done = FALSE;
     9e0:	2300      	movs	r3, #0
     9e2:	663b      	str	r3, [r7, #96]	; 0x60
        while (!done)
     9e4:	e01a      	b.n	a1c <printk+0xf8>
        {
            switch (c = *++p)
     9e6:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     9e8:	3301      	adds	r3, #1
     9ea:	66fb      	str	r3, [r7, #108]	; 0x6c
     9ec:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     9ee:	781b      	ldrb	r3, [r3, #0]
     9f0:	64bb      	str	r3, [r7, #72]	; 0x48
     9f2:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     9f4:	3b30      	subs	r3, #48	; 0x30
     9f6:	2b09      	cmp	r3, #9
     9f8:	d80a      	bhi.n	a10 <printk+0xec>
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    field_width = (field_width * 10) + (c - '0');
     9fa:	6dba      	ldr	r2, [r7, #88]	; 0x58
     9fc:	0013      	movs	r3, r2
     9fe:	009b      	lsls	r3, r3, #2
     a00:	189b      	adds	r3, r3, r2
     a02:	005b      	lsls	r3, r3, #1
     a04:	001a      	movs	r2, r3
     a06:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     a08:	3b30      	subs	r3, #48	; 0x30
     a0a:	18d3      	adds	r3, r2, r3
     a0c:	65bb      	str	r3, [r7, #88]	; 0x58
                    break;
     a0e:	e005      	b.n	a1c <printk+0xf8>
                default:
                    /* we've gone one char too far */
                    --p;
     a10:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a12:	3b01      	subs	r3, #1
     a14:	66fb      	str	r3, [r7, #108]	; 0x6c
                    done = TRUE;
     a16:	2301      	movs	r3, #1
     a18:	663b      	str	r3, [r7, #96]	; 0x60
                    break;
     a1a:	46c0      	nop			; (mov r8, r8)
        while (!done)
     a1c:	6e3b      	ldr	r3, [r7, #96]	; 0x60
     a1e:	2b00      	cmp	r3, #0
     a20:	d0e1      	beq.n	9e6 <printk+0xc2>
        }

        /*
         * Next check for the width and precision field separator.
         */
        if (*++p == '.')
     a22:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a24:	3301      	adds	r3, #1
     a26:	66fb      	str	r3, [r7, #108]	; 0x6c
     a28:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a2a:	781b      	ldrb	r3, [r3, #0]
     a2c:	2b2e      	cmp	r3, #46	; 0x2e
     a2e:	d115      	bne.n	a5c <printk+0x138>
        {

            /*
             * Must get precision field width, if present.
             */
            done = FALSE;
     a30:	2300      	movs	r3, #0
     a32:	663b      	str	r3, [r7, #96]	; 0x60
            while (!done)
     a34:	e00e      	b.n	a54 <printk+0x130>
            {
                switch (/* c = uncomment if used below */ *++p)
     a36:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a38:	3301      	adds	r3, #1
     a3a:	66fb      	str	r3, [r7, #108]	; 0x6c
     a3c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a3e:	781b      	ldrb	r3, [r3, #0]
     a40:	3b30      	subs	r3, #48	; 0x30
     a42:	2b09      	cmp	r3, #9
     a44:	d800      	bhi.n	a48 <printk+0x124>
                    case '9':
#if 0
                        precision_width = (precision_width * 10) +
                            (c - '0');
#endif
                        break;
     a46:	e005      	b.n	a54 <printk+0x130>
                    default:
                        /* we've gone one char too far */
                        --p;
     a48:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a4a:	3b01      	subs	r3, #1
     a4c:	66fb      	str	r3, [r7, #108]	; 0x6c
                        done = TRUE;
     a4e:	2301      	movs	r3, #1
     a50:	663b      	str	r3, [r7, #96]	; 0x60
                        break;
     a52:	46c0      	nop			; (mov r8, r8)
            while (!done)
     a54:	6e3b      	ldr	r3, [r7, #96]	; 0x60
     a56:	2b00      	cmp	r3, #0
     a58:	d0ed      	beq.n	a36 <printk+0x112>
     a5a:	e002      	b.n	a62 <printk+0x13e>
            }
        }
        else
        {
            /* we've gone one char too far */
            --p;
     a5c:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a5e:	3b01      	subs	r3, #1
     a60:	66fb      	str	r3, [r7, #108]	; 0x6c
        }

        /*
         * Check for the length modifier.
         */
        switch (*++p)
     a62:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a64:	3301      	adds	r3, #1
     a66:	66fb      	str	r3, [r7, #108]	; 0x6c
     a68:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a6a:	781b      	ldrb	r3, [r3, #0]
     a6c:	2b68      	cmp	r3, #104	; 0x68
     a6e:	d007      	beq.n	a80 <printk+0x15c>
     a70:	2b6c      	cmp	r3, #108	; 0x6c
     a72:	d007      	beq.n	a84 <printk+0x160>
     a74:	2b4c      	cmp	r3, #76	; 0x4c
     a76:	d007      	beq.n	a88 <printk+0x164>
                break;
            case 'L':
                break;
            default:
                /* we've gone one char too far */
                --p;
     a78:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a7a:	3b01      	subs	r3, #1
     a7c:	66fb      	str	r3, [r7, #108]	; 0x6c
                break;
     a7e:	e004      	b.n	a8a <printk+0x166>
                break;
     a80:	46c0      	nop			; (mov r8, r8)
     a82:	e002      	b.n	a8a <printk+0x166>
                break;
     a84:	46c0      	nop			; (mov r8, r8)
     a86:	e000      	b.n	a8a <printk+0x166>
                break;
     a88:	46c0      	nop			; (mov r8, r8)
        }

        /*
         * Now we're ready to examine the format.
         */
        switch (c = *++p)
     a8a:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a8c:	3301      	adds	r3, #1
     a8e:	66fb      	str	r3, [r7, #108]	; 0x6c
     a90:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     a92:	781b      	ldrb	r3, [r3, #0]
     a94:	64bb      	str	r3, [r7, #72]	; 0x48
     a96:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     a98:	3b58      	subs	r3, #88	; 0x58
     a9a:	2b20      	cmp	r3, #32
     a9c:	d900      	bls.n	aa0 <printk+0x17c>
     a9e:	e1c0      	b.n	e22 <printk+0x4fe>
     aa0:	009a      	lsls	r2, r3, #2
     aa2:	4b92      	ldr	r3, [pc, #584]	; (cec <printk+0x3c8>)
     aa4:	18d3      	adds	r3, r2, r3
     aa6:	681b      	ldr	r3, [r3, #0]
     aa8:	469f      	mov	pc, r3
        {
            case 'd':
            case 'i':
                ival = (int)va_arg(ap, int);
     aaa:	687b      	ldr	r3, [r7, #4]
     aac:	1d1a      	adds	r2, r3, #4
     aae:	607a      	str	r2, [r7, #4]
     ab0:	681b      	ldr	r3, [r3, #0]
     ab2:	617b      	str	r3, [r7, #20]
                vlen = printk_mknumstr(vstr,&ival,TRUE,10);
     ab4:	2314      	movs	r3, #20
     ab6:	18f9      	adds	r1, r7, r3
     ab8:	231c      	movs	r3, #28
     aba:	18f8      	adds	r0, r7, r3
     abc:	230a      	movs	r3, #10
     abe:	2201      	movs	r2, #1
     ac0:	f7ff fe7c 	bl	7bc <printk_mknumstr>
     ac4:	0003      	movs	r3, r0
     ac6:	667b      	str	r3, [r7, #100]	; 0x64
                vstrp = &vstr[vlen];
     ac8:	231c      	movs	r3, #28
     aca:	18fa      	adds	r2, r7, r3
     acc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     ace:	18d3      	adds	r3, r2, r3
     ad0:	66bb      	str	r3, [r7, #104]	; 0x68

                if (ival < 0)
     ad2:	697b      	ldr	r3, [r7, #20]
     ad4:	2b00      	cmp	r3, #0
     ad6:	da05      	bge.n	ae4 <printk+0x1c0>
                {
                    schar = '-';
     ad8:	232d      	movs	r3, #45	; 0x2d
     ada:	657b      	str	r3, [r7, #84]	; 0x54
                    ++vlen;
     adc:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     ade:	3301      	adds	r3, #1
     ae0:	667b      	str	r3, [r7, #100]	; 0x64
     ae2:	e015      	b.n	b10 <printk+0x1ec>
                }
                else
                {
                    if (IS_FLAG_PLUS(flags_used))
     ae4:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     ae6:	2202      	movs	r2, #2
     ae8:	4013      	ands	r3, r2
     aea:	d005      	beq.n	af8 <printk+0x1d4>
                    {
                        schar = '+';
     aec:	232b      	movs	r3, #43	; 0x2b
     aee:	657b      	str	r3, [r7, #84]	; 0x54
                        ++vlen;
     af0:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     af2:	3301      	adds	r3, #1
     af4:	667b      	str	r3, [r7, #100]	; 0x64
     af6:	e00b      	b.n	b10 <printk+0x1ec>
                    }
                    else
                    {
                        if (IS_FLAG_SPACE(flags_used))
     af8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     afa:	2204      	movs	r2, #4
     afc:	4013      	ands	r3, r2
     afe:	d005      	beq.n	b0c <printk+0x1e8>
                        {
                            schar = ' ';
     b00:	2320      	movs	r3, #32
     b02:	657b      	str	r3, [r7, #84]	; 0x54
                            ++vlen;
     b04:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     b06:	3301      	adds	r3, #1
     b08:	667b      	str	r3, [r7, #100]	; 0x64
     b0a:	e001      	b.n	b10 <printk+0x1ec>
                        }
                        else
                        {
                            schar = 0;
     b0c:	2300      	movs	r3, #0
     b0e:	657b      	str	r3, [r7, #84]	; 0x54
                        }
                    }
                }
                dschar = FALSE;
     b10:	2300      	movs	r3, #0
     b12:	653b      	str	r3, [r7, #80]	; 0x50
            
                /*
                 * do the ZERO pad.
                 */
                if (IS_FLAG_ZERO(flags_used))
     b14:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     b16:	2208      	movs	r2, #8
     b18:	4013      	ands	r3, r2
     b1a:	d015      	beq.n	b48 <printk+0x224>
                {
                    if (schar)
     b1c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b1e:	2b00      	cmp	r3, #0
     b20:	d006      	beq.n	b30 <printk+0x20c>
                        printk_putc(schar, &count, info);
     b22:	68fa      	ldr	r2, [r7, #12]
     b24:	2318      	movs	r3, #24
     b26:	18f9      	adds	r1, r7, r3
     b28:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b2a:	0018      	movs	r0, r3
     b2c:	f7ff fe1e 	bl	76c <printk_putc>
                    dschar = TRUE;
     b30:	2301      	movs	r3, #1
     b32:	653b      	str	r3, [r7, #80]	; 0x50
            
                    printk_pad_zero (vlen, field_width, &count, info);
     b34:	68fb      	ldr	r3, [r7, #12]
     b36:	2218      	movs	r2, #24
     b38:	18ba      	adds	r2, r7, r2
     b3a:	6db9      	ldr	r1, [r7, #88]	; 0x58
     b3c:	6e78      	ldr	r0, [r7, #100]	; 0x64
     b3e:	f7ff feba 	bl	8b6 <printk_pad_zero>
                    vlen = field_width;
     b42:	6dbb      	ldr	r3, [r7, #88]	; 0x58
     b44:	667b      	str	r3, [r7, #100]	; 0x64
     b46:	e016      	b.n	b76 <printk+0x252>
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
     b48:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     b4a:	2201      	movs	r2, #1
     b4c:	4013      	ands	r3, r2
     b4e:	d112      	bne.n	b76 <printk+0x252>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
     b50:	68fb      	ldr	r3, [r7, #12]
     b52:	2218      	movs	r2, #24
     b54:	18ba      	adds	r2, r7, r2
     b56:	6db9      	ldr	r1, [r7, #88]	; 0x58
     b58:	6e78      	ldr	r0, [r7, #100]	; 0x64
     b5a:	f7ff fec7 	bl	8ec <printk_pad_space>
            
                        if (schar)
     b5e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b60:	2b00      	cmp	r3, #0
     b62:	d006      	beq.n	b72 <printk+0x24e>
                            printk_putc(schar, &count, info);
     b64:	68fa      	ldr	r2, [r7, #12]
     b66:	2318      	movs	r3, #24
     b68:	18f9      	adds	r1, r7, r3
     b6a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b6c:	0018      	movs	r0, r3
     b6e:	f7ff fdfd 	bl	76c <printk_putc>
                        dschar = TRUE;
     b72:	2301      	movs	r3, #1
     b74:	653b      	str	r3, [r7, #80]	; 0x50
                    }
                }
            
                /* the string was built in reverse order, now display in */
                /* correct order */
                if (!dschar && schar)
     b76:	6d3b      	ldr	r3, [r7, #80]	; 0x50
     b78:	2b00      	cmp	r3, #0
     b7a:	d000      	beq.n	b7e <printk+0x25a>
     b7c:	e0e6      	b.n	d4c <printk+0x428>
     b7e:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b80:	2b00      	cmp	r3, #0
     b82:	d100      	bne.n	b86 <printk+0x262>
     b84:	e0e2      	b.n	d4c <printk+0x428>
                {
                    printk_putc(schar, &count, info);
     b86:	68fa      	ldr	r2, [r7, #12]
     b88:	2318      	movs	r3, #24
     b8a:	18f9      	adds	r1, r7, r3
     b8c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
     b8e:	0018      	movs	r0, r3
     b90:	f7ff fdec 	bl	76c <printk_putc>
                }
                goto cont_xd;
     b94:	e0da      	b.n	d4c <printk+0x428>

            case 'x':
            case 'X':
                uval = (unsigned int)va_arg(ap, unsigned int);
     b96:	687b      	ldr	r3, [r7, #4]
     b98:	1d1a      	adds	r2, r3, #4
     b9a:	607a      	str	r2, [r7, #4]
     b9c:	681b      	ldr	r3, [r3, #0]
     b9e:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
     ba0:	2310      	movs	r3, #16
     ba2:	18f9      	adds	r1, r7, r3
     ba4:	231c      	movs	r3, #28
     ba6:	18f8      	adds	r0, r7, r3
     ba8:	2310      	movs	r3, #16
     baa:	2200      	movs	r2, #0
     bac:	f7ff fe06 	bl	7bc <printk_mknumstr>
     bb0:	0003      	movs	r3, r0
     bb2:	667b      	str	r3, [r7, #100]	; 0x64
                vstrp = &vstr[vlen];
     bb4:	231c      	movs	r3, #28
     bb6:	18fa      	adds	r2, r7, r3
     bb8:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     bba:	18d3      	adds	r3, r2, r3
     bbc:	66bb      	str	r3, [r7, #104]	; 0x68

                dschar = FALSE;
     bbe:	2300      	movs	r3, #0
     bc0:	653b      	str	r3, [r7, #80]	; 0x50
                if (IS_FLAG_ZERO(flags_used))
     bc2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     bc4:	2208      	movs	r2, #8
     bc6:	4013      	ands	r3, r2
     bc8:	d01d      	beq.n	c06 <printk+0x2e2>
                {
                    if (IS_FLAG_POUND(flags_used))
     bca:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     bcc:	2210      	movs	r2, #16
     bce:	4013      	ands	r3, r2
     bd0:	d00f      	beq.n	bf2 <printk+0x2ce>
                    {
                        printk_putc('0', &count, info);
     bd2:	68fa      	ldr	r2, [r7, #12]
     bd4:	2318      	movs	r3, #24
     bd6:	18fb      	adds	r3, r7, r3
     bd8:	0019      	movs	r1, r3
     bda:	2030      	movs	r0, #48	; 0x30
     bdc:	f7ff fdc6 	bl	76c <printk_putc>
                        printk_putc('x', &count, info);
     be0:	68fa      	ldr	r2, [r7, #12]
     be2:	2318      	movs	r3, #24
     be4:	18fb      	adds	r3, r7, r3
     be6:	0019      	movs	r1, r3
     be8:	2078      	movs	r0, #120	; 0x78
     bea:	f7ff fdbf 	bl	76c <printk_putc>
                        /*vlen += 2;*/
                        dschar = TRUE;
     bee:	2301      	movs	r3, #1
     bf0:	653b      	str	r3, [r7, #80]	; 0x50
                    }
                    printk_pad_zero (vlen, field_width, &count, info);
     bf2:	68fb      	ldr	r3, [r7, #12]
     bf4:	2218      	movs	r2, #24
     bf6:	18ba      	adds	r2, r7, r2
     bf8:	6db9      	ldr	r1, [r7, #88]	; 0x58
     bfa:	6e78      	ldr	r0, [r7, #100]	; 0x64
     bfc:	f7ff fe5b 	bl	8b6 <printk_pad_zero>
                    vlen = field_width;
     c00:	6dbb      	ldr	r3, [r7, #88]	; 0x58
     c02:	667b      	str	r3, [r7, #100]	; 0x64
     c04:	e025      	b.n	c52 <printk+0x32e>
                }
                else
                {
                    if (!IS_FLAG_MINUS(flags_used))
     c06:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     c08:	2201      	movs	r2, #1
     c0a:	4013      	ands	r3, r2
     c0c:	d121      	bne.n	c52 <printk+0x32e>
                    {
                        if (IS_FLAG_POUND(flags_used))
     c0e:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     c10:	2210      	movs	r2, #16
     c12:	4013      	ands	r3, r2
     c14:	d002      	beq.n	c1c <printk+0x2f8>
                        {
                            vlen += 2;
     c16:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     c18:	3302      	adds	r3, #2
     c1a:	667b      	str	r3, [r7, #100]	; 0x64
                        }
                        printk_pad_space (vlen, field_width, &count, info);
     c1c:	68fb      	ldr	r3, [r7, #12]
     c1e:	2218      	movs	r2, #24
     c20:	18ba      	adds	r2, r7, r2
     c22:	6db9      	ldr	r1, [r7, #88]	; 0x58
     c24:	6e78      	ldr	r0, [r7, #100]	; 0x64
     c26:	f7ff fe61 	bl	8ec <printk_pad_space>
                        if (IS_FLAG_POUND(flags_used))
     c2a:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     c2c:	2210      	movs	r2, #16
     c2e:	4013      	ands	r3, r2
     c30:	d00f      	beq.n	c52 <printk+0x32e>
                        {
                            printk_putc('0', &count, info);
     c32:	68fa      	ldr	r2, [r7, #12]
     c34:	2318      	movs	r3, #24
     c36:	18fb      	adds	r3, r7, r3
     c38:	0019      	movs	r1, r3
     c3a:	2030      	movs	r0, #48	; 0x30
     c3c:	f7ff fd96 	bl	76c <printk_putc>
                            printk_putc('x', &count, info);
     c40:	68fa      	ldr	r2, [r7, #12]
     c42:	2318      	movs	r3, #24
     c44:	18fb      	adds	r3, r7, r3
     c46:	0019      	movs	r1, r3
     c48:	2078      	movs	r0, #120	; 0x78
     c4a:	f7ff fd8f 	bl	76c <printk_putc>
                            dschar = TRUE;
     c4e:	2301      	movs	r3, #1
     c50:	653b      	str	r3, [r7, #80]	; 0x50
                        }
                    }
                }

                if ((IS_FLAG_POUND(flags_used)) && !dschar)
     c52:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     c54:	2210      	movs	r2, #16
     c56:	4013      	ands	r3, r2
     c58:	d100      	bne.n	c5c <printk+0x338>
     c5a:	e079      	b.n	d50 <printk+0x42c>
     c5c:	6d3b      	ldr	r3, [r7, #80]	; 0x50
     c5e:	2b00      	cmp	r3, #0
     c60:	d000      	beq.n	c64 <printk+0x340>
     c62:	e075      	b.n	d50 <printk+0x42c>
                {
                    printk_putc('0', &count, info);
     c64:	68fa      	ldr	r2, [r7, #12]
     c66:	2318      	movs	r3, #24
     c68:	18fb      	adds	r3, r7, r3
     c6a:	0019      	movs	r1, r3
     c6c:	2030      	movs	r0, #48	; 0x30
     c6e:	f7ff fd7d 	bl	76c <printk_putc>
                    printk_putc('x', &count, info);
     c72:	68fa      	ldr	r2, [r7, #12]
     c74:	2318      	movs	r3, #24
     c76:	18fb      	adds	r3, r7, r3
     c78:	0019      	movs	r1, r3
     c7a:	2078      	movs	r0, #120	; 0x78
     c7c:	f7ff fd76 	bl	76c <printk_putc>
                    vlen += 2;
     c80:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     c82:	3302      	adds	r3, #2
     c84:	667b      	str	r3, [r7, #100]	; 0x64
                }
                goto cont_xd;
     c86:	e063      	b.n	d50 <printk+0x42c>

            case 'o':
                uval = (unsigned int)va_arg(ap, unsigned int);
     c88:	687b      	ldr	r3, [r7, #4]
     c8a:	1d1a      	adds	r2, r3, #4
     c8c:	607a      	str	r2, [r7, #4]
     c8e:	681b      	ldr	r3, [r3, #0]
     c90:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,8);
     c92:	2310      	movs	r3, #16
     c94:	18f9      	adds	r1, r7, r3
     c96:	231c      	movs	r3, #28
     c98:	18f8      	adds	r0, r7, r3
     c9a:	2308      	movs	r3, #8
     c9c:	2200      	movs	r2, #0
     c9e:	f7ff fd8d 	bl	7bc <printk_mknumstr>
     ca2:	0003      	movs	r3, r0
     ca4:	667b      	str	r3, [r7, #100]	; 0x64
                goto cont_u;
     ca6:	e032      	b.n	d0e <printk+0x3ea>
            case 'b':
                uval = (unsigned int)va_arg(ap, unsigned int);
     ca8:	687b      	ldr	r3, [r7, #4]
     caa:	1d1a      	adds	r2, r3, #4
     cac:	607a      	str	r2, [r7, #4]
     cae:	681b      	ldr	r3, [r3, #0]
     cb0:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,2);
     cb2:	2310      	movs	r3, #16
     cb4:	18f9      	adds	r1, r7, r3
     cb6:	231c      	movs	r3, #28
     cb8:	18f8      	adds	r0, r7, r3
     cba:	2302      	movs	r3, #2
     cbc:	2200      	movs	r2, #0
     cbe:	f7ff fd7d 	bl	7bc <printk_mknumstr>
     cc2:	0003      	movs	r3, r0
     cc4:	667b      	str	r3, [r7, #100]	; 0x64
                goto cont_u;
     cc6:	e022      	b.n	d0e <printk+0x3ea>
            case 'p':
                uval = (unsigned int)va_arg(ap, void *);
     cc8:	687b      	ldr	r3, [r7, #4]
     cca:	1d1a      	adds	r2, r3, #4
     ccc:	607a      	str	r2, [r7, #4]
     cce:	681b      	ldr	r3, [r3, #0]
     cd0:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,16);
     cd2:	2310      	movs	r3, #16
     cd4:	18f9      	adds	r1, r7, r3
     cd6:	231c      	movs	r3, #28
     cd8:	18f8      	adds	r0, r7, r3
     cda:	2310      	movs	r3, #16
     cdc:	2200      	movs	r2, #0
     cde:	f7ff fd6d 	bl	7bc <printk_mknumstr>
     ce2:	0003      	movs	r3, r0
     ce4:	667b      	str	r3, [r7, #100]	; 0x64
                goto cont_u;
     ce6:	e012      	b.n	d0e <printk+0x3ea>
     ce8:	00004818 	.word	0x00004818
     cec:	0000485c 	.word	0x0000485c
            case 'u':
                uval = (unsigned int)va_arg(ap, unsigned int);
     cf0:	687b      	ldr	r3, [r7, #4]
     cf2:	1d1a      	adds	r2, r3, #4
     cf4:	607a      	str	r2, [r7, #4]
     cf6:	681b      	ldr	r3, [r3, #0]
     cf8:	613b      	str	r3, [r7, #16]
                vlen = printk_mknumstr(vstr,&uval,FALSE,10);
     cfa:	2310      	movs	r3, #16
     cfc:	18f9      	adds	r1, r7, r3
     cfe:	231c      	movs	r3, #28
     d00:	18f8      	adds	r0, r7, r3
     d02:	230a      	movs	r3, #10
     d04:	2200      	movs	r2, #0
     d06:	f7ff fd59 	bl	7bc <printk_mknumstr>
     d0a:	0003      	movs	r3, r0
     d0c:	667b      	str	r3, [r7, #100]	; 0x64

                cont_u:
                    vstrp = &vstr[vlen];
     d0e:	231c      	movs	r3, #28
     d10:	18fa      	adds	r2, r7, r3
     d12:	6e7b      	ldr	r3, [r7, #100]	; 0x64
     d14:	18d3      	adds	r3, r2, r3
     d16:	66bb      	str	r3, [r7, #104]	; 0x68

                    if (IS_FLAG_ZERO(flags_used))
     d18:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d1a:	2208      	movs	r2, #8
     d1c:	4013      	ands	r3, r2
     d1e:	d009      	beq.n	d34 <printk+0x410>
                    {
                        printk_pad_zero (vlen, field_width, &count, info);
     d20:	68fb      	ldr	r3, [r7, #12]
     d22:	2218      	movs	r2, #24
     d24:	18ba      	adds	r2, r7, r2
     d26:	6db9      	ldr	r1, [r7, #88]	; 0x58
     d28:	6e78      	ldr	r0, [r7, #100]	; 0x64
     d2a:	f7ff fdc4 	bl	8b6 <printk_pad_zero>
                        vlen = field_width;
     d2e:	6dbb      	ldr	r3, [r7, #88]	; 0x58
     d30:	667b      	str	r3, [r7, #100]	; 0x64
     d32:	e01a      	b.n	d6a <printk+0x446>
                    }
                    else
                    {
                        if (!IS_FLAG_MINUS(flags_used))
     d34:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d36:	2201      	movs	r2, #1
     d38:	4013      	ands	r3, r2
     d3a:	d116      	bne.n	d6a <printk+0x446>
                        {
                            printk_pad_space (vlen, field_width, &count, info);
     d3c:	68fb      	ldr	r3, [r7, #12]
     d3e:	2218      	movs	r2, #24
     d40:	18ba      	adds	r2, r7, r2
     d42:	6db9      	ldr	r1, [r7, #88]	; 0x58
     d44:	6e78      	ldr	r0, [r7, #100]	; 0x64
     d46:	f7ff fdd1 	bl	8ec <printk_pad_space>
     d4a:	e00e      	b.n	d6a <printk+0x446>
                goto cont_xd;
     d4c:	46c0      	nop			; (mov r8, r8)
     d4e:	e00c      	b.n	d6a <printk+0x446>
                goto cont_xd;
     d50:	46c0      	nop			; (mov r8, r8)
                        }
                    }

                cont_xd:
                    while (*vstrp)
     d52:	e00a      	b.n	d6a <printk+0x446>
                        printk_putc(*vstrp--, &count, info);
     d54:	6ebb      	ldr	r3, [r7, #104]	; 0x68
     d56:	1e5a      	subs	r2, r3, #1
     d58:	66ba      	str	r2, [r7, #104]	; 0x68
     d5a:	781b      	ldrb	r3, [r3, #0]
     d5c:	0018      	movs	r0, r3
     d5e:	68fa      	ldr	r2, [r7, #12]
     d60:	2318      	movs	r3, #24
     d62:	18fb      	adds	r3, r7, r3
     d64:	0019      	movs	r1, r3
     d66:	f7ff fd01 	bl	76c <printk_putc>
                    while (*vstrp)
     d6a:	6ebb      	ldr	r3, [r7, #104]	; 0x68
     d6c:	781b      	ldrb	r3, [r3, #0]
     d6e:	2b00      	cmp	r3, #0
     d70:	d1f0      	bne.n	d54 <printk+0x430>

                    if (IS_FLAG_MINUS(flags_used))
     d72:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     d74:	2201      	movs	r2, #1
     d76:	4013      	ands	r3, r2
     d78:	d05b      	beq.n	e32 <printk+0x50e>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
     d7a:	68fb      	ldr	r3, [r7, #12]
     d7c:	2218      	movs	r2, #24
     d7e:	18ba      	adds	r2, r7, r2
     d80:	6db9      	ldr	r1, [r7, #88]	; 0x58
     d82:	6e78      	ldr	r0, [r7, #100]	; 0x64
     d84:	f7ff fdb2 	bl	8ec <printk_pad_space>
                    }
                break;
     d88:	e053      	b.n	e32 <printk+0x50e>

            case 'c':
                cval = (char)va_arg(ap, unsigned int);
     d8a:	687b      	ldr	r3, [r7, #4]
     d8c:	1d1a      	adds	r2, r3, #4
     d8e:	607a      	str	r2, [r7, #4]
     d90:	681b      	ldr	r3, [r3, #0]
     d92:	b2db      	uxtb	r3, r3
     d94:	647b      	str	r3, [r7, #68]	; 0x44
                printk_putc(cval,&count, info);
     d96:	68fa      	ldr	r2, [r7, #12]
     d98:	2318      	movs	r3, #24
     d9a:	18f9      	adds	r1, r7, r3
     d9c:	6c7b      	ldr	r3, [r7, #68]	; 0x44
     d9e:	0018      	movs	r0, r3
     da0:	f7ff fce4 	bl	76c <printk_putc>
                break;
     da4:	e048      	b.n	e38 <printk+0x514>
            case 's':
                sval = (char *)va_arg(ap, char *);
     da6:	687b      	ldr	r3, [r7, #4]
     da8:	1d1a      	adds	r2, r3, #4
     daa:	607a      	str	r2, [r7, #4]
     dac:	681b      	ldr	r3, [r3, #0]
     dae:	64fb      	str	r3, [r7, #76]	; 0x4c
                if (sval)
     db0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     db2:	2b00      	cmp	r3, #0
     db4:	d03f      	beq.n	e36 <printk+0x512>
                {
                    vlen = strlen(sval);
     db6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     db8:	0018      	movs	r0, r3
     dba:	f000 f8eb 	bl	f94 <strlen>
     dbe:	0003      	movs	r3, r0
     dc0:	667b      	str	r3, [r7, #100]	; 0x64
                    if (!IS_FLAG_MINUS(flags_used))
     dc2:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     dc4:	2201      	movs	r2, #1
     dc6:	4013      	ands	r3, r2
     dc8:	d112      	bne.n	df0 <printk+0x4cc>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
     dca:	68fb      	ldr	r3, [r7, #12]
     dcc:	2218      	movs	r2, #24
     dce:	18ba      	adds	r2, r7, r2
     dd0:	6db9      	ldr	r1, [r7, #88]	; 0x58
     dd2:	6e78      	ldr	r0, [r7, #100]	; 0x64
     dd4:	f7ff fd8a 	bl	8ec <printk_pad_space>
                    }
                    while (*sval)
     dd8:	e00a      	b.n	df0 <printk+0x4cc>
                        printk_putc(*sval++,&count, info);
     dda:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     ddc:	1c5a      	adds	r2, r3, #1
     dde:	64fa      	str	r2, [r7, #76]	; 0x4c
     de0:	781b      	ldrb	r3, [r3, #0]
     de2:	0018      	movs	r0, r3
     de4:	68fa      	ldr	r2, [r7, #12]
     de6:	2318      	movs	r3, #24
     de8:	18fb      	adds	r3, r7, r3
     dea:	0019      	movs	r1, r3
     dec:	f7ff fcbe 	bl	76c <printk_putc>
                    while (*sval)
     df0:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
     df2:	781b      	ldrb	r3, [r3, #0]
     df4:	2b00      	cmp	r3, #0
     df6:	d1f0      	bne.n	dda <printk+0x4b6>
                    if (IS_FLAG_MINUS(flags_used))
     df8:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
     dfa:	2201      	movs	r2, #1
     dfc:	4013      	ands	r3, r2
     dfe:	d01a      	beq.n	e36 <printk+0x512>
                    {
                        printk_pad_space (vlen, field_width, &count, info);
     e00:	68fb      	ldr	r3, [r7, #12]
     e02:	2218      	movs	r2, #24
     e04:	18ba      	adds	r2, r7, r2
     e06:	6db9      	ldr	r1, [r7, #88]	; 0x58
     e08:	6e78      	ldr	r0, [r7, #100]	; 0x64
     e0a:	f7ff fd6f 	bl	8ec <printk_pad_space>
                    }
                }
                break;
     e0e:	e012      	b.n	e36 <printk+0x512>
            case 'n':
                ivalp = (int *)va_arg(ap, int *);
     e10:	687b      	ldr	r3, [r7, #4]
     e12:	1d1a      	adds	r2, r3, #4
     e14:	607a      	str	r2, [r7, #4]
     e16:	681b      	ldr	r3, [r3, #0]
     e18:	643b      	str	r3, [r7, #64]	; 0x40
                *ivalp = count;
     e1a:	69ba      	ldr	r2, [r7, #24]
     e1c:	6c3b      	ldr	r3, [r7, #64]	; 0x40
     e1e:	601a      	str	r2, [r3, #0]
                break;
     e20:	e00a      	b.n	e38 <printk+0x514>
            default:
                printk_putc(c,&count, info);
     e22:	68fa      	ldr	r2, [r7, #12]
     e24:	2318      	movs	r3, #24
     e26:	18f9      	adds	r1, r7, r3
     e28:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     e2a:	0018      	movs	r0, r3
     e2c:	f7ff fc9e 	bl	76c <printk_putc>
                break;
     e30:	e002      	b.n	e38 <printk+0x514>
                break;
     e32:	46c0      	nop			; (mov r8, r8)
     e34:	e000      	b.n	e38 <printk+0x514>
                break;
     e36:	46c0      	nop			; (mov r8, r8)
    for (p = (char *)fmt; (c = *p) != 0; p++)
     e38:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     e3a:	3301      	adds	r3, #1
     e3c:	66fb      	str	r3, [r7, #108]	; 0x6c
     e3e:	6efb      	ldr	r3, [r7, #108]	; 0x6c
     e40:	781b      	ldrb	r3, [r3, #0]
     e42:	64bb      	str	r3, [r7, #72]	; 0x48
     e44:	6cbb      	ldr	r3, [r7, #72]	; 0x48
     e46:	2b00      	cmp	r3, #0
     e48:	d000      	beq.n	e4c <printk+0x528>
     e4a:	e576      	b.n	93a <printk+0x16>
        }
    }
    return count;
     e4c:	69bb      	ldr	r3, [r7, #24]
}
     e4e:	0018      	movs	r0, r3
     e50:	46bd      	mov	sp, r7
     e52:	b01c      	add	sp, #112	; 0x70
     e54:	bd80      	pop	{r7, pc}
     e56:	46c0      	nop			; (mov r8, r8)

00000e58 <printf>:

/********************************************************************/
int
printf (const char *fmt, ...)
{
     e58:	b40f      	push	{r0, r1, r2, r3}
     e5a:	b580      	push	{r7, lr}
     e5c:	b086      	sub	sp, #24
     e5e:	af00      	add	r7, sp, #0
    va_list ap;
    int rvalue;
    PRINTK_INFO info;


    info.dest = DEST_CONSOLE;
     e60:	1d3b      	adds	r3, r7, #4
     e62:	2201      	movs	r2, #1
     e64:	601a      	str	r2, [r3, #0]
    info.func = &out_char;
     e66:	1d3b      	adds	r3, r7, #4
     e68:	4a0a      	ldr	r2, [pc, #40]	; (e94 <printf+0x3c>)
     e6a:	605a      	str	r2, [r3, #4]
    /*
     * Initialize the pointer to the variable length argument list.
     */
    va_start(ap, fmt);
     e6c:	2324      	movs	r3, #36	; 0x24
     e6e:	18fb      	adds	r3, r7, r3
     e70:	613b      	str	r3, [r7, #16]
    rvalue = printk(&info, fmt, ap);
     e72:	693a      	ldr	r2, [r7, #16]
     e74:	6a39      	ldr	r1, [r7, #32]
     e76:	1d3b      	adds	r3, r7, #4
     e78:	0018      	movs	r0, r3
     e7a:	f7ff fd53 	bl	924 <printk>
     e7e:	0003      	movs	r3, r0
     e80:	617b      	str	r3, [r7, #20]
    /*
     * Cleanup the variable length argument list.
     */
    va_end(ap);
    return rvalue;
     e82:	697b      	ldr	r3, [r7, #20]
}
     e84:	0018      	movs	r0, r3
     e86:	46bd      	mov	sp, r7
     e88:	b006      	add	sp, #24
     e8a:	bc80      	pop	{r7}
     e8c:	bc08      	pop	{r3}
     e8e:	b004      	add	sp, #16
     e90:	4718      	bx	r3
     e92:	46c0      	nop			; (mov r8, r8)
     e94:	00000745 	.word	0x00000745

00000e98 <sprintf>:

/********************************************************************/
int
sprintf (char *s, const char *fmt, ...)
{
     e98:	b40e      	push	{r1, r2, r3}
     e9a:	b580      	push	{r7, lr}
     e9c:	b089      	sub	sp, #36	; 0x24
     e9e:	af00      	add	r7, sp, #0
     ea0:	6078      	str	r0, [r7, #4]
    va_list ap;
    int rvalue = 0;
     ea2:	2300      	movs	r3, #0
     ea4:	61fb      	str	r3, [r7, #28]
    PRINTK_INFO info;

    /*
     * Initialize the pointer to the variable length argument list.
     */
    if (s != 0)
     ea6:	687b      	ldr	r3, [r7, #4]
     ea8:	2b00      	cmp	r3, #0
     eaa:	d018      	beq.n	ede <sprintf+0x46>
    {
        info.dest = DEST_STRING;
     eac:	230c      	movs	r3, #12
     eae:	18fb      	adds	r3, r7, r3
     eb0:	2202      	movs	r2, #2
     eb2:	601a      	str	r2, [r3, #0]
        info.loc = s;
     eb4:	230c      	movs	r3, #12
     eb6:	18fb      	adds	r3, r7, r3
     eb8:	687a      	ldr	r2, [r7, #4]
     eba:	609a      	str	r2, [r3, #8]
        va_start(ap, fmt);
     ebc:	2330      	movs	r3, #48	; 0x30
     ebe:	18fb      	adds	r3, r7, r3
     ec0:	61bb      	str	r3, [r7, #24]
        rvalue = printk(&info, fmt, ap);
     ec2:	69ba      	ldr	r2, [r7, #24]
     ec4:	6af9      	ldr	r1, [r7, #44]	; 0x2c
     ec6:	230c      	movs	r3, #12
     ec8:	18fb      	adds	r3, r7, r3
     eca:	0018      	movs	r0, r3
     ecc:	f7ff fd2a 	bl	924 <printk>
     ed0:	0003      	movs	r3, r0
     ed2:	61fb      	str	r3, [r7, #28]
        *info.loc = '\0';
     ed4:	230c      	movs	r3, #12
     ed6:	18fb      	adds	r3, r7, r3
     ed8:	689b      	ldr	r3, [r3, #8]
     eda:	2200      	movs	r2, #0
     edc:	701a      	strb	r2, [r3, #0]
        va_end(ap);
    }
    return rvalue;
     ede:	69fb      	ldr	r3, [r7, #28]
}
     ee0:	0018      	movs	r0, r3
     ee2:	46bd      	mov	sp, r7
     ee4:	b009      	add	sp, #36	; 0x24
     ee6:	bc80      	pop	{r7}
     ee8:	bc08      	pop	{r3}
     eea:	b003      	add	sp, #12
     eec:	4718      	bx	r3
	...

00000ef0 <common_startup>:
extern unsigned long _estack;

/********************************************************************/
void
common_startup(void)
{
     ef0:	b580      	push	{r7, lr}
     ef2:	b084      	sub	sp, #16
     ef4:	af00      	add	r7, sp, #0
    /* Addresses for VECTOR_TABLE and VECTOR_RAM come from the linker file */
    extern uint32 __VECTOR_TABLE[];
    extern uint32 __VECTOR_RAM[];

    /* Copy the vector table to RAM */
    if (__VECTOR_RAM != __VECTOR_TABLE)
     ef6:	4a1f      	ldr	r2, [pc, #124]	; (f74 <common_startup+0x84>)
     ef8:	4b1f      	ldr	r3, [pc, #124]	; (f78 <common_startup+0x88>)
     efa:	429a      	cmp	r2, r3
     efc:	d012      	beq.n	f24 <common_startup+0x34>
    {
        for (n = 0; n < 0x104; n++)
     efe:	2300      	movs	r3, #0
     f00:	60fb      	str	r3, [r7, #12]
     f02:	e00a      	b.n	f1a <common_startup+0x2a>
            __VECTOR_RAM[n] = __VECTOR_TABLE[n];
     f04:	4b1c      	ldr	r3, [pc, #112]	; (f78 <common_startup+0x88>)
     f06:	68fa      	ldr	r2, [r7, #12]
     f08:	0092      	lsls	r2, r2, #2
     f0a:	58d1      	ldr	r1, [r2, r3]
     f0c:	4b19      	ldr	r3, [pc, #100]	; (f74 <common_startup+0x84>)
     f0e:	68fa      	ldr	r2, [r7, #12]
     f10:	0092      	lsls	r2, r2, #2
     f12:	50d1      	str	r1, [r2, r3]
        for (n = 0; n < 0x104; n++)
     f14:	68fb      	ldr	r3, [r7, #12]
     f16:	3301      	adds	r3, #1
     f18:	60fb      	str	r3, [r7, #12]
     f1a:	68fa      	ldr	r2, [r7, #12]
     f1c:	2304      	movs	r3, #4
     f1e:	33ff      	adds	r3, #255	; 0xff
     f20:	429a      	cmp	r2, r3
     f22:	d9ef      	bls.n	f04 <common_startup+0x14>
    }
    /* Point the VTOR to the new copy of the vector table */
    write_vtor((uint32)__VECTOR_RAM);
     f24:	4b13      	ldr	r3, [pc, #76]	; (f74 <common_startup+0x84>)
     f26:	0018      	movs	r0, r3
     f28:	f000 f850 	bl	fcc <write_vtor>

    /* Data and BSS variables */
	unsigned long *srcdata, *dstdata, *sbss;

	/* Set up the stack pointer */
	asm("ldr r0,=_estack\n\t");
     f2c:	4818      	ldr	r0, [pc, #96]	; (f90 <common_startup+0xa0>)
	asm("mov sp, r0");
     f2e:	4685      	mov	sp, r0

	srcdata = &_sidata;
     f30:	4b12      	ldr	r3, [pc, #72]	; (f7c <common_startup+0x8c>)
     f32:	60bb      	str	r3, [r7, #8]
	dstdata = &_sdata;
     f34:	4b12      	ldr	r3, [pc, #72]	; (f80 <common_startup+0x90>)
     f36:	607b      	str	r3, [r7, #4]
	sbss = &_sbss;
     f38:	4b12      	ldr	r3, [pc, #72]	; (f84 <common_startup+0x94>)
     f3a:	603b      	str	r3, [r7, #0]

	/* Copy data */
	while (dstdata != &_edata) {
     f3c:	e007      	b.n	f4e <common_startup+0x5e>
	*(dstdata++) = *(srcdata++);
     f3e:	687b      	ldr	r3, [r7, #4]
     f40:	1d1a      	adds	r2, r3, #4
     f42:	607a      	str	r2, [r7, #4]
     f44:	68ba      	ldr	r2, [r7, #8]
     f46:	1d11      	adds	r1, r2, #4
     f48:	60b9      	str	r1, [r7, #8]
     f4a:	6812      	ldr	r2, [r2, #0]
     f4c:	601a      	str	r2, [r3, #0]
	while (dstdata != &_edata) {
     f4e:	687a      	ldr	r2, [r7, #4]
     f50:	4b0d      	ldr	r3, [pc, #52]	; (f88 <common_startup+0x98>)
     f52:	429a      	cmp	r2, r3
     f54:	d1f3      	bne.n	f3e <common_startup+0x4e>
	}

	/* Clear BSS */
	while (sbss != &_ebss) {
     f56:	e004      	b.n	f62 <common_startup+0x72>
	*(sbss++) = '\0';
     f58:	683b      	ldr	r3, [r7, #0]
     f5a:	1d1a      	adds	r2, r3, #4
     f5c:	603a      	str	r2, [r7, #0]
     f5e:	2200      	movs	r2, #0
     f60:	601a      	str	r2, [r3, #0]
	while (sbss != &_ebss) {
     f62:	683a      	ldr	r2, [r7, #0]
     f64:	4b09      	ldr	r3, [pc, #36]	; (f8c <common_startup+0x9c>)
     f66:	429a      	cmp	r2, r3
     f68:	d1f6      	bne.n	f58 <common_startup+0x68>
	}
}
     f6a:	46c0      	nop			; (mov r8, r8)
     f6c:	46bd      	mov	sp, r7
     f6e:	b004      	add	sp, #16
     f70:	bd80      	pop	{r7, pc}
     f72:	46c0      	nop			; (mov r8, r8)
     f74:	1ffff000 	.word	0x1ffff000
     f78:	00000000 	.word	0x00000000
     f7c:	00004c88 	.word	0x00004c88
     f80:	1ffff410 	.word	0x1ffff410
     f84:	1ffff498 	.word	0x1ffff498
     f88:	1ffff498 	.word	0x1ffff498
     f8c:	1ffff990 	.word	0x1ffff990
     f90:	20003000 	.word	0x20003000

00000f94 <strlen>:
}

/****************************************************************/
int
strlen (const char *str)
{
     f94:	b580      	push	{r7, lr}
     f96:	b084      	sub	sp, #16
     f98:	af00      	add	r7, sp, #0
     f9a:	6078      	str	r0, [r7, #4]
    char *s = (char *)str;
     f9c:	687b      	ldr	r3, [r7, #4]
     f9e:	60fb      	str	r3, [r7, #12]
    int len = 0;
     fa0:	2300      	movs	r3, #0
     fa2:	60bb      	str	r3, [r7, #8]

    if (s == NULL)
     fa4:	68fb      	ldr	r3, [r7, #12]
     fa6:	2b00      	cmp	r3, #0
     fa8:	d104      	bne.n	fb4 <strlen+0x20>
        return 0;
     faa:	2300      	movs	r3, #0
     fac:	e009      	b.n	fc2 <strlen+0x2e>

    while (*s++ != '\0')
        ++len;
     fae:	68bb      	ldr	r3, [r7, #8]
     fb0:	3301      	adds	r3, #1
     fb2:	60bb      	str	r3, [r7, #8]
    while (*s++ != '\0')
     fb4:	68fb      	ldr	r3, [r7, #12]
     fb6:	1c5a      	adds	r2, r3, #1
     fb8:	60fa      	str	r2, [r7, #12]
     fba:	781b      	ldrb	r3, [r3, #0]
     fbc:	2b00      	cmp	r3, #0
     fbe:	d1f6      	bne.n	fae <strlen+0x1a>

    return len;
     fc0:	68bb      	ldr	r3, [r7, #8]
}
     fc2:	0018      	movs	r0, r3
     fc4:	46bd      	mov	sp, r7
     fc6:	b004      	add	sp, #16
     fc8:	bd80      	pop	{r7, pc}
	...

00000fcc <write_vtor>:
 * Parameters:
 * vtor     new value to write to the VTOR
 */

void write_vtor (int vtor)
{
     fcc:	b580      	push	{r7, lr}
     fce:	b082      	sub	sp, #8
     fd0:	af00      	add	r7, sp, #0
     fd2:	6078      	str	r0, [r7, #4]
        /* Write the VTOR with the new value */
        SCB_VTOR = vtor;	
     fd4:	4903      	ldr	r1, [pc, #12]	; (fe4 <write_vtor+0x18>)
     fd6:	687b      	ldr	r3, [r7, #4]
     fd8:	4a03      	ldr	r2, [pc, #12]	; (fe8 <write_vtor+0x1c>)
     fda:	508b      	str	r3, [r1, r2]
}
     fdc:	46c0      	nop			; (mov r8, r8)
     fde:	46bd      	mov	sp, r7
     fe0:	b002      	add	sp, #8
     fe2:	bd80      	pop	{r7, pc}
     fe4:	e000e000 	.word	0xe000e000
     fe8:	00000d08 	.word	0x00000d08

00000fec <enable_irq>:
 * irq    irq number to be enabled (the irq number NOT the vector number)
 */

#ifndef CMSIS
void enable_irq (int irq)
{   
     fec:	b580      	push	{r7, lr}
     fee:	b082      	sub	sp, #8
     ff0:	af00      	add	r7, sp, #0
     ff2:	6078      	str	r0, [r7, #4]
     * used.
     *
     * NOTE: If you are using the interrupt definitions from the header
     * file, you MUST SUBTRACT 16!!!
     */
    if (irq > 32)
     ff4:	687b      	ldr	r3, [r7, #4]
     ff6:	2b20      	cmp	r3, #32
     ff8:	dd04      	ble.n	1004 <enable_irq+0x18>
        printf("\nERR! Invalid IRQ value passed to enable irq function!\n");
     ffa:	4b17      	ldr	r3, [pc, #92]	; (1058 <enable_irq+0x6c>)
     ffc:	0018      	movs	r0, r3
     ffe:	f7ff ff2b 	bl	e58 <printf>
    {
      /* Set the ICPR and ISER registers accordingly */
      NVIC_ICPR |= 1 << (irq%32);
      NVIC_ISER |= 1 << (irq%32);
    }
}
    1002:	e025      	b.n	1050 <enable_irq+0x64>
      NVIC_ICPR |= 1 << (irq%32);
    1004:	4815      	ldr	r0, [pc, #84]	; (105c <enable_irq+0x70>)
    1006:	4a15      	ldr	r2, [pc, #84]	; (105c <enable_irq+0x70>)
    1008:	23c0      	movs	r3, #192	; 0xc0
    100a:	005b      	lsls	r3, r3, #1
    100c:	58d2      	ldr	r2, [r2, r3]
    100e:	687b      	ldr	r3, [r7, #4]
    1010:	4913      	ldr	r1, [pc, #76]	; (1060 <enable_irq+0x74>)
    1012:	400b      	ands	r3, r1
    1014:	d504      	bpl.n	1020 <enable_irq+0x34>
    1016:	3b01      	subs	r3, #1
    1018:	2120      	movs	r1, #32
    101a:	4249      	negs	r1, r1
    101c:	430b      	orrs	r3, r1
    101e:	3301      	adds	r3, #1
    1020:	0019      	movs	r1, r3
    1022:	2301      	movs	r3, #1
    1024:	408b      	lsls	r3, r1
    1026:	431a      	orrs	r2, r3
    1028:	23c0      	movs	r3, #192	; 0xc0
    102a:	005b      	lsls	r3, r3, #1
    102c:	50c2      	str	r2, [r0, r3]
      NVIC_ISER |= 1 << (irq%32);
    102e:	4a0b      	ldr	r2, [pc, #44]	; (105c <enable_irq+0x70>)
    1030:	4b0a      	ldr	r3, [pc, #40]	; (105c <enable_irq+0x70>)
    1032:	6819      	ldr	r1, [r3, #0]
    1034:	687b      	ldr	r3, [r7, #4]
    1036:	480a      	ldr	r0, [pc, #40]	; (1060 <enable_irq+0x74>)
    1038:	4003      	ands	r3, r0
    103a:	d504      	bpl.n	1046 <enable_irq+0x5a>
    103c:	3b01      	subs	r3, #1
    103e:	2020      	movs	r0, #32
    1040:	4240      	negs	r0, r0
    1042:	4303      	orrs	r3, r0
    1044:	3301      	adds	r3, #1
    1046:	0018      	movs	r0, r3
    1048:	2301      	movs	r3, #1
    104a:	4083      	lsls	r3, r0
    104c:	430b      	orrs	r3, r1
    104e:	6013      	str	r3, [r2, #0]
}
    1050:	46c0      	nop			; (mov r8, r8)
    1052:	46bd      	mov	sp, r7
    1054:	b002      	add	sp, #8
    1056:	bd80      	pop	{r7, pc}
    1058:	00003f68 	.word	0x00003f68
    105c:	e000e100 	.word	0xe000e100
    1060:	8000001f 	.word	0x8000001f

00001064 <start>:
 *
 * This function calls all of the necessary startup routines and then 
 * branches to the main process.
 */
void start(void)
{ 
    1064:	b580      	push	{r7, lr}
    1066:	af00      	add	r7, sp, #0
	/* Disable the watchdog timer */
	SIM_COPC = 0x00;
    1068:	4a09      	ldr	r2, [pc, #36]	; (1090 <start+0x2c>)
    106a:	2388      	movs	r3, #136	; 0x88
    106c:	015b      	lsls	r3, r3, #5
    106e:	2100      	movs	r1, #0
    1070:	50d1      	str	r1, [r2, r3]
#ifndef CMSIS    // If conforming to CMSIS, we do not need to perform this code


	/* Copy any vector or data sections that need to be in RAM */
	common_startup();
    1072:	f7ff ff3d 	bl	ef0 <common_startup>

	/* Perform clock initialization, default UART initialization,
	 * initializes clock out function, and enables the abort button
	 */
	// common_startup();
	sysinit();
    1076:	f000 f9ff 	bl	1478 <sysinit>

	printf("\n\r\n\r");
    107a:	4b06      	ldr	r3, [pc, #24]	; (1094 <start+0x30>)
    107c:	0018      	movs	r0, r3
    107e:	f7ff feeb 	bl	e58 <printf>

	/* Determine the last cause(s) of reset */
	outSRS();	
    1082:	f000 fd69 	bl	1b58 <outSRS>

	/* Determine specific Kinetis L Family device and revision */
	cpu_identify();
    1086:	f000 f807 	bl	1098 <cpu_identify>

#ifndef CMSIS    // If conforming to CMSIS, we do not need to perform this code
	/* Jump to main process */
	main();
    108a:	f001 fa53 	bl	2534 <main>

	/* No actions to perform after this so wait forever */
	while(1);
    108e:	e7fe      	b.n	108e <start+0x2a>
    1090:	40047000 	.word	0x40047000
    1094:	00004058 	.word	0x00004058

00001098 <cpu_identify>:
 * - die revision
 * - P-flash size
 * - Ram size
 */
void cpu_identify (void)
{
    1098:	b580      	push	{r7, lr}
    109a:	b082      	sub	sp, #8
    109c:	af00      	add	r7, sp, #0
	uint16 temp;
	/* Determine the Kinetis family */
	switch((SIM_SDID & SIM_SDID_FAMID(0x7))>>SIM_SDID_FAMID_SHIFT)
    109e:	4a84      	ldr	r2, [pc, #528]	; (12b0 <cpu_identify+0x218>)
    10a0:	4b84      	ldr	r3, [pc, #528]	; (12b4 <cpu_identify+0x21c>)
    10a2:	58d3      	ldr	r3, [r2, r3]
    10a4:	0f1b      	lsrs	r3, r3, #28
    10a6:	2207      	movs	r2, #7
    10a8:	4013      	ands	r3, r2
    10aa:	2b04      	cmp	r3, #4
    10ac:	d81d      	bhi.n	10ea <cpu_identify+0x52>
    10ae:	009a      	lsls	r2, r3, #2
    10b0:	4b81      	ldr	r3, [pc, #516]	; (12b8 <cpu_identify+0x220>)
    10b2:	18d3      	adds	r3, r2, r3
    10b4:	681b      	ldr	r3, [r3, #0]
    10b6:	469f      	mov	pc, r3
	{
	case 0x0:
		printf("\n\rKL0");
    10b8:	4b80      	ldr	r3, [pc, #512]	; (12bc <cpu_identify+0x224>)
    10ba:	0018      	movs	r0, r3
    10bc:	f7ff fecc 	bl	e58 <printf>
		break;
    10c0:	e018      	b.n	10f4 <cpu_identify+0x5c>
	case 0x1:
		printf("\n\rKL1");
    10c2:	4b7f      	ldr	r3, [pc, #508]	; (12c0 <cpu_identify+0x228>)
    10c4:	0018      	movs	r0, r3
    10c6:	f7ff fec7 	bl	e58 <printf>
		break;
    10ca:	e013      	b.n	10f4 <cpu_identify+0x5c>
	case 0x2:
		printf("\n\rKL2");
    10cc:	4b7d      	ldr	r3, [pc, #500]	; (12c4 <cpu_identify+0x22c>)
    10ce:	0018      	movs	r0, r3
    10d0:	f7ff fec2 	bl	e58 <printf>
		break;
    10d4:	e00e      	b.n	10f4 <cpu_identify+0x5c>
	case 0x3:
		printf("\n\rKL3");
    10d6:	4b7c      	ldr	r3, [pc, #496]	; (12c8 <cpu_identify+0x230>)
    10d8:	0018      	movs	r0, r3
    10da:	f7ff febd 	bl	e58 <printf>
		break;
    10de:	e009      	b.n	10f4 <cpu_identify+0x5c>
	case 0x4:
		printf("\n\rKL4");
    10e0:	4b7a      	ldr	r3, [pc, #488]	; (12cc <cpu_identify+0x234>)
    10e2:	0018      	movs	r0, r3
    10e4:	f7ff feb8 	bl	e58 <printf>
		break;
    10e8:	e004      	b.n	10f4 <cpu_identify+0x5c>
	default:
		printf("\n\rUnrecognized Kinetis family device.\n\r");  
    10ea:	4b79      	ldr	r3, [pc, #484]	; (12d0 <cpu_identify+0x238>)
    10ec:	0018      	movs	r0, r3
    10ee:	f7ff feb3 	bl	e58 <printf>
		break;  	
    10f2:	46c0      	nop			; (mov r8, r8)
	}

	/* Determine Sub-Family ID */
	switch((SIM_SDID & SIM_SDID_SUBFAMID(0x7))>>SIM_SDID_SUBFAMID_SHIFT)
    10f4:	4a6e      	ldr	r2, [pc, #440]	; (12b0 <cpu_identify+0x218>)
    10f6:	4b6f      	ldr	r3, [pc, #444]	; (12b4 <cpu_identify+0x21c>)
    10f8:	58d3      	ldr	r3, [r2, r3]
    10fa:	0e1b      	lsrs	r3, r3, #24
    10fc:	2207      	movs	r2, #7
    10fe:	4013      	ands	r3, r2
    1100:	2b04      	cmp	r3, #4
    1102:	d002      	beq.n	110a <cpu_identify+0x72>
    1104:	2b05      	cmp	r3, #5
    1106:	d005      	beq.n	1114 <cpu_identify+0x7c>
    1108:	e009      	b.n	111e <cpu_identify+0x86>
	{
	case 0x4:
		printf("4");
    110a:	4b72      	ldr	r3, [pc, #456]	; (12d4 <cpu_identify+0x23c>)
    110c:	0018      	movs	r0, r3
    110e:	f7ff fea3 	bl	e58 <printf>
		break;
    1112:	e009      	b.n	1128 <cpu_identify+0x90>
	case 0x5:
		printf("5");
    1114:	4b70      	ldr	r3, [pc, #448]	; (12d8 <cpu_identify+0x240>)
    1116:	0018      	movs	r0, r3
    1118:	f7ff fe9e 	bl	e58 <printf>
		break;
    111c:	e004      	b.n	1128 <cpu_identify+0x90>
	default:
		printf("\n\rUnrecognized Kinetis sub-family device.\n\r");  
    111e:	4b6f      	ldr	r3, [pc, #444]	; (12dc <cpu_identify+0x244>)
    1120:	0018      	movs	r0, r3
    1122:	f7ff fe99 	bl	e58 <printf>
		break;  	
    1126:	46c0      	nop			; (mov r8, r8)
	}

	/* Determine the package size */
	switch((SIM_SDID & SIM_SDID_PINID(0xF))>>SIM_SDID_PINID_SHIFT)
    1128:	4a61      	ldr	r2, [pc, #388]	; (12b0 <cpu_identify+0x218>)
    112a:	4b62      	ldr	r3, [pc, #392]	; (12b4 <cpu_identify+0x21c>)
    112c:	58d3      	ldr	r3, [r2, r3]
    112e:	220f      	movs	r2, #15
    1130:	4013      	ands	r3, r2
    1132:	2b08      	cmp	r3, #8
    1134:	d825      	bhi.n	1182 <cpu_identify+0xea>
    1136:	009a      	lsls	r2, r3, #2
    1138:	4b69      	ldr	r3, [pc, #420]	; (12e0 <cpu_identify+0x248>)
    113a:	18d3      	adds	r3, r2, r3
    113c:	681b      	ldr	r3, [r3, #0]
    113e:	469f      	mov	pc, r3
	{
	case 0x0:
		printf("16pin       ");
    1140:	4b68      	ldr	r3, [pc, #416]	; (12e4 <cpu_identify+0x24c>)
    1142:	0018      	movs	r0, r3
    1144:	f7ff fe88 	bl	e58 <printf>
		break;
    1148:	e020      	b.n	118c <cpu_identify+0xf4>
	case 0x1:
		printf("24pin       ");
    114a:	4b67      	ldr	r3, [pc, #412]	; (12e8 <cpu_identify+0x250>)
    114c:	0018      	movs	r0, r3
    114e:	f7ff fe83 	bl	e58 <printf>
		break;
    1152:	e01b      	b.n	118c <cpu_identify+0xf4>
	case 0x2:
		printf("32pin      ");
    1154:	4b65      	ldr	r3, [pc, #404]	; (12ec <cpu_identify+0x254>)
    1156:	0018      	movs	r0, r3
    1158:	f7ff fe7e 	bl	e58 <printf>
		break;
    115c:	e016      	b.n	118c <cpu_identify+0xf4>
	case 0x4:
		printf("48pin      ");
    115e:	4b64      	ldr	r3, [pc, #400]	; (12f0 <cpu_identify+0x258>)
    1160:	0018      	movs	r0, r3
    1162:	f7ff fe79 	bl	e58 <printf>
		break;
    1166:	e011      	b.n	118c <cpu_identify+0xf4>
	case 0x5:
		printf("64pin      ");
    1168:	4b62      	ldr	r3, [pc, #392]	; (12f4 <cpu_identify+0x25c>)
    116a:	0018      	movs	r0, r3
    116c:	f7ff fe74 	bl	e58 <printf>
	case 0x6:
		printf("80pin      ");
    1170:	4b61      	ldr	r3, [pc, #388]	; (12f8 <cpu_identify+0x260>)
    1172:	0018      	movs	r0, r3
    1174:	f7ff fe70 	bl	e58 <printf>
	case 0x8:
		printf("100pin      ");
    1178:	4b60      	ldr	r3, [pc, #384]	; (12fc <cpu_identify+0x264>)
    117a:	0018      	movs	r0, r3
    117c:	f7ff fe6c 	bl	e58 <printf>
		break;
    1180:	e004      	b.n	118c <cpu_identify+0xf4>
	default:
		printf("\n\rUnrecognized Kinetis package code.      ");  
    1182:	4b5f      	ldr	r3, [pc, #380]	; (1300 <cpu_identify+0x268>)
    1184:	0018      	movs	r0, r3
    1186:	f7ff fe67 	bl	e58 <printf>
		break;  	
    118a:	46c0      	nop			; (mov r8, r8)
	}

	/* Determine Attribute ID */
	switch((SIM_SDID & SIM_SDID_SERIESID(0x7))>>SIM_SDID_SERIESID_SHIFT)
    118c:	4a48      	ldr	r2, [pc, #288]	; (12b0 <cpu_identify+0x218>)
    118e:	4b49      	ldr	r3, [pc, #292]	; (12b4 <cpu_identify+0x21c>)
    1190:	58d3      	ldr	r3, [r2, r3]
    1192:	0d1b      	lsrs	r3, r3, #20
    1194:	2207      	movs	r2, #7
    1196:	4013      	ands	r3, r2
    1198:	2b01      	cmp	r3, #1
    119a:	d104      	bne.n	11a6 <cpu_identify+0x10e>
	{
	case 0x1:
		printf("\n\rLow Power Line with Cortex M0+\n\r\n\r");
    119c:	4b59      	ldr	r3, [pc, #356]	; (1304 <cpu_identify+0x26c>)
    119e:	0018      	movs	r0, r3
    11a0:	f7ff fe5a 	bl	e58 <printf>
		break;
    11a4:	e004      	b.n	11b0 <cpu_identify+0x118>
	default:
		printf("\n\rUnrecognized Kinetis family attribute.\n\r");  
    11a6:	4b58      	ldr	r3, [pc, #352]	; (1308 <cpu_identify+0x270>)
    11a8:	0018      	movs	r0, r3
    11aa:	f7ff fe55 	bl	e58 <printf>
		break;  	
    11ae:	46c0      	nop			; (mov r8, r8)
	}

	/* Determine the System SRAM Size */
	switch((SIM_SDID & SIM_SDID_SRAMSIZE(0x7))>>SIM_SDID_SRAMSIZE_SHIFT)
    11b0:	4a3f      	ldr	r2, [pc, #252]	; (12b0 <cpu_identify+0x218>)
    11b2:	4b40      	ldr	r3, [pc, #256]	; (12b4 <cpu_identify+0x21c>)
    11b4:	58d3      	ldr	r3, [r2, r3]
    11b6:	0c1b      	lsrs	r3, r3, #16
    11b8:	2207      	movs	r2, #7
    11ba:	4013      	ands	r3, r2
    11bc:	2b07      	cmp	r3, #7
    11be:	d82c      	bhi.n	121a <cpu_identify+0x182>
    11c0:	009a      	lsls	r2, r3, #2
    11c2:	4b52      	ldr	r3, [pc, #328]	; (130c <cpu_identify+0x274>)
    11c4:	18d3      	adds	r3, r2, r3
    11c6:	681b      	ldr	r3, [r3, #0]
    11c8:	469f      	mov	pc, r3
	{
	case 0x0:
		printf("SRAM Size: 0.5 KB\n\r");
    11ca:	4b51      	ldr	r3, [pc, #324]	; (1310 <cpu_identify+0x278>)
    11cc:	0018      	movs	r0, r3
    11ce:	f7ff fe43 	bl	e58 <printf>
		break;
    11d2:	e027      	b.n	1224 <cpu_identify+0x18c>
	case 0x1:
		printf("SRAM Size:  1 KB\n\r");
    11d4:	4b4f      	ldr	r3, [pc, #316]	; (1314 <cpu_identify+0x27c>)
    11d6:	0018      	movs	r0, r3
    11d8:	f7ff fe3e 	bl	e58 <printf>
		break;
    11dc:	e022      	b.n	1224 <cpu_identify+0x18c>
	case 0x2:
		printf("SRAM Size:  2 KB\n\r");
    11de:	4b4e      	ldr	r3, [pc, #312]	; (1318 <cpu_identify+0x280>)
    11e0:	0018      	movs	r0, r3
    11e2:	f7ff fe39 	bl	e58 <printf>
		break;
    11e6:	e01d      	b.n	1224 <cpu_identify+0x18c>
	case 0x3:
		printf("SRAM Size:  4 KB\n\r");
    11e8:	4b4c      	ldr	r3, [pc, #304]	; (131c <cpu_identify+0x284>)
    11ea:	0018      	movs	r0, r3
    11ec:	f7ff fe34 	bl	e58 <printf>
		break;
    11f0:	e018      	b.n	1224 <cpu_identify+0x18c>
	case 0x4:
		printf("SRAM Size:  8 KB\n\r");
    11f2:	4b4b      	ldr	r3, [pc, #300]	; (1320 <cpu_identify+0x288>)
    11f4:	0018      	movs	r0, r3
    11f6:	f7ff fe2f 	bl	e58 <printf>
		break;
    11fa:	e013      	b.n	1224 <cpu_identify+0x18c>
	case 0x5:
		printf("SRAM Size:  16 KB\n\r");
    11fc:	4b49      	ldr	r3, [pc, #292]	; (1324 <cpu_identify+0x28c>)
    11fe:	0018      	movs	r0, r3
    1200:	f7ff fe2a 	bl	e58 <printf>
		break;
    1204:	e00e      	b.n	1224 <cpu_identify+0x18c>
	case 0x6:
		printf("SRAM Size:  32 KB\n\r");
    1206:	4b48      	ldr	r3, [pc, #288]	; (1328 <cpu_identify+0x290>)
    1208:	0018      	movs	r0, r3
    120a:	f7ff fe25 	bl	e58 <printf>
		break;
    120e:	e009      	b.n	1224 <cpu_identify+0x18c>
	case 0x7:
		printf("SRAM Size:  64 KB\n\r");
    1210:	4b46      	ldr	r3, [pc, #280]	; (132c <cpu_identify+0x294>)
    1212:	0018      	movs	r0, r3
    1214:	f7ff fe20 	bl	e58 <printf>
		break;
    1218:	e004      	b.n	1224 <cpu_identify+0x18c>
	default:
		printf("\n\rUnrecognized SRAM Size.\n\r");  
    121a:	4b45      	ldr	r3, [pc, #276]	; (1330 <cpu_identify+0x298>)
    121c:	0018      	movs	r0, r3
    121e:	f7ff fe1b 	bl	e58 <printf>
		break;  	
    1222:	46c0      	nop			; (mov r8, r8)
	}

	/* Determine the revision ID */
	temp = ((SIM_SDID_REVID(0xF))>>SIM_SDID_REVID_SHIFT);
    1224:	1dbb      	adds	r3, r7, #6
    1226:	220f      	movs	r2, #15
    1228:	801a      	strh	r2, [r3, #0]
	printf("Silicon rev %d\n\r ", temp);
    122a:	1dbb      	adds	r3, r7, #6
    122c:	881a      	ldrh	r2, [r3, #0]
    122e:	4b41      	ldr	r3, [pc, #260]	; (1334 <cpu_identify+0x29c>)
    1230:	0011      	movs	r1, r2
    1232:	0018      	movs	r0, r3
    1234:	f7ff fe10 	bl	e58 <printf>

	/* Determine the flash revision */
	flash_identify();
    1238:	f000 f890 	bl	135c <flash_identify>

	/* Determine the P-flash size */
	switch((SIM_FCFG1 & SIM_FCFG1_PFSIZE(0xF))>>SIM_FCFG1_PFSIZE_SHIFT)
    123c:	4a1c      	ldr	r2, [pc, #112]	; (12b0 <cpu_identify+0x218>)
    123e:	4b3e      	ldr	r3, [pc, #248]	; (1338 <cpu_identify+0x2a0>)
    1240:	58d3      	ldr	r3, [r2, r3]
    1242:	0e1b      	lsrs	r3, r3, #24
    1244:	220f      	movs	r2, #15
    1246:	4013      	ands	r3, r2
    1248:	2b0f      	cmp	r3, #15
    124a:	d827      	bhi.n	129c <cpu_identify+0x204>
    124c:	009a      	lsls	r2, r3, #2
    124e:	4b3b      	ldr	r3, [pc, #236]	; (133c <cpu_identify+0x2a4>)
    1250:	18d3      	adds	r3, r2, r3
    1252:	681b      	ldr	r3, [r3, #0]
    1254:	469f      	mov	pc, r3
	{
	case 0x0:
		printf("Flash size:  8 KB program flash, 0.25 KB protection region");
    1256:	4b3a      	ldr	r3, [pc, #232]	; (1340 <cpu_identify+0x2a8>)
    1258:	0018      	movs	r0, r3
    125a:	f7ff fdfd 	bl	e58 <printf>
		break;
    125e:	e022      	b.n	12a6 <cpu_identify+0x20e>
	case 0x1:
		printf("Flash size:  16 KB program flash, 0.5 KB protection region	");
    1260:	4b38      	ldr	r3, [pc, #224]	; (1344 <cpu_identify+0x2ac>)
    1262:	0018      	movs	r0, r3
    1264:	f7ff fdf8 	bl	e58 <printf>
		break;
    1268:	e01d      	b.n	12a6 <cpu_identify+0x20e>
	case 0x3:
		printf("Flash size:  32 KB program flash, 1 KB protection region	");
    126a:	4b37      	ldr	r3, [pc, #220]	; (1348 <cpu_identify+0x2b0>)
    126c:	0018      	movs	r0, r3
    126e:	f7ff fdf3 	bl	e58 <printf>
		break;
    1272:	e018      	b.n	12a6 <cpu_identify+0x20e>
	case 0x5:
		printf("Flash size:  64 KB program flash, 2 KB protection region	");
    1274:	4b35      	ldr	r3, [pc, #212]	; (134c <cpu_identify+0x2b4>)
    1276:	0018      	movs	r0, r3
    1278:	f7ff fdee 	bl	e58 <printf>
		break;
    127c:	e013      	b.n	12a6 <cpu_identify+0x20e>
	case 0x7:
		printf("Flash size:  128 KB program flash, 4 KB protection region	");
    127e:	4b34      	ldr	r3, [pc, #208]	; (1350 <cpu_identify+0x2b8>)
    1280:	0018      	movs	r0, r3
    1282:	f7ff fde9 	bl	e58 <printf>
		break;
    1286:	e00e      	b.n	12a6 <cpu_identify+0x20e>
	case 0x9:
		printf("Flash size:  256 KB program flash, 4 KB protection region	");
    1288:	4b32      	ldr	r3, [pc, #200]	; (1354 <cpu_identify+0x2bc>)
    128a:	0018      	movs	r0, r3
    128c:	f7ff fde4 	bl	e58 <printf>
		break;
    1290:	e009      	b.n	12a6 <cpu_identify+0x20e>
	case 0xF:
		printf("Flash size:  128 KB program flash, 4 KB protection region	");
    1292:	4b2f      	ldr	r3, [pc, #188]	; (1350 <cpu_identify+0x2b8>)
    1294:	0018      	movs	r0, r3
    1296:	f7ff fddf 	bl	e58 <printf>
		break;
    129a:	e004      	b.n	12a6 <cpu_identify+0x20e>
	default:
		printf("ERR!! Undefined flash size\n\r");  
    129c:	4b2e      	ldr	r3, [pc, #184]	; (1358 <cpu_identify+0x2c0>)
    129e:	0018      	movs	r0, r3
    12a0:	f7ff fdda 	bl	e58 <printf>
		break;  	  		
    12a4:	46c0      	nop			; (mov r8, r8)
	}
}
    12a6:	46c0      	nop			; (mov r8, r8)
    12a8:	46bd      	mov	sp, r7
    12aa:	b002      	add	sp, #8
    12ac:	bd80      	pop	{r7, pc}
    12ae:	46c0      	nop			; (mov r8, r8)
    12b0:	40047000 	.word	0x40047000
    12b4:	00001024 	.word	0x00001024
    12b8:	000048e0 	.word	0x000048e0
    12bc:	00004060 	.word	0x00004060
    12c0:	00004068 	.word	0x00004068
    12c4:	00004070 	.word	0x00004070
    12c8:	00004078 	.word	0x00004078
    12cc:	00004080 	.word	0x00004080
    12d0:	00004088 	.word	0x00004088
    12d4:	000040b0 	.word	0x000040b0
    12d8:	000040b4 	.word	0x000040b4
    12dc:	000040b8 	.word	0x000040b8
    12e0:	000048f4 	.word	0x000048f4
    12e4:	000040e4 	.word	0x000040e4
    12e8:	000040f4 	.word	0x000040f4
    12ec:	00004104 	.word	0x00004104
    12f0:	00004110 	.word	0x00004110
    12f4:	0000411c 	.word	0x0000411c
    12f8:	00004128 	.word	0x00004128
    12fc:	00004134 	.word	0x00004134
    1300:	00004144 	.word	0x00004144
    1304:	00004170 	.word	0x00004170
    1308:	00004198 	.word	0x00004198
    130c:	00004918 	.word	0x00004918
    1310:	000041c4 	.word	0x000041c4
    1314:	000041d8 	.word	0x000041d8
    1318:	000041ec 	.word	0x000041ec
    131c:	00004200 	.word	0x00004200
    1320:	00004214 	.word	0x00004214
    1324:	00004228 	.word	0x00004228
    1328:	0000423c 	.word	0x0000423c
    132c:	00004250 	.word	0x00004250
    1330:	00004264 	.word	0x00004264
    1334:	00004280 	.word	0x00004280
    1338:	0000104c 	.word	0x0000104c
    133c:	00004938 	.word	0x00004938
    1340:	00004294 	.word	0x00004294
    1344:	000042d0 	.word	0x000042d0
    1348:	0000430c 	.word	0x0000430c
    134c:	00004348 	.word	0x00004348
    1350:	00004384 	.word	0x00004384
    1354:	000043c0 	.word	0x000043c0
    1358:	000043fc 	.word	0x000043fc

0000135c <flash_identify>:
 * flash command call "read resource." The first four bytes returned
 * are the flash parameter revision, and the second four bytes are
 * the flash version ID.
 */
void flash_identify (void)
{
    135c:	b580      	push	{r7, lr}
    135e:	af00      	add	r7, sp, #0
	/* Get the flash parameter version */

	/* Write the flash FCCOB registers with the values for a read resource command */
	FTFA_FCCOB0 = 0x03;
    1360:	4b3e      	ldr	r3, [pc, #248]	; (145c <flash_identify+0x100>)
    1362:	2203      	movs	r2, #3
    1364:	71da      	strb	r2, [r3, #7]
	FTFA_FCCOB1 = 0x00;
    1366:	4b3d      	ldr	r3, [pc, #244]	; (145c <flash_identify+0x100>)
    1368:	2200      	movs	r2, #0
    136a:	719a      	strb	r2, [r3, #6]
	FTFA_FCCOB2 = 0x00;
    136c:	4b3b      	ldr	r3, [pc, #236]	; (145c <flash_identify+0x100>)
    136e:	2200      	movs	r2, #0
    1370:	715a      	strb	r2, [r3, #5]
	FTFA_FCCOB3 = 0x00;
    1372:	4b3a      	ldr	r3, [pc, #232]	; (145c <flash_identify+0x100>)
    1374:	2200      	movs	r2, #0
    1376:	711a      	strb	r2, [r3, #4]
	FTFA_FCCOB8 = 0x01;
    1378:	4b38      	ldr	r3, [pc, #224]	; (145c <flash_identify+0x100>)
    137a:	2201      	movs	r2, #1
    137c:	73da      	strb	r2, [r3, #15]

	/* All required FCCOBx registers are written, so launch the command */
	FTFA_FSTAT = FTFA_FSTAT_CCIF_MASK;
    137e:	4b37      	ldr	r3, [pc, #220]	; (145c <flash_identify+0x100>)
    1380:	2280      	movs	r2, #128	; 0x80
    1382:	701a      	strb	r2, [r3, #0]

	/* Wait for the command to complete */
	while(!(FTFA_FSTAT & FTFA_FSTAT_CCIF_MASK));
    1384:	46c0      	nop			; (mov r8, r8)
    1386:	4b35      	ldr	r3, [pc, #212]	; (145c <flash_identify+0x100>)
    1388:	781b      	ldrb	r3, [r3, #0]
    138a:	b2db      	uxtb	r3, r3
    138c:	b25b      	sxtb	r3, r3
    138e:	2b00      	cmp	r3, #0
    1390:	daf9      	bge.n	1386 <flash_identify+0x2a>

	printf("Flash parameter version %d ",FTFA_FCCOB4);
    1392:	4b32      	ldr	r3, [pc, #200]	; (145c <flash_identify+0x100>)
    1394:	7adb      	ldrb	r3, [r3, #11]
    1396:	b2db      	uxtb	r3, r3
    1398:	001a      	movs	r2, r3
    139a:	4b31      	ldr	r3, [pc, #196]	; (1460 <flash_identify+0x104>)
    139c:	0011      	movs	r1, r2
    139e:	0018      	movs	r0, r3
    13a0:	f7ff fd5a 	bl	e58 <printf>
	printf(" %d ",FTFA_FCCOB5);
    13a4:	4b2d      	ldr	r3, [pc, #180]	; (145c <flash_identify+0x100>)
    13a6:	7a9b      	ldrb	r3, [r3, #10]
    13a8:	b2db      	uxtb	r3, r3
    13aa:	001a      	movs	r2, r3
    13ac:	4b2d      	ldr	r3, [pc, #180]	; (1464 <flash_identify+0x108>)
    13ae:	0011      	movs	r1, r2
    13b0:	0018      	movs	r0, r3
    13b2:	f7ff fd51 	bl	e58 <printf>
	printf(" %d ",FTFA_FCCOB6);
    13b6:	4b29      	ldr	r3, [pc, #164]	; (145c <flash_identify+0x100>)
    13b8:	7a5b      	ldrb	r3, [r3, #9]
    13ba:	b2db      	uxtb	r3, r3
    13bc:	001a      	movs	r2, r3
    13be:	4b29      	ldr	r3, [pc, #164]	; (1464 <flash_identify+0x108>)
    13c0:	0011      	movs	r1, r2
    13c2:	0018      	movs	r0, r3
    13c4:	f7ff fd48 	bl	e58 <printf>
	printf(" %d\n\r",FTFA_FCCOB7);
    13c8:	4b24      	ldr	r3, [pc, #144]	; (145c <flash_identify+0x100>)
    13ca:	7a1b      	ldrb	r3, [r3, #8]
    13cc:	b2db      	uxtb	r3, r3
    13ce:	001a      	movs	r2, r3
    13d0:	4b25      	ldr	r3, [pc, #148]	; (1468 <flash_identify+0x10c>)
    13d2:	0011      	movs	r1, r2
    13d4:	0018      	movs	r0, r3
    13d6:	f7ff fd3f 	bl	e58 <printf>

	/* Get the flash version ID */

	/* Write the flash FCCOB registers with the values for a read resource command */
	FTFA_FCCOB0 = 0x03;
    13da:	4b20      	ldr	r3, [pc, #128]	; (145c <flash_identify+0x100>)
    13dc:	2203      	movs	r2, #3
    13de:	71da      	strb	r2, [r3, #7]
	FTFA_FCCOB1 = 0x00;
    13e0:	4b1e      	ldr	r3, [pc, #120]	; (145c <flash_identify+0x100>)
    13e2:	2200      	movs	r2, #0
    13e4:	719a      	strb	r2, [r3, #6]
	FTFA_FCCOB2 = 0x00;
    13e6:	4b1d      	ldr	r3, [pc, #116]	; (145c <flash_identify+0x100>)
    13e8:	2200      	movs	r2, #0
    13ea:	715a      	strb	r2, [r3, #5]
	FTFA_FCCOB3 = 0x04;
    13ec:	4b1b      	ldr	r3, [pc, #108]	; (145c <flash_identify+0x100>)
    13ee:	2204      	movs	r2, #4
    13f0:	711a      	strb	r2, [r3, #4]
	FTFA_FCCOB8 = 0x01;
    13f2:	4b1a      	ldr	r3, [pc, #104]	; (145c <flash_identify+0x100>)
    13f4:	2201      	movs	r2, #1
    13f6:	73da      	strb	r2, [r3, #15]

	/* All required FCCOBx registers are written, so launch the command */
	FTFA_FSTAT = FTFA_FSTAT_CCIF_MASK;
    13f8:	4b18      	ldr	r3, [pc, #96]	; (145c <flash_identify+0x100>)
    13fa:	2280      	movs	r2, #128	; 0x80
    13fc:	701a      	strb	r2, [r3, #0]

	/* Wait for the command to complete */
	while(!(FTFA_FSTAT & FTFA_FSTAT_CCIF_MASK));
    13fe:	46c0      	nop			; (mov r8, r8)
    1400:	4b16      	ldr	r3, [pc, #88]	; (145c <flash_identify+0x100>)
    1402:	781b      	ldrb	r3, [r3, #0]
    1404:	b2db      	uxtb	r3, r3
    1406:	b25b      	sxtb	r3, r3
    1408:	2b00      	cmp	r3, #0
    140a:	daf9      	bge.n	1400 <flash_identify+0xa4>

	printf("Flash version ID %d ",FTFA_FCCOB4);
    140c:	4b13      	ldr	r3, [pc, #76]	; (145c <flash_identify+0x100>)
    140e:	7adb      	ldrb	r3, [r3, #11]
    1410:	b2db      	uxtb	r3, r3
    1412:	001a      	movs	r2, r3
    1414:	4b15      	ldr	r3, [pc, #84]	; (146c <flash_identify+0x110>)
    1416:	0011      	movs	r1, r2
    1418:	0018      	movs	r0, r3
    141a:	f7ff fd1d 	bl	e58 <printf>
	printf(" %d",FTFA_FCCOB5);
    141e:	4b0f      	ldr	r3, [pc, #60]	; (145c <flash_identify+0x100>)
    1420:	7a9b      	ldrb	r3, [r3, #10]
    1422:	b2db      	uxtb	r3, r3
    1424:	001a      	movs	r2, r3
    1426:	4b12      	ldr	r3, [pc, #72]	; (1470 <flash_identify+0x114>)
    1428:	0011      	movs	r1, r2
    142a:	0018      	movs	r0, r3
    142c:	f7ff fd14 	bl	e58 <printf>
	printf(" %d ",FTFA_FCCOB6);
    1430:	4b0a      	ldr	r3, [pc, #40]	; (145c <flash_identify+0x100>)
    1432:	7a5b      	ldrb	r3, [r3, #9]
    1434:	b2db      	uxtb	r3, r3
    1436:	001a      	movs	r2, r3
    1438:	4b0a      	ldr	r3, [pc, #40]	; (1464 <flash_identify+0x108>)
    143a:	0011      	movs	r1, r2
    143c:	0018      	movs	r0, r3
    143e:	f7ff fd0b 	bl	e58 <printf>
	printf("%d\n\r",FTFA_FCCOB7);
    1442:	4b06      	ldr	r3, [pc, #24]	; (145c <flash_identify+0x100>)
    1444:	7a1b      	ldrb	r3, [r3, #8]
    1446:	b2db      	uxtb	r3, r3
    1448:	001a      	movs	r2, r3
    144a:	4b0a      	ldr	r3, [pc, #40]	; (1474 <flash_identify+0x118>)
    144c:	0011      	movs	r1, r2
    144e:	0018      	movs	r0, r3
    1450:	f7ff fd02 	bl	e58 <printf>
}
    1454:	46c0      	nop			; (mov r8, r8)
    1456:	46bd      	mov	sp, r7
    1458:	bd80      	pop	{r7, pc}
    145a:	46c0      	nop			; (mov r8, r8)
    145c:	40020000 	.word	0x40020000
    1460:	0000441c 	.word	0x0000441c
    1464:	00004438 	.word	0x00004438
    1468:	00004440 	.word	0x00004440
    146c:	00004448 	.word	0x00004448
    1470:	00004460 	.word	0x00004460
    1474:	00004464 	.word	0x00004464

00001478 <sysinit>:



/********************************************************************/
void sysinit (void)
{
    1478:	b580      	push	{r7, lr}
    147a:	b082      	sub	sp, #8
    147c:	af02      	add	r7, sp, #8
        /* Enable all of the port clocks. These have to be enabled to configure
         * pin muxing options, so most code will need all of these on anyway.
         */
        SIM_SCGC5 |= (SIM_SCGC5_PORTA_MASK
    147e:	4945      	ldr	r1, [pc, #276]	; (1594 <sysinit+0x11c>)
    1480:	4a44      	ldr	r2, [pc, #272]	; (1594 <sysinit+0x11c>)
    1482:	4b45      	ldr	r3, [pc, #276]	; (1598 <sysinit+0x120>)
    1484:	58d3      	ldr	r3, [r2, r3]
    1486:	22f8      	movs	r2, #248	; 0xf8
    1488:	0192      	lsls	r2, r2, #6
    148a:	4313      	orrs	r3, r2
    148c:	4a42      	ldr	r2, [pc, #264]	; (1598 <sysinit+0x120>)
    148e:	508b      	str	r3, [r1, r2]
        // releases hold with ACKISO:  Only has an effect if recovering from VLLS1, VLLS2, or VLLS3
        // if ACKISO is set you must clear ackiso before calling pll_init 
        //    or pll init hangs waiting for OSC to initialize
        // if osc enabled in low power modes - enable it first before ack
        // if I/O needs to be maintained without glitches enable outputs and modules first before ack.
        if (PMC_REGSC &  PMC_REGSC_ACKISO_MASK)
    1490:	4b42      	ldr	r3, [pc, #264]	; (159c <sysinit+0x124>)
    1492:	789b      	ldrb	r3, [r3, #2]
    1494:	b2db      	uxtb	r3, r3
    1496:	001a      	movs	r2, r3
    1498:	2308      	movs	r3, #8
    149a:	4013      	ands	r3, r2
    149c:	d007      	beq.n	14ae <sysinit+0x36>
        PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
    149e:	4a3f      	ldr	r2, [pc, #252]	; (159c <sysinit+0x124>)
    14a0:	4b3e      	ldr	r3, [pc, #248]	; (159c <sysinit+0x124>)
    14a2:	789b      	ldrb	r3, [r3, #2]
    14a4:	b2db      	uxtb	r3, r3
    14a6:	2108      	movs	r1, #8
    14a8:	430b      	orrs	r3, r1
    14aa:	b2db      	uxtb	r3, r3
    14ac:	7093      	strb	r3, [r2, #2]
   
#else        
        

           /* Configuration for PLL freq = 96MHz */
        SIM_CLKDIV1 = ( 0
    14ae:	4a39      	ldr	r2, [pc, #228]	; (1594 <sysinit+0x11c>)
    14b0:	4b3b      	ldr	r3, [pc, #236]	; (15a0 <sysinit+0x128>)
    14b2:	493c      	ldr	r1, [pc, #240]	; (15a4 <sysinit+0x12c>)
    14b4:	50d1      	str	r1, [r2, r3]
        
        
        
       /* Initialize PLL */
       /* PLL will be the source for MCG CLKOUT so the core, system, and flash clocks are derived from it */ 
       mcg_clk_hz = pll_init(CLK0_FREQ_HZ,  /* CLKIN0 frequency */
    14b6:	483c      	ldr	r0, [pc, #240]	; (15a8 <sysinit+0x130>)
    14b8:	2301      	movs	r3, #1
    14ba:	9301      	str	r3, [sp, #4]
    14bc:	2330      	movs	r3, #48	; 0x30
    14be:	9300      	str	r3, [sp, #0]
    14c0:	2304      	movs	r3, #4
    14c2:	2201      	movs	r2, #1
    14c4:	2100      	movs	r1, #0
    14c6:	f000 f891 	bl	15ec <pll_init>
    14ca:	0002      	movs	r2, r0
    14cc:	4b37      	ldr	r3, [pc, #220]	; (15ac <sysinit+0x134>)
    14ce:	601a      	str	r2, [r3, #0]
                             PLL0_PRDIV,    /* PLL predivider value */
                             PLL0_VDIV,     /* PLL multiplier */
                             MCGOUT);       /* Use the output from this PLL as the MCGOUT */

       /* Check the value returned from pll_init() to make sure there wasn't an error */
       if (mcg_clk_hz < 0x100)
    14d0:	4b36      	ldr	r3, [pc, #216]	; (15ac <sysinit+0x134>)
    14d2:	681b      	ldr	r3, [r3, #0]
    14d4:	2bff      	cmp	r3, #255	; 0xff
    14d6:	dc00      	bgt.n	14da <sysinit+0x62>
         while(1);
    14d8:	e7fe      	b.n	14d8 <sysinit+0x60>
       
       SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK; // set PLLFLLSEL to select the PLL for this clock source
    14da:	492e      	ldr	r1, [pc, #184]	; (1594 <sysinit+0x11c>)
    14dc:	4a2d      	ldr	r2, [pc, #180]	; (1594 <sysinit+0x11c>)
    14de:	4b34      	ldr	r3, [pc, #208]	; (15b0 <sysinit+0x138>)
    14e0:	58d3      	ldr	r3, [r2, r3]
    14e2:	2280      	movs	r2, #128	; 0x80
    14e4:	0252      	lsls	r2, r2, #9
    14e6:	4313      	orrs	r3, r2
    14e8:	4a31      	ldr	r2, [pc, #196]	; (15b0 <sysinit+0x138>)
    14ea:	508b      	str	r3, [r1, r2]
       
       uart0_clk_khz = ((mcg_clk_hz / 2) / 1000); // UART0 clock frequency will equal half the PLL frequency
    14ec:	4b2f      	ldr	r3, [pc, #188]	; (15ac <sysinit+0x134>)
    14ee:	681a      	ldr	r2, [r3, #0]
    14f0:	23fa      	movs	r3, #250	; 0xfa
    14f2:	00d9      	lsls	r1, r3, #3
    14f4:	0010      	movs	r0, r2
    14f6:	f7ff f839 	bl	56c <__divsi3>
    14fa:	0003      	movs	r3, r0
    14fc:	001a      	movs	r2, r3
    14fe:	4b2d      	ldr	r3, [pc, #180]	; (15b4 <sysinit+0x13c>)
    1500:	601a      	str	r2, [r3, #0]
         * Use the value obtained from the pll_init function to define variables
	 * for the core clock in kHz and also the peripheral clock. These
	 * variables can be used by other functions that need awareness of the
	 * system frequency.
	 */
        mcg_clk_khz = mcg_clk_hz / 1000;
    1502:	4b2a      	ldr	r3, [pc, #168]	; (15ac <sysinit+0x134>)
    1504:	681a      	ldr	r2, [r3, #0]
    1506:	23fa      	movs	r3, #250	; 0xfa
    1508:	0099      	lsls	r1, r3, #2
    150a:	0010      	movs	r0, r2
    150c:	f7ff f82e 	bl	56c <__divsi3>
    1510:	0003      	movs	r3, r0
    1512:	001a      	movs	r2, r3
    1514:	4b28      	ldr	r3, [pc, #160]	; (15b8 <sysinit+0x140>)
    1516:	601a      	str	r2, [r3, #0]
  	core_clk_khz = mcg_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV1_MASK) >> 28)+ 1);
    1518:	4b27      	ldr	r3, [pc, #156]	; (15b8 <sysinit+0x140>)
    151a:	681b      	ldr	r3, [r3, #0]
    151c:	0018      	movs	r0, r3
    151e:	4a1d      	ldr	r2, [pc, #116]	; (1594 <sysinit+0x11c>)
    1520:	4b1f      	ldr	r3, [pc, #124]	; (15a0 <sysinit+0x128>)
    1522:	58d3      	ldr	r3, [r2, r3]
    1524:	0f1b      	lsrs	r3, r3, #28
    1526:	220f      	movs	r2, #15
    1528:	4013      	ands	r3, r2
    152a:	3301      	adds	r3, #1
    152c:	0019      	movs	r1, r3
    152e:	f7fe ff93 	bl	458 <__udivsi3>
    1532:	0003      	movs	r3, r0
    1534:	001a      	movs	r2, r3
    1536:	4b21      	ldr	r3, [pc, #132]	; (15bc <sysinit+0x144>)
    1538:	601a      	str	r2, [r3, #0]
        periph_clk_khz = core_clk_khz / (((SIM_CLKDIV1 & SIM_CLKDIV1_OUTDIV4_MASK) >> 16)+ 1);
    153a:	4b20      	ldr	r3, [pc, #128]	; (15bc <sysinit+0x144>)
    153c:	681b      	ldr	r3, [r3, #0]
    153e:	0018      	movs	r0, r3
    1540:	4a14      	ldr	r2, [pc, #80]	; (1594 <sysinit+0x11c>)
    1542:	4b17      	ldr	r3, [pc, #92]	; (15a0 <sysinit+0x128>)
    1544:	58d3      	ldr	r3, [r2, r3]
    1546:	0c1b      	lsrs	r3, r3, #16
    1548:	2207      	movs	r2, #7
    154a:	4013      	ands	r3, r2
    154c:	3301      	adds	r3, #1
    154e:	0019      	movs	r1, r3
    1550:	f7fe ff82 	bl	458 <__udivsi3>
    1554:	0003      	movs	r3, r0
    1556:	001a      	movs	r2, r3
    1558:	4b19      	ldr	r3, [pc, #100]	; (15c0 <sysinit+0x148>)
    155a:	601a      	str	r2, [r3, #0]
        if (TERM_PORT_NUM == 0)
        {
  	  /* Enable the pins for the selected UART */
#ifdef FREEDOM
          /* Enable the UART_TXD function on PTA1 */
          PORTA_PCR1 = PORT_PCR_MUX(0x2);
    155c:	4b19      	ldr	r3, [pc, #100]	; (15c4 <sysinit+0x14c>)
    155e:	2280      	movs	r2, #128	; 0x80
    1560:	0092      	lsls	r2, r2, #2
    1562:	605a      	str	r2, [r3, #4]
          
          /* Enable the UART_TXD function on PTA2 */
          PORTA_PCR2 = PORT_PCR_MUX(0x2);
    1564:	4b17      	ldr	r3, [pc, #92]	; (15c4 <sysinit+0x14c>)
    1566:	2280      	movs	r2, #128	; 0x80
    1568:	0092      	lsls	r2, r2, #2
    156a:	609a      	str	r2, [r3, #8]
  		
  	  /* Enable the UART_RXD function on PTA15 */
  	  PORTA_PCR15 = PORT_PCR_MUX(0x3); // UART0 is alt3 function for this pin
#endif
         
          SIM_SOPT2 |= SIM_SOPT2_UART0SRC(1); // select the PLLFLLCLK as UART0 clock source
    156c:	4909      	ldr	r1, [pc, #36]	; (1594 <sysinit+0x11c>)
    156e:	4a09      	ldr	r2, [pc, #36]	; (1594 <sysinit+0x11c>)
    1570:	4b0f      	ldr	r3, [pc, #60]	; (15b0 <sysinit+0x138>)
    1572:	58d3      	ldr	r3, [r2, r3]
    1574:	2280      	movs	r2, #128	; 0x80
    1576:	04d2      	lsls	r2, r2, #19
    1578:	4313      	orrs	r3, r2
    157a:	4a0d      	ldr	r2, [pc, #52]	; (15b0 <sysinit+0x138>)
    157c:	508b      	str	r3, [r1, r2]
  	/* UART0 is clocked asynchronously to the core clock, but all other UARTs are
         * clocked from the peripheral clock. So we have to determine which clock
         * to send to the UART_init function.
         */
        if (TERM_PORT_NUM == 0)
            uart0_init (UART0_BASE_PTR, uart0_clk_khz, TERMINAL_BAUD);
    157e:	4b0d      	ldr	r3, [pc, #52]	; (15b4 <sysinit+0x13c>)
    1580:	6819      	ldr	r1, [r3, #0]
    1582:	2396      	movs	r3, #150	; 0x96
    1584:	01db      	lsls	r3, r3, #7
    1586:	4810      	ldr	r0, [pc, #64]	; (15c8 <sysinit+0x150>)
    1588:	001a      	movs	r2, r3
    158a:	f000 fc01 	bl	1d90 <uart0_init>
  	    uart_init (UART1_BASE_PTR, periph_clk_khz, TERMINAL_BAUD);
        else if (TERM_PORT_NUM == 2)
            uart_init (UART2_BASE_PTR, periph_clk_khz, TERMINAL_BAUD);
        else
          while(1);
}
    158e:	46c0      	nop			; (mov r8, r8)
    1590:	46bd      	mov	sp, r7
    1592:	bd80      	pop	{r7, pc}
    1594:	40047000 	.word	0x40047000
    1598:	00001038 	.word	0x00001038
    159c:	4007d000 	.word	0x4007d000
    15a0:	00001044 	.word	0x00001044
    15a4:	10010000 	.word	0x10010000
    15a8:	007a1200 	.word	0x007a1200
    15ac:	1ffff4c4 	.word	0x1ffff4c4
    15b0:	00001004 	.word	0x00001004
    15b4:	1ffff4d0 	.word	0x1ffff4d0
    15b8:	1ffff4d4 	.word	0x1ffff4d4
    15bc:	1ffff4c8 	.word	0x1ffff4c8
    15c0:	1ffff4cc 	.word	0x1ffff4cc
    15c4:	40049000 	.word	0x40049000
    15c8:	4006a000 	.word	0x4006a000

000015cc <default_isr>:
*
* In:  n/a
* Out: n/a
******************************************************************************/
void default_isr(void)
{
    15cc:	b580      	push	{r7, lr}
    15ce:	af00      	add	r7, sp, #0
   #define VECTORNUM                     (*(volatile uint32_t*)(0xE000ED04))

   printf("\n****default_isr entered on vector %d*****\r\n\n",VECTORNUM);
    15d0:	4b04      	ldr	r3, [pc, #16]	; (15e4 <default_isr+0x18>)
    15d2:	681a      	ldr	r2, [r3, #0]
    15d4:	4b04      	ldr	r3, [pc, #16]	; (15e8 <default_isr+0x1c>)
    15d6:	0011      	movs	r1, r2
    15d8:	0018      	movs	r0, r3
    15da:	f7ff fc3d 	bl	e58 <printf>
   return;
    15de:	46c0      	nop			; (mov r8, r8)
}
    15e0:	46bd      	mov	sp, r7
    15e2:	bd80      	pop	{r7, pc}
    15e4:	e000ed04 	.word	0xe000ed04
    15e8:	0000446c 	.word	0x0000446c

000015ec <pll_init>:
 *
 * Return value : PLL frequency (Hz) or error code
 */

int pll_init(int crystal_val, unsigned char hgo_val, unsigned char erefs_val, signed char prdiv_val, signed char vdiv_val, unsigned char mcgout_select)
{
    15ec:	b590      	push	{r4, r7, lr}
    15ee:	b087      	sub	sp, #28
    15f0:	af00      	add	r7, sp, #0
    15f2:	6078      	str	r0, [r7, #4]
    15f4:	000c      	movs	r4, r1
    15f6:	0010      	movs	r0, r2
    15f8:	0019      	movs	r1, r3
    15fa:	1cfb      	adds	r3, r7, #3
    15fc:	1c22      	adds	r2, r4, #0
    15fe:	701a      	strb	r2, [r3, #0]
    1600:	1cbb      	adds	r3, r7, #2
    1602:	1c02      	adds	r2, r0, #0
    1604:	701a      	strb	r2, [r3, #0]
    1606:	1c7b      	adds	r3, r7, #1
    1608:	1c0a      	adds	r2, r1, #0
    160a:	701a      	strb	r2, [r3, #0]
  short i;
  int ref_freq;
  int pll_freq;

  // check if in FEI mode
  if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    160c:	4bc5      	ldr	r3, [pc, #788]	; (1924 <pll_init+0x338>)
    160e:	799b      	ldrb	r3, [r3, #6]
    1610:	b2db      	uxtb	r3, r3
    1612:	089b      	lsrs	r3, r3, #2
    1614:	2203      	movs	r2, #3
    1616:	4013      	ands	r3, r2
    1618:	d10d      	bne.n	1636 <pll_init+0x4a>
      (MCG_S & MCG_S_IREFST_MASK) &&                                  // check FLL ref is internal ref clk
    161a:	4bc2      	ldr	r3, [pc, #776]	; (1924 <pll_init+0x338>)
    161c:	799b      	ldrb	r3, [r3, #6]
    161e:	b2db      	uxtb	r3, r3
    1620:	001a      	movs	r2, r3
    1622:	2310      	movs	r3, #16
    1624:	4013      	ands	r3, r2
  if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    1626:	d006      	beq.n	1636 <pll_init+0x4a>
      (!(MCG_S & MCG_S_PLLST_MASK))))                                 // check PLLS mux has selected FLL
    1628:	4bbe      	ldr	r3, [pc, #760]	; (1924 <pll_init+0x338>)
    162a:	799b      	ldrb	r3, [r3, #6]
    162c:	b2db      	uxtb	r3, r3
    162e:	001a      	movs	r2, r3
    1630:	2320      	movs	r3, #32
    1632:	4013      	ands	r3, r2
  if (!((((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x0) && // check CLKS mux has selcted FLL output
    1634:	d001      	beq.n	163a <pll_init+0x4e>
  {
    return 0x1;                                                     // return error code
    1636:	2301      	movs	r3, #1
    1638:	e283      	b.n	1b42 <pll_init+0x556>
  }

  // check external frequency is less than the maximum frequency
  if  (crystal_val > 50000000) {return 0x21;}
    163a:	687b      	ldr	r3, [r7, #4]
    163c:	4aba      	ldr	r2, [pc, #744]	; (1928 <pll_init+0x33c>)
    163e:	4293      	cmp	r3, r2
    1640:	dd01      	ble.n	1646 <pll_init+0x5a>
    1642:	2321      	movs	r3, #33	; 0x21
    1644:	e27d      	b.n	1b42 <pll_init+0x556>

  // check crystal frequency is within spec. if crystal osc is being used as PLL ref
  if (erefs_val)
    1646:	1cbb      	adds	r3, r7, #2
    1648:	781b      	ldrb	r3, [r3, #0]
    164a:	2b00      	cmp	r3, #0
    164c:	d009      	beq.n	1662 <pll_init+0x76>
  {
    if ((crystal_val < 3000000) || (crystal_val > 32000000)) {return 0x22;} // return 1 if one of the available crystal options is not available
    164e:	687b      	ldr	r3, [r7, #4]
    1650:	4ab6      	ldr	r2, [pc, #728]	; (192c <pll_init+0x340>)
    1652:	4293      	cmp	r3, r2
    1654:	dd03      	ble.n	165e <pll_init+0x72>
    1656:	687b      	ldr	r3, [r7, #4]
    1658:	4ab5      	ldr	r2, [pc, #724]	; (1930 <pll_init+0x344>)
    165a:	4293      	cmp	r3, r2
    165c:	dd01      	ble.n	1662 <pll_init+0x76>
    165e:	2322      	movs	r3, #34	; 0x22
    1660:	e26f      	b.n	1b42 <pll_init+0x556>
  }

  // make sure HGO will never be greater than 1. Could return an error instead if desired.
  if (hgo_val > 0)
    1662:	1cfb      	adds	r3, r7, #3
    1664:	781b      	ldrb	r3, [r3, #0]
    1666:	2b00      	cmp	r3, #0
    1668:	d002      	beq.n	1670 <pll_init+0x84>
  {
    hgo_val = 1; // force hgo_val to 1 if > 0
    166a:	1cfb      	adds	r3, r7, #3
    166c:	2201      	movs	r2, #1
    166e:	701a      	strb	r2, [r3, #0]
  }

  // Check PLL divider settings are within spec.
  if ((prdiv_val < 1) || (prdiv_val > 25)) {return 0x41;}
    1670:	1c7b      	adds	r3, r7, #1
    1672:	781b      	ldrb	r3, [r3, #0]
    1674:	b25b      	sxtb	r3, r3
    1676:	2b00      	cmp	r3, #0
    1678:	dd04      	ble.n	1684 <pll_init+0x98>
    167a:	1c7b      	adds	r3, r7, #1
    167c:	781b      	ldrb	r3, [r3, #0]
    167e:	b25b      	sxtb	r3, r3
    1680:	2b19      	cmp	r3, #25
    1682:	dd01      	ble.n	1688 <pll_init+0x9c>
    1684:	2341      	movs	r3, #65	; 0x41
    1686:	e25c      	b.n	1b42 <pll_init+0x556>
  if ((vdiv_val < 24) || (vdiv_val > 50)) {return 0x42;}
    1688:	2328      	movs	r3, #40	; 0x28
    168a:	18fb      	adds	r3, r7, r3
    168c:	781b      	ldrb	r3, [r3, #0]
    168e:	b25b      	sxtb	r3, r3
    1690:	2b17      	cmp	r3, #23
    1692:	dd05      	ble.n	16a0 <pll_init+0xb4>
    1694:	2328      	movs	r3, #40	; 0x28
    1696:	18fb      	adds	r3, r7, r3
    1698:	781b      	ldrb	r3, [r3, #0]
    169a:	b25b      	sxtb	r3, r3
    169c:	2b32      	cmp	r3, #50	; 0x32
    169e:	dd01      	ble.n	16a4 <pll_init+0xb8>
    16a0:	2342      	movs	r3, #66	; 0x42
    16a2:	e24e      	b.n	1b42 <pll_init+0x556>

  // Check PLL reference clock frequency is within spec.
  ref_freq = crystal_val / prdiv_val;
    16a4:	1c7b      	adds	r3, r7, #1
    16a6:	781b      	ldrb	r3, [r3, #0]
    16a8:	b25b      	sxtb	r3, r3
    16aa:	0019      	movs	r1, r3
    16ac:	6878      	ldr	r0, [r7, #4]
    16ae:	f7fe ff5d 	bl	56c <__divsi3>
    16b2:	0003      	movs	r3, r0
    16b4:	613b      	str	r3, [r7, #16]
  if ((ref_freq < 2000000) || (ref_freq > 4000000)) {return 0x43;}
    16b6:	693b      	ldr	r3, [r7, #16]
    16b8:	4a9e      	ldr	r2, [pc, #632]	; (1934 <pll_init+0x348>)
    16ba:	4293      	cmp	r3, r2
    16bc:	dd03      	ble.n	16c6 <pll_init+0xda>
    16be:	693b      	ldr	r3, [r7, #16]
    16c0:	4a9d      	ldr	r2, [pc, #628]	; (1938 <pll_init+0x34c>)
    16c2:	4293      	cmp	r3, r2
    16c4:	dd01      	ble.n	16ca <pll_init+0xde>
    16c6:	2343      	movs	r3, #67	; 0x43
    16c8:	e23b      	b.n	1b42 <pll_init+0x556>

  // Check PLL output frequency is within spec.
  pll_freq = (crystal_val / prdiv_val) * vdiv_val;
    16ca:	1c7b      	adds	r3, r7, #1
    16cc:	781b      	ldrb	r3, [r3, #0]
    16ce:	b25b      	sxtb	r3, r3
    16d0:	0019      	movs	r1, r3
    16d2:	6878      	ldr	r0, [r7, #4]
    16d4:	f7fe ff4a 	bl	56c <__divsi3>
    16d8:	0003      	movs	r3, r0
    16da:	001a      	movs	r2, r3
    16dc:	2328      	movs	r3, #40	; 0x28
    16de:	18fb      	adds	r3, r7, r3
    16e0:	781b      	ldrb	r3, [r3, #0]
    16e2:	b25b      	sxtb	r3, r3
    16e4:	4353      	muls	r3, r2
    16e6:	60fb      	str	r3, [r7, #12]
  if ((pll_freq < 48000000) || (pll_freq > 100000000)) {return 0x45;}
    16e8:	68fb      	ldr	r3, [r7, #12]
    16ea:	4a94      	ldr	r2, [pc, #592]	; (193c <pll_init+0x350>)
    16ec:	4293      	cmp	r3, r2
    16ee:	dd03      	ble.n	16f8 <pll_init+0x10c>
    16f0:	68fb      	ldr	r3, [r7, #12]
    16f2:	4a93      	ldr	r2, [pc, #588]	; (1940 <pll_init+0x354>)
    16f4:	4293      	cmp	r3, r2
    16f6:	dd01      	ble.n	16fc <pll_init+0x110>
    16f8:	2345      	movs	r3, #69	; 0x45
    16fa:	e222      	b.n	1b42 <pll_init+0x556>

  // configure the MCG_C2 register
  // the RANGE value is determined by the external frequency. Since the RANGE parameter affects the FRDIV divide value
  // it still needs to be set correctly even if the oscillator is not being used
      
  temp_reg = MCG_C2;
    16fc:	4a89      	ldr	r2, [pc, #548]	; (1924 <pll_init+0x338>)
    16fe:	2316      	movs	r3, #22
    1700:	18fb      	adds	r3, r7, r3
    1702:	7852      	ldrb	r2, [r2, #1]
    1704:	701a      	strb	r2, [r3, #0]
  temp_reg &= ~(MCG_C2_RANGE0_MASK | MCG_C2_HGO0_MASK | MCG_C2_EREFS0_MASK); // clear fields before writing new values
    1706:	2316      	movs	r3, #22
    1708:	18fb      	adds	r3, r7, r3
    170a:	2216      	movs	r2, #22
    170c:	18ba      	adds	r2, r7, r2
    170e:	7812      	ldrb	r2, [r2, #0]
    1710:	213c      	movs	r1, #60	; 0x3c
    1712:	438a      	bics	r2, r1
    1714:	701a      	strb	r2, [r3, #0]
    
  if (crystal_val <= 8000000)
    1716:	687b      	ldr	r3, [r7, #4]
    1718:	4a8a      	ldr	r2, [pc, #552]	; (1944 <pll_init+0x358>)
    171a:	4293      	cmp	r3, r2
    171c:	dc14      	bgt.n	1748 <pll_init+0x15c>
  {
    temp_reg |= (MCG_C2_RANGE0(1) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
    171e:	1cfb      	adds	r3, r7, #3
    1720:	781b      	ldrb	r3, [r3, #0]
    1722:	00db      	lsls	r3, r3, #3
    1724:	b2da      	uxtb	r2, r3
    1726:	1cbb      	adds	r3, r7, #2
    1728:	781b      	ldrb	r3, [r3, #0]
    172a:	009b      	lsls	r3, r3, #2
    172c:	b2db      	uxtb	r3, r3
    172e:	4313      	orrs	r3, r2
    1730:	b2da      	uxtb	r2, r3
    1732:	2316      	movs	r3, #22
    1734:	18fb      	adds	r3, r7, r3
    1736:	781b      	ldrb	r3, [r3, #0]
    1738:	4313      	orrs	r3, r2
    173a:	b2da      	uxtb	r2, r3
    173c:	2316      	movs	r3, #22
    173e:	18fb      	adds	r3, r7, r3
    1740:	2110      	movs	r1, #16
    1742:	430a      	orrs	r2, r1
    1744:	701a      	strb	r2, [r3, #0]
    1746:	e013      	b.n	1770 <pll_init+0x184>
  }
  else
  {
    temp_reg |= (MCG_C2_RANGE0(2) | (hgo_val << MCG_C2_HGO0_SHIFT) | (erefs_val << MCG_C2_EREFS0_SHIFT));
    1748:	1cfb      	adds	r3, r7, #3
    174a:	781b      	ldrb	r3, [r3, #0]
    174c:	00db      	lsls	r3, r3, #3
    174e:	b2da      	uxtb	r2, r3
    1750:	1cbb      	adds	r3, r7, #2
    1752:	781b      	ldrb	r3, [r3, #0]
    1754:	009b      	lsls	r3, r3, #2
    1756:	b2db      	uxtb	r3, r3
    1758:	4313      	orrs	r3, r2
    175a:	b2da      	uxtb	r2, r3
    175c:	2316      	movs	r3, #22
    175e:	18fb      	adds	r3, r7, r3
    1760:	781b      	ldrb	r3, [r3, #0]
    1762:	4313      	orrs	r3, r2
    1764:	b2da      	uxtb	r2, r3
    1766:	2316      	movs	r3, #22
    1768:	18fb      	adds	r3, r7, r3
    176a:	2120      	movs	r1, #32
    176c:	430a      	orrs	r2, r1
    176e:	701a      	strb	r2, [r3, #0]
  }
  MCG_C2 = temp_reg;
    1770:	4a6c      	ldr	r2, [pc, #432]	; (1924 <pll_init+0x338>)
    1772:	2316      	movs	r3, #22
    1774:	18fb      	adds	r3, r7, r3
    1776:	781b      	ldrb	r3, [r3, #0]
    1778:	7053      	strb	r3, [r2, #1]
  
  // determine FRDIV based on reference clock frequency
  // since the external frequency has already been checked only the maximum frequency for each FRDIV value needs to be compared here.
  if (crystal_val <= 1250000) {frdiv_val = 0;}
    177a:	687b      	ldr	r3, [r7, #4]
    177c:	4a72      	ldr	r2, [pc, #456]	; (1948 <pll_init+0x35c>)
    177e:	4293      	cmp	r3, r2
    1780:	dc04      	bgt.n	178c <pll_init+0x1a0>
    1782:	2317      	movs	r3, #23
    1784:	18fb      	adds	r3, r7, r3
    1786:	2200      	movs	r2, #0
    1788:	701a      	strb	r2, [r3, #0]
    178a:	e027      	b.n	17dc <pll_init+0x1f0>
  else if (crystal_val <= 2500000) {frdiv_val = 1;}
    178c:	687b      	ldr	r3, [r7, #4]
    178e:	4a6f      	ldr	r2, [pc, #444]	; (194c <pll_init+0x360>)
    1790:	4293      	cmp	r3, r2
    1792:	dc04      	bgt.n	179e <pll_init+0x1b2>
    1794:	2317      	movs	r3, #23
    1796:	18fb      	adds	r3, r7, r3
    1798:	2201      	movs	r2, #1
    179a:	701a      	strb	r2, [r3, #0]
    179c:	e01e      	b.n	17dc <pll_init+0x1f0>
  else if (crystal_val <= 5000000) {frdiv_val = 2;}
    179e:	687b      	ldr	r3, [r7, #4]
    17a0:	4a6b      	ldr	r2, [pc, #428]	; (1950 <pll_init+0x364>)
    17a2:	4293      	cmp	r3, r2
    17a4:	dc04      	bgt.n	17b0 <pll_init+0x1c4>
    17a6:	2317      	movs	r3, #23
    17a8:	18fb      	adds	r3, r7, r3
    17aa:	2202      	movs	r2, #2
    17ac:	701a      	strb	r2, [r3, #0]
    17ae:	e015      	b.n	17dc <pll_init+0x1f0>
  else if (crystal_val <= 10000000) {frdiv_val = 3;}
    17b0:	687b      	ldr	r3, [r7, #4]
    17b2:	4a68      	ldr	r2, [pc, #416]	; (1954 <pll_init+0x368>)
    17b4:	4293      	cmp	r3, r2
    17b6:	dc04      	bgt.n	17c2 <pll_init+0x1d6>
    17b8:	2317      	movs	r3, #23
    17ba:	18fb      	adds	r3, r7, r3
    17bc:	2203      	movs	r2, #3
    17be:	701a      	strb	r2, [r3, #0]
    17c0:	e00c      	b.n	17dc <pll_init+0x1f0>
  else if (crystal_val <= 20000000) {frdiv_val = 4;}
    17c2:	687b      	ldr	r3, [r7, #4]
    17c4:	4a64      	ldr	r2, [pc, #400]	; (1958 <pll_init+0x36c>)
    17c6:	4293      	cmp	r3, r2
    17c8:	dc04      	bgt.n	17d4 <pll_init+0x1e8>
    17ca:	2317      	movs	r3, #23
    17cc:	18fb      	adds	r3, r7, r3
    17ce:	2204      	movs	r2, #4
    17d0:	701a      	strb	r2, [r3, #0]
    17d2:	e003      	b.n	17dc <pll_init+0x1f0>
  else {frdiv_val = 5;}
    17d4:	2317      	movs	r3, #23
    17d6:	18fb      	adds	r3, r7, r3
    17d8:	2205      	movs	r2, #5
    17da:	701a      	strb	r2, [r3, #0]

  // Select external oscillator and Reference Divider and clear IREFS to start ext osc
  // If IRCLK is required it must be enabled outside of this driver, existing state will be maintained
  // CLKS=2, FRDIV=frdiv_val, IREFS=0, IRCLKEN=0, IREFSTEN=0
  temp_reg = MCG_C1;
    17dc:	4a51      	ldr	r2, [pc, #324]	; (1924 <pll_init+0x338>)
    17de:	2316      	movs	r3, #22
    17e0:	18fb      	adds	r3, r7, r3
    17e2:	7812      	ldrb	r2, [r2, #0]
    17e4:	701a      	strb	r2, [r3, #0]
  temp_reg &= ~(MCG_C1_CLKS_MASK | MCG_C1_FRDIV_MASK | MCG_C1_IREFS_MASK); // Clear values in these fields
    17e6:	2316      	movs	r3, #22
    17e8:	18fb      	adds	r3, r7, r3
    17ea:	2216      	movs	r2, #22
    17ec:	18ba      	adds	r2, r7, r2
    17ee:	7812      	ldrb	r2, [r2, #0]
    17f0:	2103      	movs	r1, #3
    17f2:	400a      	ands	r2, r1
    17f4:	701a      	strb	r2, [r3, #0]
  temp_reg |= (MCG_C1_CLKS(2) | MCG_C1_FRDIV(frdiv_val)); // Set the required CLKS and FRDIV values
    17f6:	2317      	movs	r3, #23
    17f8:	18fb      	adds	r3, r7, r3
    17fa:	781b      	ldrb	r3, [r3, #0]
    17fc:	00db      	lsls	r3, r3, #3
    17fe:	b2db      	uxtb	r3, r3
    1800:	2238      	movs	r2, #56	; 0x38
    1802:	4013      	ands	r3, r2
    1804:	b2da      	uxtb	r2, r3
    1806:	2316      	movs	r3, #22
    1808:	18fb      	adds	r3, r7, r3
    180a:	781b      	ldrb	r3, [r3, #0]
    180c:	4313      	orrs	r3, r2
    180e:	b2da      	uxtb	r2, r3
    1810:	2316      	movs	r3, #22
    1812:	18fb      	adds	r3, r7, r3
    1814:	2180      	movs	r1, #128	; 0x80
    1816:	4249      	negs	r1, r1
    1818:	430a      	orrs	r2, r1
    181a:	701a      	strb	r2, [r3, #0]
  MCG_C1 = temp_reg;
    181c:	4a41      	ldr	r2, [pc, #260]	; (1924 <pll_init+0x338>)
    181e:	2316      	movs	r3, #22
    1820:	18fb      	adds	r3, r7, r3
    1822:	781b      	ldrb	r3, [r3, #0]
    1824:	7013      	strb	r3, [r2, #0]

  // if the external oscillator is used need to wait for OSCINIT to set
  if (erefs_val)
    1826:	1cbb      	adds	r3, r7, #2
    1828:	781b      	ldrb	r3, [r3, #0]
    182a:	2b00      	cmp	r3, #0
    182c:	d027      	beq.n	187e <pll_init+0x292>
  {
    for (i = 0 ; i < 20000 ; i++)
    182e:	2314      	movs	r3, #20
    1830:	18fb      	adds	r3, r7, r3
    1832:	2200      	movs	r2, #0
    1834:	801a      	strh	r2, [r3, #0]
    1836:	e010      	b.n	185a <pll_init+0x26e>
    {
      if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
    1838:	4b3a      	ldr	r3, [pc, #232]	; (1924 <pll_init+0x338>)
    183a:	799b      	ldrb	r3, [r3, #6]
    183c:	b2db      	uxtb	r3, r3
    183e:	001a      	movs	r2, r3
    1840:	2302      	movs	r3, #2
    1842:	4013      	ands	r3, r2
    1844:	d111      	bne.n	186a <pll_init+0x27e>
    for (i = 0 ; i < 20000 ; i++)
    1846:	2314      	movs	r3, #20
    1848:	18fb      	adds	r3, r7, r3
    184a:	2200      	movs	r2, #0
    184c:	5e9b      	ldrsh	r3, [r3, r2]
    184e:	b29b      	uxth	r3, r3
    1850:	3301      	adds	r3, #1
    1852:	b29a      	uxth	r2, r3
    1854:	2314      	movs	r3, #20
    1856:	18fb      	adds	r3, r7, r3
    1858:	801a      	strh	r2, [r3, #0]
    185a:	2314      	movs	r3, #20
    185c:	18fb      	adds	r3, r7, r3
    185e:	2200      	movs	r2, #0
    1860:	5e9b      	ldrsh	r3, [r3, r2]
    1862:	4a3e      	ldr	r2, [pc, #248]	; (195c <pll_init+0x370>)
    1864:	4293      	cmp	r3, r2
    1866:	dde7      	ble.n	1838 <pll_init+0x24c>
    1868:	e000      	b.n	186c <pll_init+0x280>
      if (MCG_S & MCG_S_OSCINIT0_MASK) break; // jump out early if OSCINIT sets before loop finishes
    186a:	46c0      	nop			; (mov r8, r8)
    }
  if (!(MCG_S & MCG_S_OSCINIT0_MASK)) return 0x23; // check bit is really set and return with error if not set
    186c:	4b2d      	ldr	r3, [pc, #180]	; (1924 <pll_init+0x338>)
    186e:	799b      	ldrb	r3, [r3, #6]
    1870:	b2db      	uxtb	r3, r3
    1872:	001a      	movs	r2, r3
    1874:	2302      	movs	r3, #2
    1876:	4013      	ands	r3, r2
    1878:	d101      	bne.n	187e <pll_init+0x292>
    187a:	2323      	movs	r3, #35	; 0x23
    187c:	e161      	b.n	1b42 <pll_init+0x556>
  }

  // wait for Reference clock Status bit to clear
  for (i = 0 ; i < 2000 ; i++)
    187e:	2314      	movs	r3, #20
    1880:	18fb      	adds	r3, r7, r3
    1882:	2200      	movs	r2, #0
    1884:	801a      	strh	r2, [r3, #0]
    1886:	e010      	b.n	18aa <pll_init+0x2be>
  {
    if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
    1888:	4b26      	ldr	r3, [pc, #152]	; (1924 <pll_init+0x338>)
    188a:	799b      	ldrb	r3, [r3, #6]
    188c:	b2db      	uxtb	r3, r3
    188e:	001a      	movs	r2, r3
    1890:	2310      	movs	r3, #16
    1892:	4013      	ands	r3, r2
    1894:	d011      	beq.n	18ba <pll_init+0x2ce>
  for (i = 0 ; i < 2000 ; i++)
    1896:	2314      	movs	r3, #20
    1898:	18fb      	adds	r3, r7, r3
    189a:	2200      	movs	r2, #0
    189c:	5e9b      	ldrsh	r3, [r3, r2]
    189e:	b29b      	uxth	r3, r3
    18a0:	3301      	adds	r3, #1
    18a2:	b29a      	uxth	r2, r3
    18a4:	2314      	movs	r3, #20
    18a6:	18fb      	adds	r3, r7, r3
    18a8:	801a      	strh	r2, [r3, #0]
    18aa:	2314      	movs	r3, #20
    18ac:	18fb      	adds	r3, r7, r3
    18ae:	2200      	movs	r2, #0
    18b0:	5e9b      	ldrsh	r3, [r3, r2]
    18b2:	4a2b      	ldr	r2, [pc, #172]	; (1960 <pll_init+0x374>)
    18b4:	4293      	cmp	r3, r2
    18b6:	dde7      	ble.n	1888 <pll_init+0x29c>
    18b8:	e000      	b.n	18bc <pll_init+0x2d0>
    if (!(MCG_S & MCG_S_IREFST_MASK)) break; // jump out early if IREFST clears before loop finishes
    18ba:	46c0      	nop			; (mov r8, r8)
  }
  if (MCG_S & MCG_S_IREFST_MASK) return 0x11; // check bit is really clear and return with error if not set
    18bc:	4b19      	ldr	r3, [pc, #100]	; (1924 <pll_init+0x338>)
    18be:	799b      	ldrb	r3, [r3, #6]
    18c0:	b2db      	uxtb	r3, r3
    18c2:	001a      	movs	r2, r3
    18c4:	2310      	movs	r3, #16
    18c6:	4013      	ands	r3, r2
    18c8:	d001      	beq.n	18ce <pll_init+0x2e2>
    18ca:	2311      	movs	r3, #17
    18cc:	e139      	b.n	1b42 <pll_init+0x556>

  // Wait for clock status bits to show clock source is ext ref clk
  for (i = 0 ; i < 2000 ; i++)
    18ce:	2314      	movs	r3, #20
    18d0:	18fb      	adds	r3, r7, r3
    18d2:	2200      	movs	r2, #0
    18d4:	801a      	strh	r2, [r3, #0]
    18d6:	e011      	b.n	18fc <pll_init+0x310>
  {
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
    18d8:	4b12      	ldr	r3, [pc, #72]	; (1924 <pll_init+0x338>)
    18da:	799b      	ldrb	r3, [r3, #6]
    18dc:	b2db      	uxtb	r3, r3
    18de:	089b      	lsrs	r3, r3, #2
    18e0:	2203      	movs	r2, #3
    18e2:	4013      	ands	r3, r2
    18e4:	2b02      	cmp	r3, #2
    18e6:	d011      	beq.n	190c <pll_init+0x320>
  for (i = 0 ; i < 2000 ; i++)
    18e8:	2314      	movs	r3, #20
    18ea:	18fb      	adds	r3, r7, r3
    18ec:	2200      	movs	r2, #0
    18ee:	5e9b      	ldrsh	r3, [r3, r2]
    18f0:	b29b      	uxth	r3, r3
    18f2:	3301      	adds	r3, #1
    18f4:	b29a      	uxth	r2, r3
    18f6:	2314      	movs	r3, #20
    18f8:	18fb      	adds	r3, r7, r3
    18fa:	801a      	strh	r2, [r3, #0]
    18fc:	2314      	movs	r3, #20
    18fe:	18fb      	adds	r3, r7, r3
    1900:	2200      	movs	r2, #0
    1902:	5e9b      	ldrsh	r3, [r3, r2]
    1904:	4a16      	ldr	r2, [pc, #88]	; (1960 <pll_init+0x374>)
    1906:	4293      	cmp	r3, r2
    1908:	dde6      	ble.n	18d8 <pll_init+0x2ec>
    190a:	e000      	b.n	190e <pll_init+0x322>
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x2) break; // jump out early if CLKST shows EXT CLK slected before loop finishes
    190c:	46c0      	nop			; (mov r8, r8)
  }
  if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2) return 0x1A; // check EXT CLK is really selected and return with error if not
    190e:	4b05      	ldr	r3, [pc, #20]	; (1924 <pll_init+0x338>)
    1910:	799b      	ldrb	r3, [r3, #6]
    1912:	b2db      	uxtb	r3, r3
    1914:	089b      	lsrs	r3, r3, #2
    1916:	2203      	movs	r2, #3
    1918:	4013      	ands	r3, r2
    191a:	2b02      	cmp	r3, #2
    191c:	d022      	beq.n	1964 <pll_init+0x378>
    191e:	231a      	movs	r3, #26
    1920:	e10f      	b.n	1b42 <pll_init+0x556>
    1922:	46c0      	nop			; (mov r8, r8)
    1924:	40064000 	.word	0x40064000
    1928:	02faf080 	.word	0x02faf080
    192c:	002dc6bf 	.word	0x002dc6bf
    1930:	01e84800 	.word	0x01e84800
    1934:	001e847f 	.word	0x001e847f
    1938:	003d0900 	.word	0x003d0900
    193c:	02dc6bff 	.word	0x02dc6bff
    1940:	05f5e100 	.word	0x05f5e100
    1944:	007a1200 	.word	0x007a1200
    1948:	001312d0 	.word	0x001312d0
    194c:	002625a0 	.word	0x002625a0
    1950:	004c4b40 	.word	0x004c4b40
    1954:	00989680 	.word	0x00989680
    1958:	01312d00 	.word	0x01312d00
    195c:	00004e1f 	.word	0x00004e1f
    1960:	000007cf 	.word	0x000007cf

  // Now in FBE
  // It is recommended that the clock monitor is enabled when using an external clock as the clock source/reference.
  // It is enabled here but can be removed if this is not required.
  MCG_C6 |= MCG_C6_CME0_MASK;
    1964:	4a79      	ldr	r2, [pc, #484]	; (1b4c <pll_init+0x560>)
    1966:	4b79      	ldr	r3, [pc, #484]	; (1b4c <pll_init+0x560>)
    1968:	795b      	ldrb	r3, [r3, #5]
    196a:	b2db      	uxtb	r3, r3
    196c:	2120      	movs	r1, #32
    196e:	430b      	orrs	r3, r1
    1970:	b2db      	uxtb	r3, r3
    1972:	7153      	strb	r3, [r2, #5]
  
  // Configure PLL
  // Configure MCG_C5
  // If the PLL is to run in STOP mode then the PLLSTEN bit needs to be OR'ed in here or in user code.
  temp_reg = MCG_C5;
    1974:	4a75      	ldr	r2, [pc, #468]	; (1b4c <pll_init+0x560>)
    1976:	2316      	movs	r3, #22
    1978:	18fb      	adds	r3, r7, r3
    197a:	7912      	ldrb	r2, [r2, #4]
    197c:	701a      	strb	r2, [r3, #0]
  temp_reg &= ~MCG_C5_PRDIV0_MASK;
    197e:	2316      	movs	r3, #22
    1980:	18fb      	adds	r3, r7, r3
    1982:	2216      	movs	r2, #22
    1984:	18ba      	adds	r2, r7, r2
    1986:	7812      	ldrb	r2, [r2, #0]
    1988:	211f      	movs	r1, #31
    198a:	438a      	bics	r2, r1
    198c:	701a      	strb	r2, [r3, #0]
  temp_reg |= MCG_C5_PRDIV0(prdiv_val - 1);    //set PLL ref divider
    198e:	1c7b      	adds	r3, r7, #1
    1990:	781b      	ldrb	r3, [r3, #0]
    1992:	3b01      	subs	r3, #1
    1994:	b2db      	uxtb	r3, r3
    1996:	221f      	movs	r2, #31
    1998:	4013      	ands	r3, r2
    199a:	b2d9      	uxtb	r1, r3
    199c:	2316      	movs	r3, #22
    199e:	18fb      	adds	r3, r7, r3
    19a0:	2216      	movs	r2, #22
    19a2:	18ba      	adds	r2, r7, r2
    19a4:	7812      	ldrb	r2, [r2, #0]
    19a6:	430a      	orrs	r2, r1
    19a8:	701a      	strb	r2, [r3, #0]
  MCG_C5 = temp_reg;
    19aa:	4a68      	ldr	r2, [pc, #416]	; (1b4c <pll_init+0x560>)
    19ac:	2316      	movs	r3, #22
    19ae:	18fb      	adds	r3, r7, r3
    19b0:	781b      	ldrb	r3, [r3, #0]
    19b2:	7113      	strb	r3, [r2, #4]

  // Configure MCG_C6
  // The PLLS bit is set to enable the PLL, MCGOUT still sourced from ext ref clk
  // The loss of lock interrupt can be enabled by seperately OR'ing in the LOLIE bit in MCG_C6
  temp_reg = MCG_C6; // store present C6 value
    19b4:	4a65      	ldr	r2, [pc, #404]	; (1b4c <pll_init+0x560>)
    19b6:	2316      	movs	r3, #22
    19b8:	18fb      	adds	r3, r7, r3
    19ba:	7952      	ldrb	r2, [r2, #5]
    19bc:	701a      	strb	r2, [r3, #0]
  temp_reg &= ~MCG_C6_VDIV0_MASK; // clear VDIV settings
    19be:	2316      	movs	r3, #22
    19c0:	18fb      	adds	r3, r7, r3
    19c2:	2216      	movs	r2, #22
    19c4:	18ba      	adds	r2, r7, r2
    19c6:	7812      	ldrb	r2, [r2, #0]
    19c8:	211f      	movs	r1, #31
    19ca:	438a      	bics	r2, r1
    19cc:	701a      	strb	r2, [r3, #0]
  temp_reg |= MCG_C6_PLLS_MASK | MCG_C6_VDIV0(vdiv_val - 24); // write new VDIV and enable PLL
    19ce:	2328      	movs	r3, #40	; 0x28
    19d0:	18fb      	adds	r3, r7, r3
    19d2:	781b      	ldrb	r3, [r3, #0]
    19d4:	3b18      	subs	r3, #24
    19d6:	b2db      	uxtb	r3, r3
    19d8:	221f      	movs	r2, #31
    19da:	4013      	ands	r3, r2
    19dc:	b2da      	uxtb	r2, r3
    19de:	2316      	movs	r3, #22
    19e0:	18fb      	adds	r3, r7, r3
    19e2:	781b      	ldrb	r3, [r3, #0]
    19e4:	4313      	orrs	r3, r2
    19e6:	b2da      	uxtb	r2, r3
    19e8:	2316      	movs	r3, #22
    19ea:	18fb      	adds	r3, r7, r3
    19ec:	2140      	movs	r1, #64	; 0x40
    19ee:	430a      	orrs	r2, r1
    19f0:	701a      	strb	r2, [r3, #0]
  MCG_C6 = temp_reg; // update MCG_C6
    19f2:	4a56      	ldr	r2, [pc, #344]	; (1b4c <pll_init+0x560>)
    19f4:	2316      	movs	r3, #22
    19f6:	18fb      	adds	r3, r7, r3
    19f8:	781b      	ldrb	r3, [r3, #0]
    19fa:	7153      	strb	r3, [r2, #5]

  // wait for PLLST status bit to set
  for (i = 0 ; i < 2000 ; i++)
    19fc:	2314      	movs	r3, #20
    19fe:	18fb      	adds	r3, r7, r3
    1a00:	2200      	movs	r2, #0
    1a02:	801a      	strh	r2, [r3, #0]
    1a04:	e010      	b.n	1a28 <pll_init+0x43c>
  {
    if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
    1a06:	4b51      	ldr	r3, [pc, #324]	; (1b4c <pll_init+0x560>)
    1a08:	799b      	ldrb	r3, [r3, #6]
    1a0a:	b2db      	uxtb	r3, r3
    1a0c:	001a      	movs	r2, r3
    1a0e:	2320      	movs	r3, #32
    1a10:	4013      	ands	r3, r2
    1a12:	d111      	bne.n	1a38 <pll_init+0x44c>
  for (i = 0 ; i < 2000 ; i++)
    1a14:	2314      	movs	r3, #20
    1a16:	18fb      	adds	r3, r7, r3
    1a18:	2200      	movs	r2, #0
    1a1a:	5e9b      	ldrsh	r3, [r3, r2]
    1a1c:	b29b      	uxth	r3, r3
    1a1e:	3301      	adds	r3, #1
    1a20:	b29a      	uxth	r2, r3
    1a22:	2314      	movs	r3, #20
    1a24:	18fb      	adds	r3, r7, r3
    1a26:	801a      	strh	r2, [r3, #0]
    1a28:	2314      	movs	r3, #20
    1a2a:	18fb      	adds	r3, r7, r3
    1a2c:	2200      	movs	r2, #0
    1a2e:	5e9b      	ldrsh	r3, [r3, r2]
    1a30:	4a47      	ldr	r2, [pc, #284]	; (1b50 <pll_init+0x564>)
    1a32:	4293      	cmp	r3, r2
    1a34:	dde7      	ble.n	1a06 <pll_init+0x41a>
    1a36:	e000      	b.n	1a3a <pll_init+0x44e>
    if (MCG_S & MCG_S_PLLST_MASK) break; // jump out early if PLLST sets before loop finishes
    1a38:	46c0      	nop			; (mov r8, r8)
  }
  if (!(MCG_S & MCG_S_PLLST_MASK)) return 0x16; // check bit is really set and return with error if not set
    1a3a:	4b44      	ldr	r3, [pc, #272]	; (1b4c <pll_init+0x560>)
    1a3c:	799b      	ldrb	r3, [r3, #6]
    1a3e:	b2db      	uxtb	r3, r3
    1a40:	001a      	movs	r2, r3
    1a42:	2320      	movs	r3, #32
    1a44:	4013      	ands	r3, r2
    1a46:	d101      	bne.n	1a4c <pll_init+0x460>
    1a48:	2316      	movs	r3, #22
    1a4a:	e07a      	b.n	1b42 <pll_init+0x556>

  // Wait for LOCK bit to set
  for (i = 0 ; i < 4000 ; i++)
    1a4c:	2314      	movs	r3, #20
    1a4e:	18fb      	adds	r3, r7, r3
    1a50:	2200      	movs	r2, #0
    1a52:	801a      	strh	r2, [r3, #0]
    1a54:	e010      	b.n	1a78 <pll_init+0x48c>
  {
    if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
    1a56:	4b3d      	ldr	r3, [pc, #244]	; (1b4c <pll_init+0x560>)
    1a58:	799b      	ldrb	r3, [r3, #6]
    1a5a:	b2db      	uxtb	r3, r3
    1a5c:	001a      	movs	r2, r3
    1a5e:	2340      	movs	r3, #64	; 0x40
    1a60:	4013      	ands	r3, r2
    1a62:	d111      	bne.n	1a88 <pll_init+0x49c>
  for (i = 0 ; i < 4000 ; i++)
    1a64:	2314      	movs	r3, #20
    1a66:	18fb      	adds	r3, r7, r3
    1a68:	2200      	movs	r2, #0
    1a6a:	5e9b      	ldrsh	r3, [r3, r2]
    1a6c:	b29b      	uxth	r3, r3
    1a6e:	3301      	adds	r3, #1
    1a70:	b29a      	uxth	r2, r3
    1a72:	2314      	movs	r3, #20
    1a74:	18fb      	adds	r3, r7, r3
    1a76:	801a      	strh	r2, [r3, #0]
    1a78:	2314      	movs	r3, #20
    1a7a:	18fb      	adds	r3, r7, r3
    1a7c:	2200      	movs	r2, #0
    1a7e:	5e9b      	ldrsh	r3, [r3, r2]
    1a80:	4a34      	ldr	r2, [pc, #208]	; (1b54 <pll_init+0x568>)
    1a82:	4293      	cmp	r3, r2
    1a84:	dde7      	ble.n	1a56 <pll_init+0x46a>
    1a86:	e000      	b.n	1a8a <pll_init+0x49e>
    if (MCG_S & MCG_S_LOCK0_MASK) break; // jump out early if LOCK sets before loop finishes
    1a88:	46c0      	nop			; (mov r8, r8)
  }
  if (!(MCG_S & MCG_S_LOCK0_MASK)) return 0x44; // check bit is really set and return with error if not set
    1a8a:	4b30      	ldr	r3, [pc, #192]	; (1b4c <pll_init+0x560>)
    1a8c:	799b      	ldrb	r3, [r3, #6]
    1a8e:	b2db      	uxtb	r3, r3
    1a90:	001a      	movs	r2, r3
    1a92:	2340      	movs	r3, #64	; 0x40
    1a94:	4013      	ands	r3, r2
    1a96:	d101      	bne.n	1a9c <pll_init+0x4b0>
    1a98:	2344      	movs	r3, #68	; 0x44
    1a9a:	e052      	b.n	1b42 <pll_init+0x556>

  // Use actual PLL settings to calculate PLL frequency
  prdiv = ((MCG_C5 & MCG_C5_PRDIV0_MASK) + 1);
    1a9c:	4b2b      	ldr	r3, [pc, #172]	; (1b4c <pll_init+0x560>)
    1a9e:	791b      	ldrb	r3, [r3, #4]
    1aa0:	b2db      	uxtb	r3, r3
    1aa2:	221f      	movs	r2, #31
    1aa4:	4013      	ands	r3, r2
    1aa6:	b2da      	uxtb	r2, r3
    1aa8:	230b      	movs	r3, #11
    1aaa:	18fb      	adds	r3, r7, r3
    1aac:	3201      	adds	r2, #1
    1aae:	701a      	strb	r2, [r3, #0]
  vdiv = ((MCG_C6 & MCG_C6_VDIV0_MASK) + 24);
    1ab0:	4b26      	ldr	r3, [pc, #152]	; (1b4c <pll_init+0x560>)
    1ab2:	795b      	ldrb	r3, [r3, #5]
    1ab4:	b2db      	uxtb	r3, r3
    1ab6:	221f      	movs	r2, #31
    1ab8:	4013      	ands	r3, r2
    1aba:	b2da      	uxtb	r2, r3
    1abc:	230a      	movs	r3, #10
    1abe:	18fb      	adds	r3, r7, r3
    1ac0:	3218      	adds	r2, #24
    1ac2:	701a      	strb	r2, [r3, #0]

  // now in PBE

  MCG_C1 &= ~MCG_C1_CLKS_MASK; // clear CLKS to switch CLKS mux to select PLL as MCG_OUT
    1ac4:	4a21      	ldr	r2, [pc, #132]	; (1b4c <pll_init+0x560>)
    1ac6:	4b21      	ldr	r3, [pc, #132]	; (1b4c <pll_init+0x560>)
    1ac8:	781b      	ldrb	r3, [r3, #0]
    1aca:	b2db      	uxtb	r3, r3
    1acc:	213f      	movs	r1, #63	; 0x3f
    1ace:	400b      	ands	r3, r1
    1ad0:	b2db      	uxtb	r3, r3
    1ad2:	7013      	strb	r3, [r2, #0]

  // Wait for clock status bits to update
  for (i = 0 ; i < 2000 ; i++)
    1ad4:	2314      	movs	r3, #20
    1ad6:	18fb      	adds	r3, r7, r3
    1ad8:	2200      	movs	r2, #0
    1ada:	801a      	strh	r2, [r3, #0]
    1adc:	e011      	b.n	1b02 <pll_init+0x516>
  {
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
    1ade:	4b1b      	ldr	r3, [pc, #108]	; (1b4c <pll_init+0x560>)
    1ae0:	799b      	ldrb	r3, [r3, #6]
    1ae2:	b2db      	uxtb	r3, r3
    1ae4:	089b      	lsrs	r3, r3, #2
    1ae6:	2203      	movs	r2, #3
    1ae8:	4013      	ands	r3, r2
    1aea:	2b03      	cmp	r3, #3
    1aec:	d011      	beq.n	1b12 <pll_init+0x526>
  for (i = 0 ; i < 2000 ; i++)
    1aee:	2314      	movs	r3, #20
    1af0:	18fb      	adds	r3, r7, r3
    1af2:	2200      	movs	r2, #0
    1af4:	5e9b      	ldrsh	r3, [r3, r2]
    1af6:	b29b      	uxth	r3, r3
    1af8:	3301      	adds	r3, #1
    1afa:	b29a      	uxth	r2, r3
    1afc:	2314      	movs	r3, #20
    1afe:	18fb      	adds	r3, r7, r3
    1b00:	801a      	strh	r2, [r3, #0]
    1b02:	2314      	movs	r3, #20
    1b04:	18fb      	adds	r3, r7, r3
    1b06:	2200      	movs	r2, #0
    1b08:	5e9b      	ldrsh	r3, [r3, r2]
    1b0a:	4a11      	ldr	r2, [pc, #68]	; (1b50 <pll_init+0x564>)
    1b0c:	4293      	cmp	r3, r2
    1b0e:	dde6      	ble.n	1ade <pll_init+0x4f2>
    1b10:	e000      	b.n	1b14 <pll_init+0x528>
    if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) == 0x3) break; // jump out early if CLKST = 3 before loop finishes
    1b12:	46c0      	nop			; (mov r8, r8)
  }
  if (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3) return 0x1B; // check CLKST is set correctly and return with error if not
    1b14:	4b0d      	ldr	r3, [pc, #52]	; (1b4c <pll_init+0x560>)
    1b16:	799b      	ldrb	r3, [r3, #6]
    1b18:	b2db      	uxtb	r3, r3
    1b1a:	089b      	lsrs	r3, r3, #2
    1b1c:	2203      	movs	r2, #3
    1b1e:	4013      	ands	r3, r2
    1b20:	2b03      	cmp	r3, #3
    1b22:	d001      	beq.n	1b28 <pll_init+0x53c>
    1b24:	231b      	movs	r3, #27
    1b26:	e00c      	b.n	1b42 <pll_init+0x556>

  // Now in PEE
  
  return ((crystal_val / prdiv) * vdiv); //MCGOUT equals PLL output frequency
    1b28:	230b      	movs	r3, #11
    1b2a:	18fb      	adds	r3, r7, r3
    1b2c:	781b      	ldrb	r3, [r3, #0]
    1b2e:	0019      	movs	r1, r3
    1b30:	6878      	ldr	r0, [r7, #4]
    1b32:	f7fe fd1b 	bl	56c <__divsi3>
    1b36:	0003      	movs	r3, r0
    1b38:	001a      	movs	r2, r3
    1b3a:	230a      	movs	r3, #10
    1b3c:	18fb      	adds	r3, r7, r3
    1b3e:	781b      	ldrb	r3, [r3, #0]
    1b40:	4353      	muls	r3, r2
} // pll_init
    1b42:	0018      	movs	r0, r3
    1b44:	46bd      	mov	sp, r7
    1b46:	b007      	add	sp, #28
    1b48:	bd90      	pop	{r4, r7, pc}
    1b4a:	46c0      	nop			; (mov r8, r8)
    1b4c:	40064000 	.word	0x40064000
    1b50:	000007cf 	.word	0x000007cf
    1b54:	00000f9f 	.word	0x00000f9f

00001b58 <outSRS>:

/* OutSRS routine - checks the value in the SRS registers and sends
 * messages to the terminal announcing the status at the start of the 
 * code.
 */
void outSRS(void){                         //[outSRS]
    1b58:	b580      	push	{r7, lr}
    1b5a:	af00      	add	r7, sp, #0

  
	if (RCM_SRS1 & RCM_SRS1_SACKERR_MASK)
    1b5c:	4b78      	ldr	r3, [pc, #480]	; (1d40 <outSRS+0x1e8>)
    1b5e:	785b      	ldrb	r3, [r3, #1]
    1b60:	b2db      	uxtb	r3, r3
    1b62:	001a      	movs	r2, r3
    1b64:	2320      	movs	r3, #32
    1b66:	4013      	ands	r3, r2
    1b68:	d003      	beq.n	1b72 <outSRS+0x1a>
		printf("\n\rStop Mode Acknowledge Error Reset");
    1b6a:	4b76      	ldr	r3, [pc, #472]	; (1d44 <outSRS+0x1ec>)
    1b6c:	0018      	movs	r0, r3
    1b6e:	f7ff f973 	bl	e58 <printf>
	if (RCM_SRS1 & RCM_SRS1_MDM_AP_MASK)
    1b72:	4b73      	ldr	r3, [pc, #460]	; (1d40 <outSRS+0x1e8>)
    1b74:	785b      	ldrb	r3, [r3, #1]
    1b76:	b2db      	uxtb	r3, r3
    1b78:	001a      	movs	r2, r3
    1b7a:	2308      	movs	r3, #8
    1b7c:	4013      	ands	r3, r2
    1b7e:	d003      	beq.n	1b88 <outSRS+0x30>
		printf("\n\rMDM-AP Reset");
    1b80:	4b71      	ldr	r3, [pc, #452]	; (1d48 <outSRS+0x1f0>)
    1b82:	0018      	movs	r0, r3
    1b84:	f7ff f968 	bl	e58 <printf>
	if (RCM_SRS1 & RCM_SRS1_SW_MASK)
    1b88:	4b6d      	ldr	r3, [pc, #436]	; (1d40 <outSRS+0x1e8>)
    1b8a:	785b      	ldrb	r3, [r3, #1]
    1b8c:	b2db      	uxtb	r3, r3
    1b8e:	001a      	movs	r2, r3
    1b90:	2304      	movs	r3, #4
    1b92:	4013      	ands	r3, r2
    1b94:	d003      	beq.n	1b9e <outSRS+0x46>
		printf("\n\rSoftware Reset");
    1b96:	4b6d      	ldr	r3, [pc, #436]	; (1d4c <outSRS+0x1f4>)
    1b98:	0018      	movs	r0, r3
    1b9a:	f7ff f95d 	bl	e58 <printf>
	if (RCM_SRS1 & RCM_SRS1_LOCKUP_MASK)
    1b9e:	4b68      	ldr	r3, [pc, #416]	; (1d40 <outSRS+0x1e8>)
    1ba0:	785b      	ldrb	r3, [r3, #1]
    1ba2:	b2db      	uxtb	r3, r3
    1ba4:	001a      	movs	r2, r3
    1ba6:	2302      	movs	r3, #2
    1ba8:	4013      	ands	r3, r2
    1baa:	d003      	beq.n	1bb4 <outSRS+0x5c>
		printf("\n\rCore Lockup Event Reset");
    1bac:	4b68      	ldr	r3, [pc, #416]	; (1d50 <outSRS+0x1f8>)
    1bae:	0018      	movs	r0, r3
    1bb0:	f7ff f952 	bl	e58 <printf>
	
	if (RCM_SRS0 & RCM_SRS0_POR_MASK)
    1bb4:	4b62      	ldr	r3, [pc, #392]	; (1d40 <outSRS+0x1e8>)
    1bb6:	781b      	ldrb	r3, [r3, #0]
    1bb8:	b2db      	uxtb	r3, r3
    1bba:	b25b      	sxtb	r3, r3
    1bbc:	2b00      	cmp	r3, #0
    1bbe:	da03      	bge.n	1bc8 <outSRS+0x70>
		printf("\n\rPower-on Reset");
    1bc0:	4b64      	ldr	r3, [pc, #400]	; (1d54 <outSRS+0x1fc>)
    1bc2:	0018      	movs	r0, r3
    1bc4:	f7ff f948 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_PIN_MASK)
    1bc8:	4b5d      	ldr	r3, [pc, #372]	; (1d40 <outSRS+0x1e8>)
    1bca:	781b      	ldrb	r3, [r3, #0]
    1bcc:	b2db      	uxtb	r3, r3
    1bce:	001a      	movs	r2, r3
    1bd0:	2340      	movs	r3, #64	; 0x40
    1bd2:	4013      	ands	r3, r2
    1bd4:	d003      	beq.n	1bde <outSRS+0x86>
		printf("\n\rExternal Pin Reset");
    1bd6:	4b60      	ldr	r3, [pc, #384]	; (1d58 <outSRS+0x200>)
    1bd8:	0018      	movs	r0, r3
    1bda:	f7ff f93d 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_WDOG_MASK)
    1bde:	4b58      	ldr	r3, [pc, #352]	; (1d40 <outSRS+0x1e8>)
    1be0:	781b      	ldrb	r3, [r3, #0]
    1be2:	b2db      	uxtb	r3, r3
    1be4:	001a      	movs	r2, r3
    1be6:	2320      	movs	r3, #32
    1be8:	4013      	ands	r3, r2
    1bea:	d003      	beq.n	1bf4 <outSRS+0x9c>
		printf("\n\rWatchdog(COP) Reset");
    1bec:	4b5b      	ldr	r3, [pc, #364]	; (1d5c <outSRS+0x204>)
    1bee:	0018      	movs	r0, r3
    1bf0:	f7ff f932 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_LOC_MASK)
    1bf4:	4b52      	ldr	r3, [pc, #328]	; (1d40 <outSRS+0x1e8>)
    1bf6:	781b      	ldrb	r3, [r3, #0]
    1bf8:	b2db      	uxtb	r3, r3
    1bfa:	001a      	movs	r2, r3
    1bfc:	2304      	movs	r3, #4
    1bfe:	4013      	ands	r3, r2
    1c00:	d003      	beq.n	1c0a <outSRS+0xb2>
		printf("\n\rLoss of External Clock Reset");
    1c02:	4b57      	ldr	r3, [pc, #348]	; (1d60 <outSRS+0x208>)
    1c04:	0018      	movs	r0, r3
    1c06:	f7ff f927 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_LOL_MASK)
    1c0a:	4b4d      	ldr	r3, [pc, #308]	; (1d40 <outSRS+0x1e8>)
    1c0c:	781b      	ldrb	r3, [r3, #0]
    1c0e:	b2db      	uxtb	r3, r3
    1c10:	001a      	movs	r2, r3
    1c12:	2308      	movs	r3, #8
    1c14:	4013      	ands	r3, r2
    1c16:	d003      	beq.n	1c20 <outSRS+0xc8>
		printf("\n\rLoss of Lock in PLL Reset");
    1c18:	4b52      	ldr	r3, [pc, #328]	; (1d64 <outSRS+0x20c>)
    1c1a:	0018      	movs	r0, r3
    1c1c:	f7ff f91c 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_LVD_MASK)
    1c20:	4b47      	ldr	r3, [pc, #284]	; (1d40 <outSRS+0x1e8>)
    1c22:	781b      	ldrb	r3, [r3, #0]
    1c24:	b2db      	uxtb	r3, r3
    1c26:	001a      	movs	r2, r3
    1c28:	2302      	movs	r3, #2
    1c2a:	4013      	ands	r3, r2
    1c2c:	d003      	beq.n	1c36 <outSRS+0xde>
		printf("\n\rLow-voltage Detect Reset");
    1c2e:	4b4e      	ldr	r3, [pc, #312]	; (1d68 <outSRS+0x210>)
    1c30:	0018      	movs	r0, r3
    1c32:	f7ff f911 	bl	e58 <printf>
	if (RCM_SRS0 & RCM_SRS0_WAKEUP_MASK)
    1c36:	4b42      	ldr	r3, [pc, #264]	; (1d40 <outSRS+0x1e8>)
    1c38:	781b      	ldrb	r3, [r3, #0]
    1c3a:	b2db      	uxtb	r3, r3
    1c3c:	001a      	movs	r2, r3
    1c3e:	2301      	movs	r3, #1
    1c40:	4013      	ands	r3, r2
    1c42:	d05e      	beq.n	1d02 <outSRS+0x1aa>
        {
          printf("\n\r[outSRS]Wakeup bit set from low power mode ");
    1c44:	4b49      	ldr	r3, [pc, #292]	; (1d6c <outSRS+0x214>)
    1c46:	0018      	movs	r0, r3
    1c48:	f7ff f906 	bl	e58 <printf>
          if ((SMC_PMCTRL & SMC_PMCTRL_STOPM_MASK)== 3)
    1c4c:	4b48      	ldr	r3, [pc, #288]	; (1d70 <outSRS+0x218>)
    1c4e:	785b      	ldrb	r3, [r3, #1]
    1c50:	b2db      	uxtb	r3, r3
    1c52:	001a      	movs	r2, r3
    1c54:	2307      	movs	r3, #7
    1c56:	4013      	ands	r3, r2
    1c58:	2b03      	cmp	r3, #3
    1c5a:	d103      	bne.n	1c64 <outSRS+0x10c>
            printf("LLS exit ") ;
    1c5c:	4b45      	ldr	r3, [pc, #276]	; (1d74 <outSRS+0x21c>)
    1c5e:	0018      	movs	r0, r3
    1c60:	f7ff f8fa 	bl	e58 <printf>
          if (((SMC_PMCTRL & SMC_PMCTRL_STOPM_MASK)== 4) && ((SMC_STOPCTRL & SMC_STOPCTRL_VLLSM_MASK)== 0))
    1c64:	4b42      	ldr	r3, [pc, #264]	; (1d70 <outSRS+0x218>)
    1c66:	785b      	ldrb	r3, [r3, #1]
    1c68:	b2db      	uxtb	r3, r3
    1c6a:	001a      	movs	r2, r3
    1c6c:	2307      	movs	r3, #7
    1c6e:	4013      	ands	r3, r2
    1c70:	2b04      	cmp	r3, #4
    1c72:	d10a      	bne.n	1c8a <outSRS+0x132>
    1c74:	4b3e      	ldr	r3, [pc, #248]	; (1d70 <outSRS+0x218>)
    1c76:	789b      	ldrb	r3, [r3, #2]
    1c78:	b2db      	uxtb	r3, r3
    1c7a:	001a      	movs	r2, r3
    1c7c:	2307      	movs	r3, #7
    1c7e:	4013      	ands	r3, r2
    1c80:	d103      	bne.n	1c8a <outSRS+0x132>
            printf("VLLS0 exit ") ;
    1c82:	4b3d      	ldr	r3, [pc, #244]	; (1d78 <outSRS+0x220>)
    1c84:	0018      	movs	r0, r3
    1c86:	f7ff f8e7 	bl	e58 <printf>
          if (((SMC_PMCTRL & SMC_PMCTRL_STOPM_MASK)== 4) && ((SMC_STOPCTRL & SMC_STOPCTRL_VLLSM_MASK)== 1))
    1c8a:	4b39      	ldr	r3, [pc, #228]	; (1d70 <outSRS+0x218>)
    1c8c:	785b      	ldrb	r3, [r3, #1]
    1c8e:	b2db      	uxtb	r3, r3
    1c90:	001a      	movs	r2, r3
    1c92:	2307      	movs	r3, #7
    1c94:	4013      	ands	r3, r2
    1c96:	2b04      	cmp	r3, #4
    1c98:	d10b      	bne.n	1cb2 <outSRS+0x15a>
    1c9a:	4b35      	ldr	r3, [pc, #212]	; (1d70 <outSRS+0x218>)
    1c9c:	789b      	ldrb	r3, [r3, #2]
    1c9e:	b2db      	uxtb	r3, r3
    1ca0:	001a      	movs	r2, r3
    1ca2:	2307      	movs	r3, #7
    1ca4:	4013      	ands	r3, r2
    1ca6:	2b01      	cmp	r3, #1
    1ca8:	d103      	bne.n	1cb2 <outSRS+0x15a>
            printf("VLLS1 exit ") ;
    1caa:	4b34      	ldr	r3, [pc, #208]	; (1d7c <outSRS+0x224>)
    1cac:	0018      	movs	r0, r3
    1cae:	f7ff f8d3 	bl	e58 <printf>
          if (((SMC_PMCTRL & SMC_PMCTRL_STOPM_MASK)== 4) && ((SMC_STOPCTRL & SMC_STOPCTRL_VLLSM_MASK)== 2))
    1cb2:	4b2f      	ldr	r3, [pc, #188]	; (1d70 <outSRS+0x218>)
    1cb4:	785b      	ldrb	r3, [r3, #1]
    1cb6:	b2db      	uxtb	r3, r3
    1cb8:	001a      	movs	r2, r3
    1cba:	2307      	movs	r3, #7
    1cbc:	4013      	ands	r3, r2
    1cbe:	2b04      	cmp	r3, #4
    1cc0:	d10b      	bne.n	1cda <outSRS+0x182>
    1cc2:	4b2b      	ldr	r3, [pc, #172]	; (1d70 <outSRS+0x218>)
    1cc4:	789b      	ldrb	r3, [r3, #2]
    1cc6:	b2db      	uxtb	r3, r3
    1cc8:	001a      	movs	r2, r3
    1cca:	2307      	movs	r3, #7
    1ccc:	4013      	ands	r3, r2
    1cce:	2b02      	cmp	r3, #2
    1cd0:	d103      	bne.n	1cda <outSRS+0x182>
            printf("VLLS2 exit") ;
    1cd2:	4b2b      	ldr	r3, [pc, #172]	; (1d80 <outSRS+0x228>)
    1cd4:	0018      	movs	r0, r3
    1cd6:	f7ff f8bf 	bl	e58 <printf>
          if (((SMC_PMCTRL & SMC_PMCTRL_STOPM_MASK)== 4) && ((SMC_STOPCTRL & SMC_STOPCTRL_VLLSM_MASK)== 3))
    1cda:	4b25      	ldr	r3, [pc, #148]	; (1d70 <outSRS+0x218>)
    1cdc:	785b      	ldrb	r3, [r3, #1]
    1cde:	b2db      	uxtb	r3, r3
    1ce0:	001a      	movs	r2, r3
    1ce2:	2307      	movs	r3, #7
    1ce4:	4013      	ands	r3, r2
    1ce6:	2b04      	cmp	r3, #4
    1ce8:	d10b      	bne.n	1d02 <outSRS+0x1aa>
    1cea:	4b21      	ldr	r3, [pc, #132]	; (1d70 <outSRS+0x218>)
    1cec:	789b      	ldrb	r3, [r3, #2]
    1cee:	b2db      	uxtb	r3, r3
    1cf0:	001a      	movs	r2, r3
    1cf2:	2307      	movs	r3, #7
    1cf4:	4013      	ands	r3, r2
    1cf6:	2b03      	cmp	r3, #3
    1cf8:	d103      	bne.n	1d02 <outSRS+0x1aa>
            printf("VLLS3 exit ") ; 
    1cfa:	4b22      	ldr	r3, [pc, #136]	; (1d84 <outSRS+0x22c>)
    1cfc:	0018      	movs	r0, r3
    1cfe:	f7ff f8ab 	bl	e58 <printf>
	}

        if ((RCM_SRS0 == 0) && (RCM_SRS1 == 0)) 
    1d02:	4b0f      	ldr	r3, [pc, #60]	; (1d40 <outSRS+0x1e8>)
    1d04:	781b      	ldrb	r3, [r3, #0]
    1d06:	b2db      	uxtb	r3, r3
    1d08:	2b00      	cmp	r3, #0
    1d0a:	d116      	bne.n	1d3a <outSRS+0x1e2>
    1d0c:	4b0c      	ldr	r3, [pc, #48]	; (1d40 <outSRS+0x1e8>)
    1d0e:	785b      	ldrb	r3, [r3, #1]
    1d10:	b2db      	uxtb	r3, r3
    1d12:	2b00      	cmp	r3, #0
    1d14:	d111      	bne.n	1d3a <outSRS+0x1e2>
        {
	       printf("[outSRS]RCM_SRS0 is ZERO   = %#02X \r\n\r", (RCM_SRS0))  ;
    1d16:	4b0a      	ldr	r3, [pc, #40]	; (1d40 <outSRS+0x1e8>)
    1d18:	781b      	ldrb	r3, [r3, #0]
    1d1a:	b2db      	uxtb	r3, r3
    1d1c:	001a      	movs	r2, r3
    1d1e:	4b1a      	ldr	r3, [pc, #104]	; (1d88 <outSRS+0x230>)
    1d20:	0011      	movs	r1, r2
    1d22:	0018      	movs	r0, r3
    1d24:	f7ff f898 	bl	e58 <printf>
	       printf("[outSRS]RCM_SRS1 is ZERO   = %#02X \r\n\r", (RCM_SRS1))  ;	 
    1d28:	4b05      	ldr	r3, [pc, #20]	; (1d40 <outSRS+0x1e8>)
    1d2a:	785b      	ldrb	r3, [r3, #1]
    1d2c:	b2db      	uxtb	r3, r3
    1d2e:	001a      	movs	r2, r3
    1d30:	4b16      	ldr	r3, [pc, #88]	; (1d8c <outSRS+0x234>)
    1d32:	0011      	movs	r1, r2
    1d34:	0018      	movs	r0, r3
    1d36:	f7ff f88f 	bl	e58 <printf>
        }
  }
    1d3a:	46c0      	nop			; (mov r8, r8)
    1d3c:	46bd      	mov	sp, r7
    1d3e:	bd80      	pop	{r7, pc}
    1d40:	4007f000 	.word	0x4007f000
    1d44:	0000461c 	.word	0x0000461c
    1d48:	00004640 	.word	0x00004640
    1d4c:	00004650 	.word	0x00004650
    1d50:	00004664 	.word	0x00004664
    1d54:	00004680 	.word	0x00004680
    1d58:	00004694 	.word	0x00004694
    1d5c:	000046ac 	.word	0x000046ac
    1d60:	000046c4 	.word	0x000046c4
    1d64:	000046e4 	.word	0x000046e4
    1d68:	00004700 	.word	0x00004700
    1d6c:	0000471c 	.word	0x0000471c
    1d70:	4007e000 	.word	0x4007e000
    1d74:	0000474c 	.word	0x0000474c
    1d78:	00004758 	.word	0x00004758
    1d7c:	00004764 	.word	0x00004764
    1d80:	00004770 	.word	0x00004770
    1d84:	0000477c 	.word	0x0000477c
    1d88:	00004788 	.word	0x00004788
    1d8c:	000047b0 	.word	0x000047b0

00001d90 <uart0_init>:
 *  uartch      uart channel to initialize
 *  sysclk      uart module Clock in kHz(used to calculate baud)
 *  baud        uart baud rate
 */
void uart0_init (UART0_MemMapPtr uartch, int sysclk, int baud)
{
    1d90:	b580      	push	{r7, lr}
    1d92:	b08e      	sub	sp, #56	; 0x38
    1d94:	af00      	add	r7, sp, #0
    1d96:	60f8      	str	r0, [r7, #12]
    1d98:	60b9      	str	r1, [r7, #8]
    1d9a:	607a      	str	r2, [r7, #4]
    uint8 i;
    uint32 calculated_baud = 0;
    1d9c:	2300      	movs	r3, #0
    1d9e:	627b      	str	r3, [r7, #36]	; 0x24
    uint32 baud_diff = 0;
    1da0:	2300      	movs	r3, #0
    1da2:	633b      	str	r3, [r7, #48]	; 0x30
    uint32 osr_val = 0;
    1da4:	2300      	movs	r3, #0
    1da6:	62fb      	str	r3, [r7, #44]	; 0x2c
    uint32 sbr_val, uart0clk;
    uint32 baud_rate;
    uint32 reg_temp = 0;
    1da8:	2300      	movs	r3, #0
    1daa:	623b      	str	r3, [r7, #32]
    uint32 temp = 0;
    1dac:	2300      	movs	r3, #0
    1dae:	62bb      	str	r3, [r7, #40]	; 0x28
    
    SIM_SCGC4 |= SIM_SCGC4_UART0_MASK;
    1db0:	497d      	ldr	r1, [pc, #500]	; (1fa8 <uart0_init+0x218>)
    1db2:	4a7d      	ldr	r2, [pc, #500]	; (1fa8 <uart0_init+0x218>)
    1db4:	4b7d      	ldr	r3, [pc, #500]	; (1fac <uart0_init+0x21c>)
    1db6:	58d3      	ldr	r3, [r2, r3]
    1db8:	2280      	movs	r2, #128	; 0x80
    1dba:	00d2      	lsls	r2, r2, #3
    1dbc:	4313      	orrs	r3, r2
    1dbe:	4a7b      	ldr	r2, [pc, #492]	; (1fac <uart0_init+0x21c>)
    1dc0:	508b      	str	r3, [r1, r2]
    
    // Disable UART0 before changing registers
    UART0_C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK);
    1dc2:	4a7b      	ldr	r2, [pc, #492]	; (1fb0 <uart0_init+0x220>)
    1dc4:	4b7a      	ldr	r3, [pc, #488]	; (1fb0 <uart0_init+0x220>)
    1dc6:	78db      	ldrb	r3, [r3, #3]
    1dc8:	b2db      	uxtb	r3, r3
    1dca:	210c      	movs	r1, #12
    1dcc:	438b      	bics	r3, r1
    1dce:	b2db      	uxtb	r3, r3
    1dd0:	70d3      	strb	r3, [r2, #3]
  
    // Verify that a valid clock value has been passed to the function 
    if ((sysclk > 50000) || (sysclk < 32))
    1dd2:	68bb      	ldr	r3, [r7, #8]
    1dd4:	4a77      	ldr	r2, [pc, #476]	; (1fb4 <uart0_init+0x224>)
    1dd6:	4293      	cmp	r3, r2
    1dd8:	dc02      	bgt.n	1de0 <uart0_init+0x50>
    1dda:	68bb      	ldr	r3, [r7, #8]
    1ddc:	2b1f      	cmp	r3, #31
    1dde:	dc0e      	bgt.n	1dfe <uart0_init+0x6e>
    {
        sysclk = 0;
    1de0:	2300      	movs	r3, #0
    1de2:	60bb      	str	r3, [r7, #8]
        reg_temp = SIM_SOPT2;
    1de4:	4a70      	ldr	r2, [pc, #448]	; (1fa8 <uart0_init+0x218>)
    1de6:	4b74      	ldr	r3, [pc, #464]	; (1fb8 <uart0_init+0x228>)
    1de8:	58d3      	ldr	r3, [r2, r3]
    1dea:	623b      	str	r3, [r7, #32]
        reg_temp &= ~SIM_SOPT2_UART0SRC_MASK;
    1dec:	6a3b      	ldr	r3, [r7, #32]
    1dee:	4a73      	ldr	r2, [pc, #460]	; (1fbc <uart0_init+0x22c>)
    1df0:	4013      	ands	r3, r2
    1df2:	623b      	str	r3, [r7, #32]
        reg_temp |= SIM_SOPT2_UART0SRC(0);
        SIM_SOPT2 = reg_temp;
    1df4:	496c      	ldr	r1, [pc, #432]	; (1fa8 <uart0_init+0x218>)
    1df6:	4a70      	ldr	r2, [pc, #448]	; (1fb8 <uart0_init+0x228>)
    1df8:	6a3b      	ldr	r3, [r7, #32]
    1dfa:	508b      	str	r3, [r1, r2]
			
			  // Enter inifinite loop because the 
			  // the desired system clock value is 
			  // invalid!!
			  while(1)
    1dfc:	e7fe      	b.n	1dfc <uart0_init+0x6c>
    }
    
    
    
    // Initialize baud rate
    baud_rate = baud;
    1dfe:	687b      	ldr	r3, [r7, #4]
    1e00:	61fb      	str	r3, [r7, #28]
    
    // Change units to Hz
    uart0clk = sysclk * 1000;
    1e02:	68bb      	ldr	r3, [r7, #8]
    1e04:	22fa      	movs	r2, #250	; 0xfa
    1e06:	0092      	lsls	r2, r2, #2
    1e08:	4353      	muls	r3, r2
    1e0a:	61bb      	str	r3, [r7, #24]
    // Calculate the first baud rate using the lowest OSR value possible.  
    i = 4;
    1e0c:	2337      	movs	r3, #55	; 0x37
    1e0e:	18fb      	adds	r3, r7, r3
    1e10:	2204      	movs	r2, #4
    1e12:	701a      	strb	r2, [r3, #0]
    sbr_val = (uint32)(uart0clk/(baud_rate * i));
    1e14:	2337      	movs	r3, #55	; 0x37
    1e16:	18fb      	adds	r3, r7, r3
    1e18:	781b      	ldrb	r3, [r3, #0]
    1e1a:	69fa      	ldr	r2, [r7, #28]
    1e1c:	4353      	muls	r3, r2
    1e1e:	0019      	movs	r1, r3
    1e20:	69b8      	ldr	r0, [r7, #24]
    1e22:	f7fe fb19 	bl	458 <__udivsi3>
    1e26:	0003      	movs	r3, r0
    1e28:	617b      	str	r3, [r7, #20]
    calculated_baud = (uart0clk / (i * sbr_val));
    1e2a:	2337      	movs	r3, #55	; 0x37
    1e2c:	18fb      	adds	r3, r7, r3
    1e2e:	781b      	ldrb	r3, [r3, #0]
    1e30:	697a      	ldr	r2, [r7, #20]
    1e32:	4353      	muls	r3, r2
    1e34:	0019      	movs	r1, r3
    1e36:	69b8      	ldr	r0, [r7, #24]
    1e38:	f7fe fb0e 	bl	458 <__udivsi3>
    1e3c:	0003      	movs	r3, r0
    1e3e:	627b      	str	r3, [r7, #36]	; 0x24
        
    if (calculated_baud > baud_rate)
    1e40:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1e42:	69fb      	ldr	r3, [r7, #28]
    1e44:	429a      	cmp	r2, r3
    1e46:	d904      	bls.n	1e52 <uart0_init+0xc2>
        baud_diff = calculated_baud - baud_rate;
    1e48:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1e4a:	69fb      	ldr	r3, [r7, #28]
    1e4c:	1ad3      	subs	r3, r2, r3
    1e4e:	633b      	str	r3, [r7, #48]	; 0x30
    1e50:	e003      	b.n	1e5a <uart0_init+0xca>
    else
        baud_diff = baud_rate - calculated_baud;
    1e52:	69fa      	ldr	r2, [r7, #28]
    1e54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1e56:	1ad3      	subs	r3, r2, r3
    1e58:	633b      	str	r3, [r7, #48]	; 0x30
    
    osr_val = i;
    1e5a:	2337      	movs	r3, #55	; 0x37
    1e5c:	18fb      	adds	r3, r7, r3
    1e5e:	781b      	ldrb	r3, [r3, #0]
    1e60:	62fb      	str	r3, [r7, #44]	; 0x2c
        
    // Select the best OSR value
    for (i = 5; i <= 32; i++)
    1e62:	2337      	movs	r3, #55	; 0x37
    1e64:	18fb      	adds	r3, r7, r3
    1e66:	2205      	movs	r2, #5
    1e68:	701a      	strb	r2, [r3, #0]
    1e6a:	e033      	b.n	1ed4 <uart0_init+0x144>
    {
        sbr_val = (uint32)(uart0clk/(baud_rate * i));
    1e6c:	2337      	movs	r3, #55	; 0x37
    1e6e:	18fb      	adds	r3, r7, r3
    1e70:	781b      	ldrb	r3, [r3, #0]
    1e72:	69fa      	ldr	r2, [r7, #28]
    1e74:	4353      	muls	r3, r2
    1e76:	0019      	movs	r1, r3
    1e78:	69b8      	ldr	r0, [r7, #24]
    1e7a:	f7fe faed 	bl	458 <__udivsi3>
    1e7e:	0003      	movs	r3, r0
    1e80:	617b      	str	r3, [r7, #20]
        calculated_baud = (uart0clk / (i * sbr_val));
    1e82:	2337      	movs	r3, #55	; 0x37
    1e84:	18fb      	adds	r3, r7, r3
    1e86:	781b      	ldrb	r3, [r3, #0]
    1e88:	697a      	ldr	r2, [r7, #20]
    1e8a:	4353      	muls	r3, r2
    1e8c:	0019      	movs	r1, r3
    1e8e:	69b8      	ldr	r0, [r7, #24]
    1e90:	f7fe fae2 	bl	458 <__udivsi3>
    1e94:	0003      	movs	r3, r0
    1e96:	627b      	str	r3, [r7, #36]	; 0x24
        
        if (calculated_baud > baud_rate)
    1e98:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1e9a:	69fb      	ldr	r3, [r7, #28]
    1e9c:	429a      	cmp	r2, r3
    1e9e:	d904      	bls.n	1eaa <uart0_init+0x11a>
            temp = calculated_baud - baud_rate;
    1ea0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
    1ea2:	69fb      	ldr	r3, [r7, #28]
    1ea4:	1ad3      	subs	r3, r2, r3
    1ea6:	62bb      	str	r3, [r7, #40]	; 0x28
    1ea8:	e003      	b.n	1eb2 <uart0_init+0x122>
        else
            temp = baud_rate - calculated_baud;
    1eaa:	69fa      	ldr	r2, [r7, #28]
    1eac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    1eae:	1ad3      	subs	r3, r2, r3
    1eb0:	62bb      	str	r3, [r7, #40]	; 0x28
        
        if (temp <= baud_diff)
    1eb2:	6aba      	ldr	r2, [r7, #40]	; 0x28
    1eb4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    1eb6:	429a      	cmp	r2, r3
    1eb8:	d805      	bhi.n	1ec6 <uart0_init+0x136>
        {
            baud_diff = temp;
    1eba:	6abb      	ldr	r3, [r7, #40]	; 0x28
    1ebc:	633b      	str	r3, [r7, #48]	; 0x30
            osr_val = i; 
    1ebe:	2337      	movs	r3, #55	; 0x37
    1ec0:	18fb      	adds	r3, r7, r3
    1ec2:	781b      	ldrb	r3, [r3, #0]
    1ec4:	62fb      	str	r3, [r7, #44]	; 0x2c
    for (i = 5; i <= 32; i++)
    1ec6:	2337      	movs	r3, #55	; 0x37
    1ec8:	18fb      	adds	r3, r7, r3
    1eca:	781a      	ldrb	r2, [r3, #0]
    1ecc:	2337      	movs	r3, #55	; 0x37
    1ece:	18fb      	adds	r3, r7, r3
    1ed0:	3201      	adds	r2, #1
    1ed2:	701a      	strb	r2, [r3, #0]
    1ed4:	2337      	movs	r3, #55	; 0x37
    1ed6:	18fb      	adds	r3, r7, r3
    1ed8:	781b      	ldrb	r3, [r3, #0]
    1eda:	2b20      	cmp	r3, #32
    1edc:	d9c6      	bls.n	1e6c <uart0_init+0xdc>
        }
    }
    
    if (baud_diff < ((baud_rate / 100) * 3))
    1ede:	69fb      	ldr	r3, [r7, #28]
    1ee0:	2164      	movs	r1, #100	; 0x64
    1ee2:	0018      	movs	r0, r3
    1ee4:	f7fe fab8 	bl	458 <__udivsi3>
    1ee8:	0003      	movs	r3, r0
    1eea:	001a      	movs	r2, r3
    1eec:	0013      	movs	r3, r2
    1eee:	005b      	lsls	r3, r3, #1
    1ef0:	189a      	adds	r2, r3, r2
    1ef2:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    1ef4:	429a      	cmp	r2, r3
    1ef6:	d952      	bls.n	1f9e <uart0_init+0x20e>
    {
        // If the OSR is between 4x and 8x then both
        // edge sampling MUST be turned on.  
        if ((osr_val >3) && (osr_val < 9))
    1ef8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1efa:	2b03      	cmp	r3, #3
    1efc:	d90a      	bls.n	1f14 <uart0_init+0x184>
    1efe:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f00:	2b08      	cmp	r3, #8
    1f02:	d807      	bhi.n	1f14 <uart0_init+0x184>
            UART0_C5|= UART0_C5_BOTHEDGE_MASK;
    1f04:	4a2a      	ldr	r2, [pc, #168]	; (1fb0 <uart0_init+0x220>)
    1f06:	4b2a      	ldr	r3, [pc, #168]	; (1fb0 <uart0_init+0x220>)
    1f08:	7adb      	ldrb	r3, [r3, #11]
    1f0a:	b2db      	uxtb	r3, r3
    1f0c:	2102      	movs	r1, #2
    1f0e:	430b      	orrs	r3, r1
    1f10:	b2db      	uxtb	r3, r3
    1f12:	72d3      	strb	r3, [r2, #11]
        
        // Setup OSR value 
        reg_temp = UART0_C4;
    1f14:	4b26      	ldr	r3, [pc, #152]	; (1fb0 <uart0_init+0x220>)
    1f16:	7a9b      	ldrb	r3, [r3, #10]
    1f18:	b2db      	uxtb	r3, r3
    1f1a:	623b      	str	r3, [r7, #32]
        reg_temp &= ~UART0_C4_OSR_MASK;
    1f1c:	6a3b      	ldr	r3, [r7, #32]
    1f1e:	221f      	movs	r2, #31
    1f20:	4393      	bics	r3, r2
    1f22:	623b      	str	r3, [r7, #32]
        reg_temp |= UART0_C4_OSR(osr_val-1);
    1f24:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    1f26:	b2db      	uxtb	r3, r3
    1f28:	3b01      	subs	r3, #1
    1f2a:	b2db      	uxtb	r3, r3
    1f2c:	001a      	movs	r2, r3
    1f2e:	231f      	movs	r3, #31
    1f30:	4013      	ands	r3, r2
    1f32:	6a3a      	ldr	r2, [r7, #32]
    1f34:	4313      	orrs	r3, r2
    1f36:	623b      	str	r3, [r7, #32]
    
        // Write reg_temp to C4 register
        UART0_C4 = reg_temp;
    1f38:	4b1d      	ldr	r3, [pc, #116]	; (1fb0 <uart0_init+0x220>)
    1f3a:	6a3a      	ldr	r2, [r7, #32]
    1f3c:	b2d2      	uxtb	r2, r2
    1f3e:	729a      	strb	r2, [r3, #10]
        
        reg_temp = (reg_temp & UART0_C4_OSR_MASK) + 1;
    1f40:	6a3b      	ldr	r3, [r7, #32]
    1f42:	221f      	movs	r2, #31
    1f44:	4013      	ands	r3, r2
    1f46:	3301      	adds	r3, #1
    1f48:	623b      	str	r3, [r7, #32]
        sbr_val = (uint32)((uart0clk)/(baud_rate * (reg_temp)));
    1f4a:	69fb      	ldr	r3, [r7, #28]
    1f4c:	6a3a      	ldr	r2, [r7, #32]
    1f4e:	4353      	muls	r3, r2
    1f50:	0019      	movs	r1, r3
    1f52:	69b8      	ldr	r0, [r7, #24]
    1f54:	f7fe fa80 	bl	458 <__udivsi3>
    1f58:	0003      	movs	r3, r0
    1f5a:	617b      	str	r3, [r7, #20]
        
         /* Save off the current value of the uartx_BDH except for the SBR field */
        reg_temp = UART0_BDH & ~(UART0_BDH_SBR(0x1F));
    1f5c:	4b14      	ldr	r3, [pc, #80]	; (1fb0 <uart0_init+0x220>)
    1f5e:	781b      	ldrb	r3, [r3, #0]
    1f60:	b2db      	uxtb	r3, r3
    1f62:	001a      	movs	r2, r3
    1f64:	231f      	movs	r3, #31
    1f66:	439a      	bics	r2, r3
    1f68:	0013      	movs	r3, r2
    1f6a:	623b      	str	r3, [r7, #32]
   
        UART0_BDH = reg_temp |  UART0_BDH_SBR(((sbr_val & 0x1F00) >> 8));
    1f6c:	4910      	ldr	r1, [pc, #64]	; (1fb0 <uart0_init+0x220>)
    1f6e:	697b      	ldr	r3, [r7, #20]
    1f70:	0a1b      	lsrs	r3, r3, #8
    1f72:	b2db      	uxtb	r3, r3
    1f74:	221f      	movs	r2, #31
    1f76:	4013      	ands	r3, r2
    1f78:	b2da      	uxtb	r2, r3
    1f7a:	6a3b      	ldr	r3, [r7, #32]
    1f7c:	b2db      	uxtb	r3, r3
    1f7e:	4313      	orrs	r3, r2
    1f80:	b2db      	uxtb	r3, r3
    1f82:	700b      	strb	r3, [r1, #0]
        UART0_BDL = (uint8)(sbr_val & UART0_BDL_SBR_MASK);
    1f84:	4b0a      	ldr	r3, [pc, #40]	; (1fb0 <uart0_init+0x220>)
    1f86:	697a      	ldr	r2, [r7, #20]
    1f88:	b2d2      	uxtb	r2, r2
    1f8a:	705a      	strb	r2, [r3, #1]
        
        /* Enable receiver and transmitter */
        UART0_C2 |= (UART0_C2_TE_MASK
    1f8c:	4a08      	ldr	r2, [pc, #32]	; (1fb0 <uart0_init+0x220>)
    1f8e:	4b08      	ldr	r3, [pc, #32]	; (1fb0 <uart0_init+0x220>)
    1f90:	78db      	ldrb	r3, [r3, #3]
    1f92:	b2db      	uxtb	r3, r3
    1f94:	210c      	movs	r1, #12
    1f96:	430b      	orrs	r3, r1
    1f98:	b2db      	uxtb	r3, r3
    1f9a:	70d3      	strb	r3, [r2, #3]
        // Enter infinite loop!
        while(1)
				{}
		}					
    
}
    1f9c:	e000      	b.n	1fa0 <uart0_init+0x210>
        while(1)
    1f9e:	e7fe      	b.n	1f9e <uart0_init+0x20e>
}
    1fa0:	46bd      	mov	sp, r7
    1fa2:	b00e      	add	sp, #56	; 0x38
    1fa4:	bd80      	pop	{r7, pc}
    1fa6:	46c0      	nop			; (mov r8, r8)
    1fa8:	40047000 	.word	0x40047000
    1fac:	00001034 	.word	0x00001034
    1fb0:	4006a000 	.word	0x4006a000
    1fb4:	0000c350 	.word	0x0000c350
    1fb8:	00001004 	.word	0x00001004
    1fbc:	f3ffffff 	.word	0xf3ffffff

00001fc0 <uart0_putchar>:
 * Parameters:
 *  channel      uart channel to send to
 *  ch			 character to send
 */ 
void uart0_putchar (UART0_MemMapPtr channel, char ch)
{
    1fc0:	b580      	push	{r7, lr}
    1fc2:	b082      	sub	sp, #8
    1fc4:	af00      	add	r7, sp, #0
    1fc6:	6078      	str	r0, [r7, #4]
    1fc8:	000a      	movs	r2, r1
    1fca:	1cfb      	adds	r3, r7, #3
    1fcc:	701a      	strb	r2, [r3, #0]
      /* Wait until space is available in the FIFO */
      while(!(UART0_S1_REG(channel) & UART0_S1_TDRE_MASK));
    1fce:	46c0      	nop			; (mov r8, r8)
    1fd0:	687b      	ldr	r3, [r7, #4]
    1fd2:	791b      	ldrb	r3, [r3, #4]
    1fd4:	b2db      	uxtb	r3, r3
    1fd6:	b25b      	sxtb	r3, r3
    1fd8:	2b00      	cmp	r3, #0
    1fda:	daf9      	bge.n	1fd0 <uart0_putchar+0x10>
    
      /* Send the character */
      UART0_D_REG(channel) = (uint8)ch;
    1fdc:	687b      	ldr	r3, [r7, #4]
    1fde:	1cfa      	adds	r2, r7, #3
    1fe0:	7812      	ldrb	r2, [r2, #0]
    1fe2:	71da      	strb	r2, [r3, #7]
    
 }
    1fe4:	46c0      	nop			; (mov r8, r8)
    1fe6:	46bd      	mov	sp, r7
    1fe8:	b002      	add	sp, #8
    1fea:	bd80      	pop	{r7, pc}

00001fec <usb_init>:
signed short resultx, resulty, resultz;
char aux1;

/******************************************************************************/
void usb_init(void)
{
    1fec:	b580      	push	{r7, lr}
    1fee:	af00      	add	r7, sp, #0
      printf("\n********** USB XCVR Module Testing **********\n");     
    1ff0:	4b11      	ldr	r3, [pc, #68]	; (2038 <usb_init+0x4c>)
    1ff2:	0018      	movs	r0, r3
    1ff4:	f7fe ff30 	bl	e58 <printf>
      USB_REG_SET_ENABLE;
    1ff8:	4b10      	ldr	r3, [pc, #64]	; (203c <usb_init+0x50>)
    1ffa:	4a10      	ldr	r2, [pc, #64]	; (203c <usb_init+0x50>)
    1ffc:	6852      	ldr	r2, [r2, #4]
    1ffe:	2180      	movs	r1, #128	; 0x80
    2000:	0449      	lsls	r1, r1, #17
    2002:	430a      	orrs	r2, r1
    2004:	605a      	str	r2, [r3, #4]
    2006:	4b0d      	ldr	r3, [pc, #52]	; (203c <usb_init+0x50>)
    2008:	4a0c      	ldr	r2, [pc, #48]	; (203c <usb_init+0x50>)
    200a:	6812      	ldr	r2, [r2, #0]
    200c:	2180      	movs	r1, #128	; 0x80
    200e:	0609      	lsls	r1, r1, #24
    2010:	430a      	orrs	r2, r1
    2012:	601a      	str	r2, [r3, #0]
      CDC_Init();
    2014:	f001 fec0 	bl	3d98 <CDC_Init>
      // Pull up enable
      FLAG_SET(USB_CONTROL_DPPULLUPNONOTG_SHIFT,USB0_CONTROL);
    2018:	4a09      	ldr	r2, [pc, #36]	; (2040 <usb_init+0x54>)
    201a:	4909      	ldr	r1, [pc, #36]	; (2040 <usb_init+0x54>)
    201c:	2384      	movs	r3, #132	; 0x84
    201e:	005b      	lsls	r3, r3, #1
    2020:	5ccb      	ldrb	r3, [r1, r3]
    2022:	b2db      	uxtb	r3, r3
    2024:	2110      	movs	r1, #16
    2026:	430b      	orrs	r3, r1
    2028:	b2d9      	uxtb	r1, r3
    202a:	2384      	movs	r3, #132	; 0x84
    202c:	005b      	lsls	r3, r3, #1
    202e:	54d1      	strb	r1, [r2, r3]
}
    2030:	46c0      	nop			; (mov r8, r8)
    2032:	46bd      	mov	sp, r7
    2034:	bd80      	pop	{r7, pc}
    2036:	46c0      	nop			; (mov r8, r8)
    2038:	000047d8 	.word	0x000047d8
    203c:	40047000 	.word	0x40047000
    2040:	40072000 	.word	0x40072000

00002044 <usb_service>:


void usb_service(void)
{
    2044:	b580      	push	{r7, lr}
    2046:	af00      	add	r7, sp, #0
    // If data transfer arrives
    if(FLAG_CHK(EP_OUT,gu8USB_Flags))
    2048:	4b1b      	ldr	r3, [pc, #108]	; (20b8 <usb_service+0x74>)
    204a:	781b      	ldrb	r3, [r3, #0]
    204c:	001a      	movs	r2, r3
    204e:	2308      	movs	r3, #8
    2050:	4013      	ands	r3, r2
    2052:	d017      	beq.n	2084 <usb_service+0x40>
    {
        (void)USB_EP_OUT_SizeCheck(EP_OUT);
    2054:	2003      	movs	r0, #3
    2056:	f001 fb1b 	bl	3690 <USB_EP_OUT_SizeCheck>
        usbEP_Reset(EP_OUT);
    205a:	4b18      	ldr	r3, [pc, #96]	; (20bc <usb_service+0x78>)
    205c:	2262      	movs	r2, #98	; 0x62
    205e:	2120      	movs	r1, #32
    2060:	5299      	strh	r1, [r3, r2]
        usbSIE_CONTROL(EP_OUT);
    2062:	4b16      	ldr	r3, [pc, #88]	; (20bc <usb_service+0x78>)
    2064:	2260      	movs	r2, #96	; 0x60
    2066:	2180      	movs	r1, #128	; 0x80
    2068:	5499      	strb	r1, [r3, r2]
        FLAG_CLR(EP_OUT,gu8USB_Flags);
    206a:	4b13      	ldr	r3, [pc, #76]	; (20b8 <usb_service+0x74>)
    206c:	781b      	ldrb	r3, [r3, #0]
    206e:	2208      	movs	r2, #8
    2070:	4393      	bics	r3, r2
    2072:	b2da      	uxtb	r2, r3
    2074:	4b10      	ldr	r3, [pc, #64]	; (20b8 <usb_service+0x74>)
    2076:	701a      	strb	r2, [r3, #0]

        // Send it back to the PC
        EP_IN_Transfer(EP2,CDC_OUTPointer,1);
    2078:	4b11      	ldr	r3, [pc, #68]	; (20c0 <usb_service+0x7c>)
    207a:	2201      	movs	r2, #1
    207c:	0019      	movs	r1, r3
    207e:	2002      	movs	r0, #2
    2080:	f001 f9d8 	bl	3434 <EP_IN_Transfer>
    }
    if (!ti_print)
    2084:	4b0f      	ldr	r3, [pc, #60]	; (20c4 <usb_service+0x80>)
    2086:	881b      	ldrh	r3, [r3, #0]
    2088:	2b00      	cmp	r3, #0
    208a:	d111      	bne.n	20b0 <usb_service+0x6c>
    {
        ti_print = 300;
    208c:	4b0d      	ldr	r3, [pc, #52]	; (20c4 <usb_service+0x80>)
    208e:	2296      	movs	r2, #150	; 0x96
    2090:	0052      	lsls	r2, r2, #1
    2092:	801a      	strh	r2, [r3, #0]
        sprintf(gu8USB_Buffer,"\rtsi %%= %03i ", AbsolutePercentegePosition);
    2094:	4b0c      	ldr	r3, [pc, #48]	; (20c8 <usb_service+0x84>)
    2096:	781b      	ldrb	r3, [r3, #0]
    2098:	001a      	movs	r2, r3
    209a:	490c      	ldr	r1, [pc, #48]	; (20cc <usb_service+0x88>)
    209c:	4b0c      	ldr	r3, [pc, #48]	; (20d0 <usb_service+0x8c>)
    209e:	0018      	movs	r0, r3
    20a0:	f7fe fefa 	bl	e98 <sprintf>
        EP_IN_Transfer(EP2,gu8USB_Buffer,15);
    20a4:	4b0a      	ldr	r3, [pc, #40]	; (20d0 <usb_service+0x8c>)
    20a6:	220f      	movs	r2, #15
    20a8:	0019      	movs	r1, r3
    20aa:	2002      	movs	r0, #2
    20ac:	f001 f9c2 	bl	3434 <EP_IN_Transfer>
    }
}
    20b0:	46c0      	nop			; (mov r8, r8)
    20b2:	46bd      	mov	sp, r7
    20b4:	bd80      	pop	{r7, pc}
    20b6:	46c0      	nop			; (mov r8, r8)
    20b8:	1ffff778 	.word	0x1ffff778
    20bc:	1ffff804 	.word	0x1ffff804
    20c0:	1ffff8c8 	.word	0x1ffff8c8
    20c4:	1ffff5d6 	.word	0x1ffff5d6
    20c8:	1ffff4be 	.word	0x1ffff4be
    20cc:	00004808 	.word	0x00004808
    20d0:	1ffff4e4 	.word	0x1ffff4e4

000020d4 <accel_init>:
/******************************************************************************/
void accel_init(void)
{
    20d4:	b590      	push	{r4, r7, lr}
    20d6:	b083      	sub	sp, #12
    20d8:	af00      	add	r7, sp, #0
    unsigned char tmp;
    //printf("****Accelerometor init ****\n");
    //Configure MMA8451 sensor //MMA8451Q
    hal_dev_mma8451_init();      //Initialize I2C modules
    20da:	f000 fa5d 	bl	2598 <hal_dev_mma8451_init>
    tmp = hal_dev_mma8451_read_reg(0x2a);
    20de:	1dfc      	adds	r4, r7, #7
    20e0:	202a      	movs	r0, #42	; 0x2a
    20e2:	f000 fa77 	bl	25d4 <hal_dev_mma8451_read_reg>
    20e6:	0003      	movs	r3, r0
    20e8:	7023      	strb	r3, [r4, #0]
    hal_dev_mma8451_write_reg(0x2a,tmp|0x01);
    20ea:	1dfb      	adds	r3, r7, #7
    20ec:	781b      	ldrb	r3, [r3, #0]
    20ee:	2201      	movs	r2, #1
    20f0:	4313      	orrs	r3, r2
    20f2:	b2db      	uxtb	r3, r3
    20f4:	0019      	movs	r1, r3
    20f6:	202a      	movs	r0, #42	; 0x2a
    20f8:	f000 face 	bl	2698 <hal_dev_mma8451_write_reg>
}
    20fc:	46c0      	nop			; (mov r8, r8)
    20fe:	46bd      	mov	sp, r7
    2100:	b003      	add	sp, #12
    2102:	bd90      	pop	{r4, r7, pc}

00002104 <accel_read>:
/******************************************************************************/
void accel_read(void)
{
    2104:	b580      	push	{r7, lr}
    2106:	af00      	add	r7, sp, #0
    if((hal_dev_mma8451_read_reg(0x00)&0xf) != 0)
    2108:	2000      	movs	r0, #0
    210a:	f000 fa63 	bl	25d4 <hal_dev_mma8451_read_reg>
    210e:	0003      	movs	r3, r0
    2110:	001a      	movs	r2, r3
    2112:	230f      	movs	r3, #15
    2114:	4013      	ands	r3, r2
    2116:	d100      	bne.n	211a <accel_read+0x16>
    2118:	e0a5      	b.n	2266 <accel_read+0x162>
    {
        accel_x   = hal_dev_mma8451_read_reg(0x01)<<8;
    211a:	2001      	movs	r0, #1
    211c:	f000 fa5a 	bl	25d4 <hal_dev_mma8451_read_reg>
    2120:	0003      	movs	r3, r0
    2122:	021b      	lsls	r3, r3, #8
    2124:	b21a      	sxth	r2, r3
    2126:	4b51      	ldr	r3, [pc, #324]	; (226c <accel_read+0x168>)
    2128:	801a      	strh	r2, [r3, #0]
        accel_x  |= hal_dev_mma8451_read_reg(0x02);
    212a:	2002      	movs	r0, #2
    212c:	f000 fa52 	bl	25d4 <hal_dev_mma8451_read_reg>
    2130:	0003      	movs	r3, r0
    2132:	b21a      	sxth	r2, r3
    2134:	4b4d      	ldr	r3, [pc, #308]	; (226c <accel_read+0x168>)
    2136:	2100      	movs	r1, #0
    2138:	5e5b      	ldrsh	r3, [r3, r1]
    213a:	4313      	orrs	r3, r2
    213c:	b21a      	sxth	r2, r3
    213e:	4b4b      	ldr	r3, [pc, #300]	; (226c <accel_read+0x168>)
    2140:	801a      	strh	r2, [r3, #0]
        accel_x >>= 2;
    2142:	4b4a      	ldr	r3, [pc, #296]	; (226c <accel_read+0x168>)
    2144:	2200      	movs	r2, #0
    2146:	5e9b      	ldrsh	r3, [r3, r2]
    2148:	109b      	asrs	r3, r3, #2
    214a:	b21a      	sxth	r2, r3
    214c:	4b47      	ldr	r3, [pc, #284]	; (226c <accel_read+0x168>)
    214e:	801a      	strh	r2, [r3, #0]

        accel_y   = hal_dev_mma8451_read_reg(0x03)<<8;
    2150:	2003      	movs	r0, #3
    2152:	f000 fa3f 	bl	25d4 <hal_dev_mma8451_read_reg>
    2156:	0003      	movs	r3, r0
    2158:	021b      	lsls	r3, r3, #8
    215a:	b21a      	sxth	r2, r3
    215c:	4b44      	ldr	r3, [pc, #272]	; (2270 <accel_read+0x16c>)
    215e:	801a      	strh	r2, [r3, #0]
        accel_y  |= hal_dev_mma8451_read_reg(0x04);
    2160:	2004      	movs	r0, #4
    2162:	f000 fa37 	bl	25d4 <hal_dev_mma8451_read_reg>
    2166:	0003      	movs	r3, r0
    2168:	b21a      	sxth	r2, r3
    216a:	4b41      	ldr	r3, [pc, #260]	; (2270 <accel_read+0x16c>)
    216c:	2100      	movs	r1, #0
    216e:	5e5b      	ldrsh	r3, [r3, r1]
    2170:	4313      	orrs	r3, r2
    2172:	b21a      	sxth	r2, r3
    2174:	4b3e      	ldr	r3, [pc, #248]	; (2270 <accel_read+0x16c>)
    2176:	801a      	strh	r2, [r3, #0]
        accel_y >>= 2;
    2178:	4b3d      	ldr	r3, [pc, #244]	; (2270 <accel_read+0x16c>)
    217a:	2200      	movs	r2, #0
    217c:	5e9b      	ldrsh	r3, [r3, r2]
    217e:	109b      	asrs	r3, r3, #2
    2180:	b21a      	sxth	r2, r3
    2182:	4b3b      	ldr	r3, [pc, #236]	; (2270 <accel_read+0x16c>)
    2184:	801a      	strh	r2, [r3, #0]

        accel_z   = hal_dev_mma8451_read_reg(0x05)<<8;
    2186:	2005      	movs	r0, #5
    2188:	f000 fa24 	bl	25d4 <hal_dev_mma8451_read_reg>
    218c:	0003      	movs	r3, r0
    218e:	021b      	lsls	r3, r3, #8
    2190:	b21a      	sxth	r2, r3
    2192:	4b38      	ldr	r3, [pc, #224]	; (2274 <accel_read+0x170>)
    2194:	801a      	strh	r2, [r3, #0]
        accel_z  |= hal_dev_mma8451_read_reg(0x06);
    2196:	2006      	movs	r0, #6
    2198:	f000 fa1c 	bl	25d4 <hal_dev_mma8451_read_reg>
    219c:	0003      	movs	r3, r0
    219e:	b21a      	sxth	r2, r3
    21a0:	4b34      	ldr	r3, [pc, #208]	; (2274 <accel_read+0x170>)
    21a2:	2100      	movs	r1, #0
    21a4:	5e5b      	ldrsh	r3, [r3, r1]
    21a6:	4313      	orrs	r3, r2
    21a8:	b21a      	sxth	r2, r3
    21aa:	4b32      	ldr	r3, [pc, #200]	; (2274 <accel_read+0x170>)
    21ac:	801a      	strh	r2, [r3, #0]
        accel_z >>= 2;
    21ae:	4b31      	ldr	r3, [pc, #196]	; (2274 <accel_read+0x170>)
    21b0:	2200      	movs	r2, #0
    21b2:	5e9b      	ldrsh	r3, [r3, r2]
    21b4:	109b      	asrs	r3, r3, #2
    21b6:	b21a      	sxth	r2, r3
    21b8:	4b2e      	ldr	r3, [pc, #184]	; (2274 <accel_read+0x170>)
    21ba:	801a      	strh	r2, [r3, #0]

        resultx   = hal_dev_mma8451_read_reg(0x01)<<8;
    21bc:	2001      	movs	r0, #1
    21be:	f000 fa09 	bl	25d4 <hal_dev_mma8451_read_reg>
    21c2:	0003      	movs	r3, r0
    21c4:	021b      	lsls	r3, r3, #8
    21c6:	b21a      	sxth	r2, r3
    21c8:	4b2b      	ldr	r3, [pc, #172]	; (2278 <accel_read+0x174>)
    21ca:	801a      	strh	r2, [r3, #0]
        resultx  |= hal_dev_mma8451_read_reg(0x02);
    21cc:	2002      	movs	r0, #2
    21ce:	f000 fa01 	bl	25d4 <hal_dev_mma8451_read_reg>
    21d2:	0003      	movs	r3, r0
    21d4:	b21a      	sxth	r2, r3
    21d6:	4b28      	ldr	r3, [pc, #160]	; (2278 <accel_read+0x174>)
    21d8:	2100      	movs	r1, #0
    21da:	5e5b      	ldrsh	r3, [r3, r1]
    21dc:	4313      	orrs	r3, r2
    21de:	b21a      	sxth	r2, r3
    21e0:	4b25      	ldr	r3, [pc, #148]	; (2278 <accel_read+0x174>)
    21e2:	801a      	strh	r2, [r3, #0]
        resultx >>= 8;
    21e4:	4b24      	ldr	r3, [pc, #144]	; (2278 <accel_read+0x174>)
    21e6:	2200      	movs	r2, #0
    21e8:	5e9b      	ldrsh	r3, [r3, r2]
    21ea:	121b      	asrs	r3, r3, #8
    21ec:	b21a      	sxth	r2, r3
    21ee:	4b22      	ldr	r3, [pc, #136]	; (2278 <accel_read+0x174>)
    21f0:	801a      	strh	r2, [r3, #0]

        resulty   = hal_dev_mma8451_read_reg(0x03)<<8;
    21f2:	2003      	movs	r0, #3
    21f4:	f000 f9ee 	bl	25d4 <hal_dev_mma8451_read_reg>
    21f8:	0003      	movs	r3, r0
    21fa:	021b      	lsls	r3, r3, #8
    21fc:	b21a      	sxth	r2, r3
    21fe:	4b1f      	ldr	r3, [pc, #124]	; (227c <accel_read+0x178>)
    2200:	801a      	strh	r2, [r3, #0]
        resulty  |= hal_dev_mma8451_read_reg(0x04);
    2202:	2004      	movs	r0, #4
    2204:	f000 f9e6 	bl	25d4 <hal_dev_mma8451_read_reg>
    2208:	0003      	movs	r3, r0
    220a:	b21a      	sxth	r2, r3
    220c:	4b1b      	ldr	r3, [pc, #108]	; (227c <accel_read+0x178>)
    220e:	2100      	movs	r1, #0
    2210:	5e5b      	ldrsh	r3, [r3, r1]
    2212:	4313      	orrs	r3, r2
    2214:	b21a      	sxth	r2, r3
    2216:	4b19      	ldr	r3, [pc, #100]	; (227c <accel_read+0x178>)
    2218:	801a      	strh	r2, [r3, #0]
        resulty >>= 8;
    221a:	4b18      	ldr	r3, [pc, #96]	; (227c <accel_read+0x178>)
    221c:	2200      	movs	r2, #0
    221e:	5e9b      	ldrsh	r3, [r3, r2]
    2220:	121b      	asrs	r3, r3, #8
    2222:	b21a      	sxth	r2, r3
    2224:	4b15      	ldr	r3, [pc, #84]	; (227c <accel_read+0x178>)
    2226:	801a      	strh	r2, [r3, #0]

        resultz   = hal_dev_mma8451_read_reg(0x05)<<8;
    2228:	2005      	movs	r0, #5
    222a:	f000 f9d3 	bl	25d4 <hal_dev_mma8451_read_reg>
    222e:	0003      	movs	r3, r0
    2230:	021b      	lsls	r3, r3, #8
    2232:	b21a      	sxth	r2, r3
    2234:	4b12      	ldr	r3, [pc, #72]	; (2280 <accel_read+0x17c>)
    2236:	801a      	strh	r2, [r3, #0]
        resultz  |= hal_dev_mma8451_read_reg(0x06);
    2238:	2006      	movs	r0, #6
    223a:	f000 f9cb 	bl	25d4 <hal_dev_mma8451_read_reg>
    223e:	0003      	movs	r3, r0
    2240:	b21a      	sxth	r2, r3
    2242:	4b0f      	ldr	r3, [pc, #60]	; (2280 <accel_read+0x17c>)
    2244:	2100      	movs	r1, #0
    2246:	5e5b      	ldrsh	r3, [r3, r1]
    2248:	4313      	orrs	r3, r2
    224a:	b21a      	sxth	r2, r3
    224c:	4b0c      	ldr	r3, [pc, #48]	; (2280 <accel_read+0x17c>)
    224e:	801a      	strh	r2, [r3, #0]
        resultz >>= 8;
    2250:	4b0b      	ldr	r3, [pc, #44]	; (2280 <accel_read+0x17c>)
    2252:	2200      	movs	r2, #0
    2254:	5e9b      	ldrsh	r3, [r3, r2]
    2256:	121b      	asrs	r3, r3, #8
    2258:	b21a      	sxth	r2, r3
    225a:	4b09      	ldr	r3, [pc, #36]	; (2280 <accel_read+0x17c>)
    225c:	801a      	strh	r2, [r3, #0]

        angle_calculation(); //-900  to  900
    225e:	f000 fb47 	bl	28f0 <angle_calculation>
        detect_fall_detection();
    2262:	f000 fc63 	bl	2b2c <detect_fall_detection>
    }
}
    2266:	46c0      	nop			; (mov r8, r8)
    2268:	46bd      	mov	sp, r7
    226a:	bd80      	pop	{r7, pc}
    226c:	1ffff4dc 	.word	0x1ffff4dc
    2270:	1ffff4de 	.word	0x1ffff4de
    2274:	1ffff524 	.word	0x1ffff524
    2278:	1ffff4e2 	.word	0x1ffff4e2
    227c:	1ffff526 	.word	0x1ffff526
    2280:	1ffff4e0 	.word	0x1ffff4e0

00002284 <accel_demo>:
/******************************************************************************/
void accel_demo(void)
{
    2284:	b580      	push	{r7, lr}
    2286:	af00      	add	r7, sp, #0
    if (ti_accel_sampling==0)
    2288:	4b34      	ldr	r3, [pc, #208]	; (235c <accel_demo+0xd8>)
    228a:	881b      	ldrh	r3, [r3, #0]
    228c:	2b00      	cmp	r3, #0
    228e:	d104      	bne.n	229a <accel_demo+0x16>
    {
        accel_read();
    2290:	f7ff ff38 	bl	2104 <accel_read>
        ti_accel_sampling = 10;
    2294:	4b31      	ldr	r3, [pc, #196]	; (235c <accel_demo+0xd8>)
    2296:	220a      	movs	r2, #10
    2298:	801a      	strh	r2, [r3, #0]
    }

    if (xy_mag > 20)
    229a:	4b31      	ldr	r3, [pc, #196]	; (2360 <accel_demo+0xdc>)
    229c:	681b      	ldr	r3, [r3, #0]
    229e:	2b14      	cmp	r3, #20
    22a0:	d93e      	bls.n	2320 <accel_demo+0x9c>
    {
        SET_LED_RED((abs(xz_angle) > 450) ? 0 : (450 - abs(xz_angle)));
    22a2:	4a30      	ldr	r2, [pc, #192]	; (2364 <accel_demo+0xe0>)
    22a4:	4b30      	ldr	r3, [pc, #192]	; (2368 <accel_demo+0xe4>)
    22a6:	681b      	ldr	r3, [r3, #0]
    22a8:	17d8      	asrs	r0, r3, #31
    22aa:	1819      	adds	r1, r3, r0
    22ac:	4041      	eors	r1, r0
    22ae:	23e1      	movs	r3, #225	; 0xe1
    22b0:	005b      	lsls	r3, r3, #1
    22b2:	4299      	cmp	r1, r3
    22b4:	dc08      	bgt.n	22c8 <accel_demo+0x44>
    22b6:	4b2c      	ldr	r3, [pc, #176]	; (2368 <accel_demo+0xe4>)
    22b8:	681b      	ldr	r3, [r3, #0]
    22ba:	17d9      	asrs	r1, r3, #31
    22bc:	185b      	adds	r3, r3, r1
    22be:	404b      	eors	r3, r1
    22c0:	21e1      	movs	r1, #225	; 0xe1
    22c2:	0049      	lsls	r1, r1, #1
    22c4:	1acb      	subs	r3, r1, r3
    22c6:	e000      	b.n	22ca <accel_demo+0x46>
    22c8:	2300      	movs	r3, #0
    22ca:	6113      	str	r3, [r2, #16]
        SET_LED_GREEN((abs(yz_angle) > 450) ? 0 : (450 - abs(yz_angle)));
    22cc:	4a25      	ldr	r2, [pc, #148]	; (2364 <accel_demo+0xe0>)
    22ce:	4b27      	ldr	r3, [pc, #156]	; (236c <accel_demo+0xe8>)
    22d0:	681b      	ldr	r3, [r3, #0]
    22d2:	17d8      	asrs	r0, r3, #31
    22d4:	1819      	adds	r1, r3, r0
    22d6:	4041      	eors	r1, r0
    22d8:	23e1      	movs	r3, #225	; 0xe1
    22da:	005b      	lsls	r3, r3, #1
    22dc:	4299      	cmp	r1, r3
    22de:	dc08      	bgt.n	22f2 <accel_demo+0x6e>
    22e0:	4b22      	ldr	r3, [pc, #136]	; (236c <accel_demo+0xe8>)
    22e2:	681b      	ldr	r3, [r3, #0]
    22e4:	17d9      	asrs	r1, r3, #31
    22e6:	185b      	adds	r3, r3, r1
    22e8:	404b      	eors	r3, r1
    22ea:	21e1      	movs	r1, #225	; 0xe1
    22ec:	0049      	lsls	r1, r1, #1
    22ee:	1acb      	subs	r3, r1, r3
    22f0:	e000      	b.n	22f4 <accel_demo+0x70>
    22f2:	2300      	movs	r3, #0
    22f4:	6193      	str	r3, [r2, #24]
        SET_LED_BLUE((abs(xy_angle) > 450) ? 0 : (450 - abs(xy_angle)));
    22f6:	4a1e      	ldr	r2, [pc, #120]	; (2370 <accel_demo+0xec>)
    22f8:	4b1e      	ldr	r3, [pc, #120]	; (2374 <accel_demo+0xf0>)
    22fa:	681b      	ldr	r3, [r3, #0]
    22fc:	17d8      	asrs	r0, r3, #31
    22fe:	1819      	adds	r1, r3, r0
    2300:	4041      	eors	r1, r0
    2302:	23e1      	movs	r3, #225	; 0xe1
    2304:	005b      	lsls	r3, r3, #1
    2306:	4299      	cmp	r1, r3
    2308:	dc08      	bgt.n	231c <accel_demo+0x98>
    230a:	4b1a      	ldr	r3, [pc, #104]	; (2374 <accel_demo+0xf0>)
    230c:	681b      	ldr	r3, [r3, #0]
    230e:	17d9      	asrs	r1, r3, #31
    2310:	185b      	adds	r3, r3, r1
    2312:	404b      	eors	r3, r1
    2314:	21e1      	movs	r1, #225	; 0xe1
    2316:	0049      	lsls	r1, r1, #1
    2318:	1acb      	subs	r3, r1, r3
    231a:	e000      	b.n	231e <accel_demo+0x9a>
    231c:	2300      	movs	r3, #0
    231e:	6193      	str	r3, [r2, #24]
    }
    if (xy_mag < 20 &&  AbsolutePercentegePosition > 0 )
    2320:	4b0f      	ldr	r3, [pc, #60]	; (2360 <accel_demo+0xdc>)
    2322:	681b      	ldr	r3, [r3, #0]
    2324:	2b13      	cmp	r3, #19
    2326:	d815      	bhi.n	2354 <accel_demo+0xd0>
    2328:	4b13      	ldr	r3, [pc, #76]	; (2378 <accel_demo+0xf4>)
    232a:	781b      	ldrb	r3, [r3, #0]
    232c:	2b00      	cmp	r3, #0
    232e:	d011      	beq.n	2354 <accel_demo+0xd0>
    {
        SET_LED_BLUE(AbsolutePercentegePosition*8);
    2330:	4b0f      	ldr	r3, [pc, #60]	; (2370 <accel_demo+0xec>)
    2332:	4a11      	ldr	r2, [pc, #68]	; (2378 <accel_demo+0xf4>)
    2334:	7812      	ldrb	r2, [r2, #0]
    2336:	00d2      	lsls	r2, r2, #3
    2338:	619a      	str	r2, [r3, #24]
        SET_LED_RED(AbsolutePercentegePosition*7);
    233a:	4a0a      	ldr	r2, [pc, #40]	; (2364 <accel_demo+0xe0>)
    233c:	4b0e      	ldr	r3, [pc, #56]	; (2378 <accel_demo+0xf4>)
    233e:	781b      	ldrb	r3, [r3, #0]
    2340:	0019      	movs	r1, r3
    2342:	000b      	movs	r3, r1
    2344:	00db      	lsls	r3, r3, #3
    2346:	1a5b      	subs	r3, r3, r1
    2348:	6113      	str	r3, [r2, #16]
        SET_LED_GREEN(AbsolutePercentegePosition*8);
    234a:	4b06      	ldr	r3, [pc, #24]	; (2364 <accel_demo+0xe0>)
    234c:	4a0a      	ldr	r2, [pc, #40]	; (2378 <accel_demo+0xf4>)
    234e:	7812      	ldrb	r2, [r2, #0]
    2350:	00d2      	lsls	r2, r2, #3
    2352:	619a      	str	r2, [r3, #24]
//    if (!ti_print)
//    {
//        ti_print = 300;
//        printf("\rxy = %03d, yz = %03d, xz = %03d", xy_angle, yz_angle, xz_angle);
//    }
}
    2354:	46c0      	nop			; (mov r8, r8)
    2356:	46bd      	mov	sp, r7
    2358:	bd80      	pop	{r7, pc}
    235a:	46c0      	nop			; (mov r8, r8)
    235c:	1ffff5e0 	.word	0x1ffff5e0
    2360:	1ffff5ac 	.word	0x1ffff5ac
    2364:	4003a000 	.word	0x4003a000
    2368:	1ffff5c4 	.word	0x1ffff5c4
    236c:	1ffff5b8 	.word	0x1ffff5b8
    2370:	40038000 	.word	0x40038000
    2374:	1ffff534 	.word	0x1ffff534
    2378:	1ffff4be 	.word	0x1ffff4be

0000237c <TPM_init>:
 * \author   b01252
 * \param    none
 * \return   none
 */
void TPM_init(void)
{
    237c:	b580      	push	{r7, lr}
    237e:	af00      	add	r7, sp, #0
    SIM_SCGC5 |= SIM_SCGC5_PORTB_MASK | SIM_SCGC5_PORTD_MASK;
    2380:	4924      	ldr	r1, [pc, #144]	; (2414 <TPM_init+0x98>)
    2382:	4a24      	ldr	r2, [pc, #144]	; (2414 <TPM_init+0x98>)
    2384:	4b24      	ldr	r3, [pc, #144]	; (2418 <TPM_init+0x9c>)
    2386:	58d3      	ldr	r3, [r2, r3]
    2388:	22a0      	movs	r2, #160	; 0xa0
    238a:	0152      	lsls	r2, r2, #5
    238c:	4313      	orrs	r3, r2
    238e:	4a22      	ldr	r2, [pc, #136]	; (2418 <TPM_init+0x9c>)
    2390:	508b      	str	r3, [r1, r2]
    SIM_SCGC6|=( SIM_SCGC6_TPM0_MASK | SIM_SCGC6_TPM2_MASK);
    2392:	4920      	ldr	r1, [pc, #128]	; (2414 <TPM_init+0x98>)
    2394:	4a1f      	ldr	r2, [pc, #124]	; (2414 <TPM_init+0x98>)
    2396:	4b21      	ldr	r3, [pc, #132]	; (241c <TPM_init+0xa0>)
    2398:	58d3      	ldr	r3, [r2, r3]
    239a:	22a0      	movs	r2, #160	; 0xa0
    239c:	04d2      	lsls	r2, r2, #19
    239e:	4313      	orrs	r3, r2
    23a0:	4a1e      	ldr	r2, [pc, #120]	; (241c <TPM_init+0xa0>)
    23a2:	508b      	str	r3, [r1, r2]
    SIM_SOPT2 |= SIM_SOPT2_TPMSRC(1); //
    23a4:	491b      	ldr	r1, [pc, #108]	; (2414 <TPM_init+0x98>)
    23a6:	4a1b      	ldr	r2, [pc, #108]	; (2414 <TPM_init+0x98>)
    23a8:	4b1d      	ldr	r3, [pc, #116]	; (2420 <TPM_init+0xa4>)
    23aa:	58d3      	ldr	r3, [r2, r3]
    23ac:	2280      	movs	r2, #128	; 0x80
    23ae:	0452      	lsls	r2, r2, #17
    23b0:	4313      	orrs	r3, r2
    23b2:	4a1b      	ldr	r2, [pc, #108]	; (2420 <TPM_init+0xa4>)
    23b4:	508b      	str	r3, [r1, r2]

    PORTB_PCR18 = (0|PORT_PCR_MUX(3)); /* TPM2_CH0 enable on PTB18 */
    23b6:	4b1b      	ldr	r3, [pc, #108]	; (2424 <TPM_init+0xa8>)
    23b8:	22c0      	movs	r2, #192	; 0xc0
    23ba:	0092      	lsls	r2, r2, #2
    23bc:	649a      	str	r2, [r3, #72]	; 0x48
    PORTB_PCR19 = (0|PORT_PCR_MUX(3)); /* TPM2_CH1 enable on PTB19 */
    23be:	4b19      	ldr	r3, [pc, #100]	; (2424 <TPM_init+0xa8>)
    23c0:	22c0      	movs	r2, #192	; 0xc0
    23c2:	0092      	lsls	r2, r2, #2
    23c4:	64da      	str	r2, [r3, #76]	; 0x4c
    PORTD_PCR1  = (0|PORT_PCR_MUX(4)); /* TPM0_CH1 enable on PTD1 */
    23c6:	4b18      	ldr	r3, [pc, #96]	; (2428 <TPM_init+0xac>)
    23c8:	2280      	movs	r2, #128	; 0x80
    23ca:	00d2      	lsls	r2, r2, #3
    23cc:	605a      	str	r2, [r3, #4]

    TPM0_MOD  = TPM_MODULE;  /* 0x0063 / 25MHz = 4uS PWM period */
    23ce:	4b17      	ldr	r3, [pc, #92]	; (242c <TPM_init+0xb0>)
    23d0:	22fa      	movs	r2, #250	; 0xfa
    23d2:	0092      	lsls	r2, r2, #2
    23d4:	609a      	str	r2, [r3, #8]
    TPM0_C1SC = TPM_Cn_MODE;   /* No Interrupts; High True pulses on Edge Aligned PWM */
    23d6:	4b15      	ldr	r3, [pc, #84]	; (242c <TPM_init+0xb0>)
    23d8:	2224      	movs	r2, #36	; 0x24
    23da:	615a      	str	r2, [r3, #20]
    TPM0_C1V  = TPM_INIT_VAL;  /* 90% pulse width */
    23dc:	4b13      	ldr	r3, [pc, #76]	; (242c <TPM_init+0xb0>)
    23de:	2219      	movs	r2, #25
    23e0:	619a      	str	r2, [r3, #24]

    TPM2_MOD  = TPM_MODULE;  /* 0x0063 / 25MHz = 4uS PWM period */
    23e2:	4b13      	ldr	r3, [pc, #76]	; (2430 <TPM_init+0xb4>)
    23e4:	22fa      	movs	r2, #250	; 0xfa
    23e6:	0092      	lsls	r2, r2, #2
    23e8:	609a      	str	r2, [r3, #8]
    TPM2_C0SC = TPM_Cn_MODE;   /* No Interrupts; Low True pulses on Edge Aligned PWM */
    23ea:	4b11      	ldr	r3, [pc, #68]	; (2430 <TPM_init+0xb4>)
    23ec:	2224      	movs	r2, #36	; 0x24
    23ee:	60da      	str	r2, [r3, #12]
    TPM2_C0V  = TPM_INIT_VAL;  /* 90% pulse width */
    23f0:	4b0f      	ldr	r3, [pc, #60]	; (2430 <TPM_init+0xb4>)
    23f2:	2219      	movs	r2, #25
    23f4:	611a      	str	r2, [r3, #16]
    TPM2_C1SC = TPM_Cn_MODE;   /* No Interrupts; Low True pulses on Edge Aligned PWM */
    23f6:	4b0e      	ldr	r3, [pc, #56]	; (2430 <TPM_init+0xb4>)
    23f8:	2224      	movs	r2, #36	; 0x24
    23fa:	615a      	str	r2, [r3, #20]
    TPM2_C1V  = TPM_INIT_VAL;  /* 90% pulse width */
    23fc:	4b0c      	ldr	r3, [pc, #48]	; (2430 <TPM_init+0xb4>)
    23fe:	2219      	movs	r2, #25
    2400:	619a      	str	r2, [r3, #24]

    TPM2_SC   = TPM_SC_CMOD(1) | TPM_SC_PS(0);     /* Edge Aligned PWM running from BUSCLK / 1 */
    2402:	4b0b      	ldr	r3, [pc, #44]	; (2430 <TPM_init+0xb4>)
    2404:	2208      	movs	r2, #8
    2406:	601a      	str	r2, [r3, #0]
    TPM0_SC   = TPM_SC_CMOD(1) | TPM_SC_PS(0);     /* Edge Aligned PWM running from BUSCLK / 1 */
    2408:	4b08      	ldr	r3, [pc, #32]	; (242c <TPM_init+0xb0>)
    240a:	2208      	movs	r2, #8
    240c:	601a      	str	r2, [r3, #0]
}
    240e:	46c0      	nop			; (mov r8, r8)
    2410:	46bd      	mov	sp, r7
    2412:	bd80      	pop	{r7, pc}
    2414:	40047000 	.word	0x40047000
    2418:	00001038 	.word	0x00001038
    241c:	0000103c 	.word	0x0000103c
    2420:	00001004 	.word	0x00001004
    2424:	4004a000 	.word	0x4004a000
    2428:	4004c000 	.word	0x4004c000
    242c:	40038000 	.word	0x40038000
    2430:	4003a000 	.word	0x4003a000

00002434 <vfn_rgb_test>:
 * \brief
 * \param    none
 * \return   none
 */
void vfn_rgb_test(void)
{
    2434:	b580      	push	{r7, lr}
    2436:	af00      	add	r7, sp, #0
    static char seq_count=0;

    if (!ti_task)
    2438:	4b37      	ldr	r3, [pc, #220]	; (2518 <vfn_rgb_test+0xe4>)
    243a:	881b      	ldrh	r3, [r3, #0]
    243c:	2b00      	cmp	r3, #0
    243e:	d168      	bne.n	2512 <vfn_rgb_test+0xde>
    {
        seq_count++;
    2440:	4b36      	ldr	r3, [pc, #216]	; (251c <vfn_rgb_test+0xe8>)
    2442:	781b      	ldrb	r3, [r3, #0]
    2444:	3301      	adds	r3, #1
    2446:	b2da      	uxtb	r2, r3
    2448:	4b34      	ldr	r3, [pc, #208]	; (251c <vfn_rgb_test+0xe8>)
    244a:	701a      	strb	r2, [r3, #0]
        ti_task = 500;
    244c:	4b32      	ldr	r3, [pc, #200]	; (2518 <vfn_rgb_test+0xe4>)
    244e:	22fa      	movs	r2, #250	; 0xfa
    2450:	0052      	lsls	r2, r2, #1
    2452:	801a      	strh	r2, [r3, #0]
        switch (seq_count)
    2454:	4b31      	ldr	r3, [pc, #196]	; (251c <vfn_rgb_test+0xe8>)
    2456:	781b      	ldrb	r3, [r3, #0]
    2458:	2b07      	cmp	r3, #7
    245a:	d853      	bhi.n	2504 <vfn_rgb_test+0xd0>
    245c:	009a      	lsls	r2, r3, #2
    245e:	4b30      	ldr	r3, [pc, #192]	; (2520 <vfn_rgb_test+0xec>)
    2460:	18d3      	adds	r3, r2, r3
    2462:	681b      	ldr	r3, [r3, #0]
    2464:	469f      	mov	pc, r3
        {
            case 1:
                SET_LED_RED(300);
    2466:	4b2f      	ldr	r3, [pc, #188]	; (2524 <vfn_rgb_test+0xf0>)
    2468:	2296      	movs	r2, #150	; 0x96
    246a:	0052      	lsls	r2, r2, #1
    246c:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(0);
    246e:	4b2d      	ldr	r3, [pc, #180]	; (2524 <vfn_rgb_test+0xf0>)
    2470:	2200      	movs	r2, #0
    2472:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(0);
    2474:	4b2c      	ldr	r3, [pc, #176]	; (2528 <vfn_rgb_test+0xf4>)
    2476:	2200      	movs	r2, #0
    2478:	619a      	str	r2, [r3, #24]
                break;
    247a:	e04a      	b.n	2512 <vfn_rgb_test+0xde>
            case 2:
                SET_LED_RED(0);
    247c:	4b29      	ldr	r3, [pc, #164]	; (2524 <vfn_rgb_test+0xf0>)
    247e:	2200      	movs	r2, #0
    2480:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(300);
    2482:	4b28      	ldr	r3, [pc, #160]	; (2524 <vfn_rgb_test+0xf0>)
    2484:	2296      	movs	r2, #150	; 0x96
    2486:	0052      	lsls	r2, r2, #1
    2488:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(0);
    248a:	4b27      	ldr	r3, [pc, #156]	; (2528 <vfn_rgb_test+0xf4>)
    248c:	2200      	movs	r2, #0
    248e:	619a      	str	r2, [r3, #24]
                break;
    2490:	e03f      	b.n	2512 <vfn_rgb_test+0xde>
            case 3:
                SET_LED_RED(0);
    2492:	4b24      	ldr	r3, [pc, #144]	; (2524 <vfn_rgb_test+0xf0>)
    2494:	2200      	movs	r2, #0
    2496:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(0);
    2498:	4b22      	ldr	r3, [pc, #136]	; (2524 <vfn_rgb_test+0xf0>)
    249a:	2200      	movs	r2, #0
    249c:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(300);
    249e:	4b22      	ldr	r3, [pc, #136]	; (2528 <vfn_rgb_test+0xf4>)
    24a0:	2296      	movs	r2, #150	; 0x96
    24a2:	0052      	lsls	r2, r2, #1
    24a4:	619a      	str	r2, [r3, #24]
                break;
    24a6:	e034      	b.n	2512 <vfn_rgb_test+0xde>
            case 4:
                SET_LED_RED(300);
    24a8:	4b1e      	ldr	r3, [pc, #120]	; (2524 <vfn_rgb_test+0xf0>)
    24aa:	2296      	movs	r2, #150	; 0x96
    24ac:	0052      	lsls	r2, r2, #1
    24ae:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(300);
    24b0:	4b1c      	ldr	r3, [pc, #112]	; (2524 <vfn_rgb_test+0xf0>)
    24b2:	2296      	movs	r2, #150	; 0x96
    24b4:	0052      	lsls	r2, r2, #1
    24b6:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(0);
    24b8:	4b1b      	ldr	r3, [pc, #108]	; (2528 <vfn_rgb_test+0xf4>)
    24ba:	2200      	movs	r2, #0
    24bc:	619a      	str	r2, [r3, #24]
                break;
    24be:	e028      	b.n	2512 <vfn_rgb_test+0xde>
            case 5:
                SET_LED_RED(0);
    24c0:	4b18      	ldr	r3, [pc, #96]	; (2524 <vfn_rgb_test+0xf0>)
    24c2:	2200      	movs	r2, #0
    24c4:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(300);
    24c6:	4b17      	ldr	r3, [pc, #92]	; (2524 <vfn_rgb_test+0xf0>)
    24c8:	2296      	movs	r2, #150	; 0x96
    24ca:	0052      	lsls	r2, r2, #1
    24cc:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(300);
    24ce:	4b16      	ldr	r3, [pc, #88]	; (2528 <vfn_rgb_test+0xf4>)
    24d0:	2296      	movs	r2, #150	; 0x96
    24d2:	0052      	lsls	r2, r2, #1
    24d4:	619a      	str	r2, [r3, #24]
                break;
    24d6:	e01c      	b.n	2512 <vfn_rgb_test+0xde>
            case 6:
                SET_LED_RED(300);
    24d8:	4b12      	ldr	r3, [pc, #72]	; (2524 <vfn_rgb_test+0xf0>)
    24da:	2296      	movs	r2, #150	; 0x96
    24dc:	0052      	lsls	r2, r2, #1
    24de:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(0);
    24e0:	4b10      	ldr	r3, [pc, #64]	; (2524 <vfn_rgb_test+0xf0>)
    24e2:	2200      	movs	r2, #0
    24e4:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(300);
    24e6:	4b10      	ldr	r3, [pc, #64]	; (2528 <vfn_rgb_test+0xf4>)
    24e8:	2296      	movs	r2, #150	; 0x96
    24ea:	0052      	lsls	r2, r2, #1
    24ec:	619a      	str	r2, [r3, #24]
                break;
    24ee:	e010      	b.n	2512 <vfn_rgb_test+0xde>
            case 7:
                SET_LED_RED(200);
    24f0:	4b0c      	ldr	r3, [pc, #48]	; (2524 <vfn_rgb_test+0xf0>)
    24f2:	22c8      	movs	r2, #200	; 0xc8
    24f4:	611a      	str	r2, [r3, #16]
                SET_LED_GREEN(250);
    24f6:	4b0b      	ldr	r3, [pc, #44]	; (2524 <vfn_rgb_test+0xf0>)
    24f8:	22fa      	movs	r2, #250	; 0xfa
    24fa:	619a      	str	r2, [r3, #24]
                SET_LED_BLUE(250);
    24fc:	4b0a      	ldr	r3, [pc, #40]	; (2528 <vfn_rgb_test+0xf4>)
    24fe:	22fa      	movs	r2, #250	; 0xfa
    2500:	619a      	str	r2, [r3, #24]
                break;
    2502:	e006      	b.n	2512 <vfn_rgb_test+0xde>
            default:
                seq_count=0;
    2504:	4b05      	ldr	r3, [pc, #20]	; (251c <vfn_rgb_test+0xe8>)
    2506:	2200      	movs	r2, #0
    2508:	701a      	strb	r2, [r3, #0]
                next_task(accel_demo);
    250a:	4b08      	ldr	r3, [pc, #32]	; (252c <vfn_rgb_test+0xf8>)
    250c:	4a08      	ldr	r2, [pc, #32]	; (2530 <vfn_rgb_test+0xfc>)
    250e:	601a      	str	r2, [r3, #0]
        };
    }
}
    2510:	e7ff      	b.n	2512 <vfn_rgb_test+0xde>
    2512:	46c0      	nop			; (mov r8, r8)
    2514:	46bd      	mov	sp, r7
    2516:	bd80      	pop	{r7, pc}
    2518:	1ffff5dc 	.word	0x1ffff5dc
    251c:	1ffff4b4 	.word	0x1ffff4b4
    2520:	00004978 	.word	0x00004978
    2524:	4003a000 	.word	0x4003a000
    2528:	40038000 	.word	0x40038000
    252c:	1ffff5e4 	.word	0x1ffff5e4
    2530:	00002285 	.word	0x00002285

00002534 <main>:
 * \brief
 * \param    none
 * \return   none
 */
int main (void)
{
    2534:	b580      	push	{r7, lr}
    2536:	b082      	sub	sp, #8
    2538:	af00      	add	r7, sp, #0
    int i = 0;
    253a:	2300      	movs	r3, #0
    253c:	603b      	str	r3, [r7, #0]
    int UsbDetected = FALSE;
    253e:	2300      	movs	r3, #0
    2540:	607b      	str	r3, [r7, #4]
    gpio_init();
    2542:	f000 fc17 	bl	2d74 <gpio_init>
    Pit_init();
    2546:	f000 fc57 	bl	2df8 <Pit_init>
    TSI_Init();
    254a:	f000 fd7d 	bl	3048 <TSI_Init>
    TPM_init();
    254e:	f7ff ff15 	bl	237c <TPM_init>
    usb_init();
    2552:	f7ff fd4b 	bl	1fec <usb_init>

    next_task(vfn_rgb_test);
    2556:	4b0d      	ldr	r3, [pc, #52]	; (258c <main+0x58>)
    2558:	4a0d      	ldr	r2, [pc, #52]	; (2590 <main+0x5c>)
    255a:	601a      	str	r2, [r3, #0]
    accel_init();
    255c:	f7ff fdba 	bl	20d4 <accel_init>

    while(1)
    {
        CDC_Engine();
    2560:	f001 fc4a 	bl	3df8 <CDC_Engine>
        ptr_next_task();  // do the actual function
    2564:	4b09      	ldr	r3, [pc, #36]	; (258c <main+0x58>)
    2566:	681b      	ldr	r3, [r3, #0]
    2568:	4798      	blx	r3
        TSI_SliderRead();
    256a:	f000 fe03 	bl	3174 <TSI_SliderRead>
        usb_service();
    256e:	f7ff fd69 	bl	2044 <usb_service>
        if (gu8USB_State == uENUMERATED && !UsbDetected) {
    2572:	4b08      	ldr	r3, [pc, #32]	; (2594 <main+0x60>)
    2574:	781b      	ldrb	r3, [r3, #0]
    2576:	2b01      	cmp	r3, #1
    2578:	d1f2      	bne.n	2560 <main+0x2c>
    257a:	687b      	ldr	r3, [r7, #4]
    257c:	2b00      	cmp	r3, #0
    257e:	d1ef      	bne.n	2560 <main+0x2c>
            next_task(vfn_rgb_test);
    2580:	4b02      	ldr	r3, [pc, #8]	; (258c <main+0x58>)
    2582:	4a03      	ldr	r2, [pc, #12]	; (2590 <main+0x5c>)
    2584:	601a      	str	r2, [r3, #0]
            UsbDetected = TRUE;
    2586:	2301      	movs	r3, #1
    2588:	607b      	str	r3, [r7, #4]
        CDC_Engine();
    258a:	e7e9      	b.n	2560 <main+0x2c>
    258c:	1ffff5e4 	.word	0x1ffff5e4
    2590:	00002435 	.word	0x00002435
    2594:	1ffff7e0 	.word	0x1ffff7e0

00002598 <hal_dev_mma8451_init>:

#define MMA8451_I2C_ADDRESS (0x1d<<1)
#define I2C0_B  I2C0_BASE_PTR

void hal_dev_mma8451_init(void)
{
    2598:	b580      	push	{r7, lr}
    259a:	af00      	add	r7, sp, #0
  hal_i2c_init(I2C0_B);
    259c:	4b03      	ldr	r3, [pc, #12]	; (25ac <hal_dev_mma8451_init+0x14>)
    259e:	0018      	movs	r0, r3
    25a0:	f000 f982 	bl	28a8 <hal_i2c_init>
}
    25a4:	46c0      	nop			; (mov r8, r8)
    25a6:	46bd      	mov	sp, r7
    25a8:	bd80      	pop	{r7, pc}
    25aa:	46c0      	nop			; (mov r8, r8)
    25ac:	40066000 	.word	0x40066000

000025b0 <pause>:



// this delay is very important, it may cause w-r operation failure.
static void pause(void)
{
    25b0:	b580      	push	{r7, lr}
    25b2:	b082      	sub	sp, #8
    25b4:	af00      	add	r7, sp, #0
    int n;
    for(n=0; n<40; n++)
    25b6:	2300      	movs	r3, #0
    25b8:	607b      	str	r3, [r7, #4]
    25ba:	e003      	b.n	25c4 <pause+0x14>
        asm("nop");
    25bc:	46c0      	nop			; (mov r8, r8)
    for(n=0; n<40; n++)
    25be:	687b      	ldr	r3, [r7, #4]
    25c0:	3301      	adds	r3, #1
    25c2:	607b      	str	r3, [r7, #4]
    25c4:	687b      	ldr	r3, [r7, #4]
    25c6:	2b27      	cmp	r3, #39	; 0x27
    25c8:	ddf8      	ble.n	25bc <pause+0xc>
}
    25ca:	46c0      	nop			; (mov r8, r8)
    25cc:	46bd      	mov	sp, r7
    25ce:	b002      	add	sp, #8
    25d0:	bd80      	pop	{r7, pc}
	...

000025d4 <hal_dev_mma8451_read_reg>:
uint8 hal_dev_mma8451_read_reg(uint8 addr)
{
    25d4:	b590      	push	{r4, r7, lr}
    25d6:	b085      	sub	sp, #20
    25d8:	af00      	add	r7, sp, #0
    25da:	0002      	movs	r2, r0
    25dc:	1dfb      	adds	r3, r7, #7
    25de:	701a      	strb	r2, [r3, #0]
    uint8 result;

    i2c_start(I2C0_B);
    25e0:	4b2c      	ldr	r3, [pc, #176]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    25e2:	0018      	movs	r0, r3
    25e4:	f000 f916 	bl	2814 <i2c_start>
    i2c_write_byte(I2C0_B, MMA8451_I2C_ADDRESS | I2C_WRITE);
    25e8:	4b2a      	ldr	r3, [pc, #168]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    25ea:	213a      	movs	r1, #58	; 0x3a
    25ec:	0018      	movs	r0, r3
    25ee:	f000 f8f7 	bl	27e0 <i2c_write_byte>
    
    i2c_wait(I2C0_B);
    25f2:	4b28      	ldr	r3, [pc, #160]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    25f4:	0018      	movs	r0, r3
    25f6:	f000 f92d 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    25fa:	4b26      	ldr	r3, [pc, #152]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    25fc:	0018      	movs	r0, r3
    25fe:	f000 f941 	bl	2884 <i2c_get_ack>

    i2c_write_byte(I2C0_B, addr);
    2602:	1dfb      	adds	r3, r7, #7
    2604:	781b      	ldrb	r3, [r3, #0]
    2606:	4a23      	ldr	r2, [pc, #140]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2608:	0019      	movs	r1, r3
    260a:	0010      	movs	r0, r2
    260c:	f000 f8e8 	bl	27e0 <i2c_write_byte>
    i2c_wait(I2C0_B);
    2610:	4b20      	ldr	r3, [pc, #128]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2612:	0018      	movs	r0, r3
    2614:	f000 f91e 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    2618:	4b1e      	ldr	r3, [pc, #120]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    261a:	0018      	movs	r0, r3
    261c:	f000 f932 	bl	2884 <i2c_get_ack>

    i2c_repeated_start(I2C0_B);
    2620:	4b1c      	ldr	r3, [pc, #112]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2622:	0018      	movs	r0, r3
    2624:	f000 f8cc 	bl	27c0 <i2c_repeated_start>
    i2c_write_byte(I2C0_B, MMA8451_I2C_ADDRESS | I2C_READ);
    2628:	4b1a      	ldr	r3, [pc, #104]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    262a:	213b      	movs	r1, #59	; 0x3b
    262c:	0018      	movs	r0, r3
    262e:	f000 f8d7 	bl	27e0 <i2c_write_byte>
    i2c_wait(I2C0_B);
    2632:	4b18      	ldr	r3, [pc, #96]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2634:	0018      	movs	r0, r3
    2636:	f000 f90d 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    263a:	4b16      	ldr	r3, [pc, #88]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    263c:	0018      	movs	r0, r3
    263e:	f000 f921 	bl	2884 <i2c_get_ack>

    i2c_set_rx_mode(I2C0_B);
    2642:	4b14      	ldr	r3, [pc, #80]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2644:	0018      	movs	r0, r3
    2646:	f000 f87b 	bl	2740 <i2c_set_rx_mode>

    i2c_give_nack(I2C0_B);
    264a:	4b12      	ldr	r3, [pc, #72]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    264c:	0018      	movs	r0, r3
    264e:	f000 f8a7 	bl	27a0 <i2c_give_nack>
    result = i2c_read_byte(I2C0_B);
    2652:	230f      	movs	r3, #15
    2654:	18fc      	adds	r4, r7, r3
    2656:	4b0f      	ldr	r3, [pc, #60]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2658:	0018      	movs	r0, r3
    265a:	f000 f8d0 	bl	27fe <i2c_read_byte>
    265e:	0003      	movs	r3, r0
    2660:	7023      	strb	r3, [r4, #0]
    i2c_wait(I2C0_B);
    2662:	4b0c      	ldr	r3, [pc, #48]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2664:	0018      	movs	r0, r3
    2666:	f000 f8f5 	bl	2854 <i2c_wait>

    i2c_stop(I2C0_B);
    266a:	4b0a      	ldr	r3, [pc, #40]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    266c:	0018      	movs	r0, r3
    266e:	f000 f8e1 	bl	2834 <i2c_stop>
    result = i2c_read_byte(I2C0_B);
    2672:	230f      	movs	r3, #15
    2674:	18fc      	adds	r4, r7, r3
    2676:	4b07      	ldr	r3, [pc, #28]	; (2694 <hal_dev_mma8451_read_reg+0xc0>)
    2678:	0018      	movs	r0, r3
    267a:	f000 f8c0 	bl	27fe <i2c_read_byte>
    267e:	0003      	movs	r3, r0
    2680:	7023      	strb	r3, [r4, #0]
    pause();
    2682:	f7ff ff95 	bl	25b0 <pause>
    return result;
    2686:	230f      	movs	r3, #15
    2688:	18fb      	adds	r3, r7, r3
    268a:	781b      	ldrb	r3, [r3, #0]
}
    268c:	0018      	movs	r0, r3
    268e:	46bd      	mov	sp, r7
    2690:	b005      	add	sp, #20
    2692:	bd90      	pop	{r4, r7, pc}
    2694:	40066000 	.word	0x40066000

00002698 <hal_dev_mma8451_write_reg>:
void hal_dev_mma8451_write_reg(uint8 addr, uint8 data)
{
    2698:	b580      	push	{r7, lr}
    269a:	b082      	sub	sp, #8
    269c:	af00      	add	r7, sp, #0
    269e:	0002      	movs	r2, r0
    26a0:	1dfb      	adds	r3, r7, #7
    26a2:	701a      	strb	r2, [r3, #0]
    26a4:	1dbb      	adds	r3, r7, #6
    26a6:	1c0a      	adds	r2, r1, #0
    26a8:	701a      	strb	r2, [r3, #0]
    i2c_start(I2C0_B);
    26aa:	4b1c      	ldr	r3, [pc, #112]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26ac:	0018      	movs	r0, r3
    26ae:	f000 f8b1 	bl	2814 <i2c_start>

    i2c_write_byte(I2C0_B, MMA8451_I2C_ADDRESS|I2C_WRITE);
    26b2:	4b1a      	ldr	r3, [pc, #104]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26b4:	213a      	movs	r1, #58	; 0x3a
    26b6:	0018      	movs	r0, r3
    26b8:	f000 f892 	bl	27e0 <i2c_write_byte>
    i2c_wait(I2C0_B);
    26bc:	4b17      	ldr	r3, [pc, #92]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26be:	0018      	movs	r0, r3
    26c0:	f000 f8c8 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    26c4:	4b15      	ldr	r3, [pc, #84]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26c6:	0018      	movs	r0, r3
    26c8:	f000 f8dc 	bl	2884 <i2c_get_ack>

    i2c_write_byte(I2C0_B, addr);
    26cc:	1dfb      	adds	r3, r7, #7
    26ce:	781b      	ldrb	r3, [r3, #0]
    26d0:	4a12      	ldr	r2, [pc, #72]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26d2:	0019      	movs	r1, r3
    26d4:	0010      	movs	r0, r2
    26d6:	f000 f883 	bl	27e0 <i2c_write_byte>
    i2c_wait(I2C0_B);
    26da:	4b10      	ldr	r3, [pc, #64]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26dc:	0018      	movs	r0, r3
    26de:	f000 f8b9 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    26e2:	4b0e      	ldr	r3, [pc, #56]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26e4:	0018      	movs	r0, r3
    26e6:	f000 f8cd 	bl	2884 <i2c_get_ack>

    i2c_write_byte(I2C0_B, data);
    26ea:	1dbb      	adds	r3, r7, #6
    26ec:	781b      	ldrb	r3, [r3, #0]
    26ee:	4a0b      	ldr	r2, [pc, #44]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26f0:	0019      	movs	r1, r3
    26f2:	0010      	movs	r0, r2
    26f4:	f000 f874 	bl	27e0 <i2c_write_byte>
    i2c_wait(I2C0_B);
    26f8:	4b08      	ldr	r3, [pc, #32]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    26fa:	0018      	movs	r0, r3
    26fc:	f000 f8aa 	bl	2854 <i2c_wait>
    i2c_get_ack(I2C0_B);
    2700:	4b06      	ldr	r3, [pc, #24]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    2702:	0018      	movs	r0, r3
    2704:	f000 f8be 	bl	2884 <i2c_get_ack>

    i2c_stop(I2C0_B);
    2708:	4b04      	ldr	r3, [pc, #16]	; (271c <hal_dev_mma8451_write_reg+0x84>)
    270a:	0018      	movs	r0, r3
    270c:	f000 f892 	bl	2834 <i2c_stop>
    pause();
    2710:	f7ff ff4e 	bl	25b0 <pause>
}
    2714:	46c0      	nop			; (mov r8, r8)
    2716:	46bd      	mov	sp, r7
    2718:	b002      	add	sp, #8
    271a:	bd80      	pop	{r7, pc}
    271c:	40066000 	.word	0x40066000

00002720 <i2c_set_tx_mode>:

#include "common.h"


void i2c_set_tx_mode(I2C_MemMapPtr p)
{
    2720:	b580      	push	{r7, lr}
    2722:	b082      	sub	sp, #8
    2724:	af00      	add	r7, sp, #0
    2726:	6078      	str	r0, [r7, #4]
    p->C1 |= I2C_C1_TX_MASK;
    2728:	687b      	ldr	r3, [r7, #4]
    272a:	789b      	ldrb	r3, [r3, #2]
    272c:	b2db      	uxtb	r3, r3
    272e:	2210      	movs	r2, #16
    2730:	4313      	orrs	r3, r2
    2732:	b2da      	uxtb	r2, r3
    2734:	687b      	ldr	r3, [r7, #4]
    2736:	709a      	strb	r2, [r3, #2]

}
    2738:	46c0      	nop			; (mov r8, r8)
    273a:	46bd      	mov	sp, r7
    273c:	b002      	add	sp, #8
    273e:	bd80      	pop	{r7, pc}

00002740 <i2c_set_rx_mode>:
void i2c_set_rx_mode(I2C_MemMapPtr p)
{
    2740:	b580      	push	{r7, lr}
    2742:	b082      	sub	sp, #8
    2744:	af00      	add	r7, sp, #0
    2746:	6078      	str	r0, [r7, #4]
    p->C1 &= ~I2C_C1_TX_MASK;
    2748:	687b      	ldr	r3, [r7, #4]
    274a:	789b      	ldrb	r3, [r3, #2]
    274c:	b2db      	uxtb	r3, r3
    274e:	2210      	movs	r2, #16
    2750:	4393      	bics	r3, r2
    2752:	b2da      	uxtb	r2, r3
    2754:	687b      	ldr	r3, [r7, #4]
    2756:	709a      	strb	r2, [r3, #2]
}
    2758:	46c0      	nop			; (mov r8, r8)
    275a:	46bd      	mov	sp, r7
    275c:	b002      	add	sp, #8
    275e:	bd80      	pop	{r7, pc}

00002760 <i2c_set_slave_mode>:

void i2c_set_slave_mode(I2C_MemMapPtr p)
{
    2760:	b580      	push	{r7, lr}
    2762:	b082      	sub	sp, #8
    2764:	af00      	add	r7, sp, #0
    2766:	6078      	str	r0, [r7, #4]
    p->C1  &= ~I2C_C1_MST_MASK;
    2768:	687b      	ldr	r3, [r7, #4]
    276a:	789b      	ldrb	r3, [r3, #2]
    276c:	b2db      	uxtb	r3, r3
    276e:	2220      	movs	r2, #32
    2770:	4393      	bics	r3, r2
    2772:	b2da      	uxtb	r2, r3
    2774:	687b      	ldr	r3, [r7, #4]
    2776:	709a      	strb	r2, [r3, #2]
}
    2778:	46c0      	nop			; (mov r8, r8)
    277a:	46bd      	mov	sp, r7
    277c:	b002      	add	sp, #8
    277e:	bd80      	pop	{r7, pc}

00002780 <i2c_set_master_mode>:
void i2c_set_master_mode(I2C_MemMapPtr p)
{
    2780:	b580      	push	{r7, lr}
    2782:	b082      	sub	sp, #8
    2784:	af00      	add	r7, sp, #0
    2786:	6078      	str	r0, [r7, #4]
    p->C1  |=  I2C_C1_MST_MASK;
    2788:	687b      	ldr	r3, [r7, #4]
    278a:	789b      	ldrb	r3, [r3, #2]
    278c:	b2db      	uxtb	r3, r3
    278e:	2220      	movs	r2, #32
    2790:	4313      	orrs	r3, r2
    2792:	b2da      	uxtb	r2, r3
    2794:	687b      	ldr	r3, [r7, #4]
    2796:	709a      	strb	r2, [r3, #2]
}
    2798:	46c0      	nop			; (mov r8, r8)
    279a:	46bd      	mov	sp, r7
    279c:	b002      	add	sp, #8
    279e:	bd80      	pop	{r7, pc}

000027a0 <i2c_give_nack>:

// i2c general

void i2c_give_nack(I2C_MemMapPtr p)
{
    27a0:	b580      	push	{r7, lr}
    27a2:	b082      	sub	sp, #8
    27a4:	af00      	add	r7, sp, #0
    27a6:	6078      	str	r0, [r7, #4]
    p->C1 |= I2C_C1_TXAK_MASK;
    27a8:	687b      	ldr	r3, [r7, #4]
    27aa:	789b      	ldrb	r3, [r3, #2]
    27ac:	b2db      	uxtb	r3, r3
    27ae:	2208      	movs	r2, #8
    27b0:	4313      	orrs	r3, r2
    27b2:	b2da      	uxtb	r2, r3
    27b4:	687b      	ldr	r3, [r7, #4]
    27b6:	709a      	strb	r2, [r3, #2]
}
    27b8:	46c0      	nop			; (mov r8, r8)
    27ba:	46bd      	mov	sp, r7
    27bc:	b002      	add	sp, #8
    27be:	bd80      	pop	{r7, pc}

000027c0 <i2c_repeated_start>:
void i2c_give_ack(I2C_MemMapPtr p)
{
    p->C1 &= ~I2C_C1_TXAK_MASK;
}
void i2c_repeated_start(I2C_MemMapPtr p)
{
    27c0:	b580      	push	{r7, lr}
    27c2:	b082      	sub	sp, #8
    27c4:	af00      	add	r7, sp, #0
    27c6:	6078      	str	r0, [r7, #4]
    p->C1     |= 0x04;
    27c8:	687b      	ldr	r3, [r7, #4]
    27ca:	789b      	ldrb	r3, [r3, #2]
    27cc:	b2db      	uxtb	r3, r3
    27ce:	2204      	movs	r2, #4
    27d0:	4313      	orrs	r3, r2
    27d2:	b2da      	uxtb	r2, r3
    27d4:	687b      	ldr	r3, [r7, #4]
    27d6:	709a      	strb	r2, [r3, #2]
}
    27d8:	46c0      	nop			; (mov r8, r8)
    27da:	46bd      	mov	sp, r7
    27dc:	b002      	add	sp, #8
    27de:	bd80      	pop	{r7, pc}

000027e0 <i2c_write_byte>:
void i2c_write_byte(I2C_MemMapPtr p, uint8 data)
{
    27e0:	b580      	push	{r7, lr}
    27e2:	b082      	sub	sp, #8
    27e4:	af00      	add	r7, sp, #0
    27e6:	6078      	str	r0, [r7, #4]
    27e8:	000a      	movs	r2, r1
    27ea:	1cfb      	adds	r3, r7, #3
    27ec:	701a      	strb	r2, [r3, #0]
    p->D = data;
    27ee:	687b      	ldr	r3, [r7, #4]
    27f0:	1cfa      	adds	r2, r7, #3
    27f2:	7812      	ldrb	r2, [r2, #0]
    27f4:	711a      	strb	r2, [r3, #4]
}
    27f6:	46c0      	nop			; (mov r8, r8)
    27f8:	46bd      	mov	sp, r7
    27fa:	b002      	add	sp, #8
    27fc:	bd80      	pop	{r7, pc}

000027fe <i2c_read_byte>:
uint8 i2c_read_byte(I2C_MemMapPtr p)
{
    27fe:	b580      	push	{r7, lr}
    2800:	b082      	sub	sp, #8
    2802:	af00      	add	r7, sp, #0
    2804:	6078      	str	r0, [r7, #4]
    return p->D;
    2806:	687b      	ldr	r3, [r7, #4]
    2808:	791b      	ldrb	r3, [r3, #4]
    280a:	b2db      	uxtb	r3, r3
}
    280c:	0018      	movs	r0, r3
    280e:	46bd      	mov	sp, r7
    2810:	b002      	add	sp, #8
    2812:	bd80      	pop	{r7, pc}

00002814 <i2c_start>:
void i2c_start(I2C_MemMapPtr p)
{
    2814:	b580      	push	{r7, lr}
    2816:	b082      	sub	sp, #8
    2818:	af00      	add	r7, sp, #0
    281a:	6078      	str	r0, [r7, #4]
    i2c_set_master_mode(p);
    281c:	687b      	ldr	r3, [r7, #4]
    281e:	0018      	movs	r0, r3
    2820:	f7ff ffae 	bl	2780 <i2c_set_master_mode>
    i2c_set_tx_mode(p);
    2824:	687b      	ldr	r3, [r7, #4]
    2826:	0018      	movs	r0, r3
    2828:	f7ff ff7a 	bl	2720 <i2c_set_tx_mode>
}
    282c:	46c0      	nop			; (mov r8, r8)
    282e:	46bd      	mov	sp, r7
    2830:	b002      	add	sp, #8
    2832:	bd80      	pop	{r7, pc}

00002834 <i2c_stop>:
void i2c_stop(I2C_MemMapPtr p)
{
    2834:	b580      	push	{r7, lr}
    2836:	b082      	sub	sp, #8
    2838:	af00      	add	r7, sp, #0
    283a:	6078      	str	r0, [r7, #4]
    i2c_set_slave_mode(p);
    283c:	687b      	ldr	r3, [r7, #4]
    283e:	0018      	movs	r0, r3
    2840:	f7ff ff8e 	bl	2760 <i2c_set_slave_mode>
    i2c_set_rx_mode(p);
    2844:	687b      	ldr	r3, [r7, #4]
    2846:	0018      	movs	r0, r3
    2848:	f7ff ff7a 	bl	2740 <i2c_set_rx_mode>
}
    284c:	46c0      	nop			; (mov r8, r8)
    284e:	46bd      	mov	sp, r7
    2850:	b002      	add	sp, #8
    2852:	bd80      	pop	{r7, pc}

00002854 <i2c_wait>:
void i2c_wait(I2C_MemMapPtr p)
{
    2854:	b580      	push	{r7, lr}
    2856:	b082      	sub	sp, #8
    2858:	af00      	add	r7, sp, #0
    285a:	6078      	str	r0, [r7, #4]
    // wait flag
    while((p->S & I2C_S_IICIF_MASK)==0)
    285c:	46c0      	nop			; (mov r8, r8)
    285e:	687b      	ldr	r3, [r7, #4]
    2860:	78db      	ldrb	r3, [r3, #3]
    2862:	b2db      	uxtb	r3, r3
    2864:	001a      	movs	r2, r3
    2866:	2302      	movs	r3, #2
    2868:	4013      	ands	r3, r2
    286a:	d0f8      	beq.n	285e <i2c_wait+0xa>
        ;
    // clear flag
    p->S |= I2C_S_IICIF_MASK;
    286c:	687b      	ldr	r3, [r7, #4]
    286e:	78db      	ldrb	r3, [r3, #3]
    2870:	b2db      	uxtb	r3, r3
    2872:	2202      	movs	r2, #2
    2874:	4313      	orrs	r3, r2
    2876:	b2da      	uxtb	r2, r3
    2878:	687b      	ldr	r3, [r7, #4]
    287a:	70da      	strb	r2, [r3, #3]
}
    287c:	46c0      	nop			; (mov r8, r8)
    287e:	46bd      	mov	sp, r7
    2880:	b002      	add	sp, #8
    2882:	bd80      	pop	{r7, pc}

00002884 <i2c_get_ack>:
uint16 i2c_get_ack(I2C_MemMapPtr p)
{
    2884:	b580      	push	{r7, lr}
    2886:	b082      	sub	sp, #8
    2888:	af00      	add	r7, sp, #0
    288a:	6078      	str	r0, [r7, #4]
    if((p->S & I2C_S_RXAK_MASK) == 0)
    288c:	687b      	ldr	r3, [r7, #4]
    288e:	78db      	ldrb	r3, [r3, #3]
    2890:	b2db      	uxtb	r3, r3
    2892:	001a      	movs	r2, r3
    2894:	2301      	movs	r3, #1
    2896:	4013      	ands	r3, r2
    2898:	d101      	bne.n	289e <i2c_get_ack+0x1a>
        return TRUE;
    289a:	2301      	movs	r3, #1
    289c:	e000      	b.n	28a0 <i2c_get_ack+0x1c>
    else
        return FALSE;
    289e:	2300      	movs	r3, #0
}
    28a0:	0018      	movs	r0, r3
    28a2:	46bd      	mov	sp, r7
    28a4:	b002      	add	sp, #8
    28a6:	bd80      	pop	{r7, pc}

000028a8 <hal_i2c_init>:

// -------------------------------------------------
void hal_i2c_init(I2C_MemMapPtr p)
{
    28a8:	b580      	push	{r7, lr}
    28aa:	b082      	sub	sp, #8
    28ac:	af00      	add	r7, sp, #0
    28ae:	6078      	str	r0, [r7, #4]
   // SIM_SCGC4 |= SIM_SCGC4_I2C1_MASK;

   SIM_SCGC4 |= SIM_SCGC4_I2C0_MASK;
    28b0:	490c      	ldr	r1, [pc, #48]	; (28e4 <hal_i2c_init+0x3c>)
    28b2:	4a0c      	ldr	r2, [pc, #48]	; (28e4 <hal_i2c_init+0x3c>)
    28b4:	4b0c      	ldr	r3, [pc, #48]	; (28e8 <hal_i2c_init+0x40>)
    28b6:	58d3      	ldr	r3, [r2, r3]
    28b8:	2240      	movs	r2, #64	; 0x40
    28ba:	4313      	orrs	r3, r2
    28bc:	4a0a      	ldr	r2, [pc, #40]	; (28e8 <hal_i2c_init+0x40>)
    28be:	508b      	str	r3, [r1, r2]
    
      // configure GPIO for I2C function
    PORTE_PCR24 = PORT_PCR_MUX(5);
    28c0:	4b0a      	ldr	r3, [pc, #40]	; (28ec <hal_i2c_init+0x44>)
    28c2:	22a0      	movs	r2, #160	; 0xa0
    28c4:	00d2      	lsls	r2, r2, #3
    28c6:	661a      	str	r2, [r3, #96]	; 0x60
    PORTE_PCR25 = PORT_PCR_MUX(5);
    28c8:	4b08      	ldr	r3, [pc, #32]	; (28ec <hal_i2c_init+0x44>)
    28ca:	22a0      	movs	r2, #160	; 0xa0
    28cc:	00d2      	lsls	r2, r2, #3
    28ce:	665a      	str	r2, [r3, #100]	; 0x64


    
    p->F  = 0x14; // baudrate
    28d0:	687b      	ldr	r3, [r7, #4]
    28d2:	2214      	movs	r2, #20
    28d4:	705a      	strb	r2, [r3, #1]
    p->C1 = 0x80; // enable IIC
    28d6:	687b      	ldr	r3, [r7, #4]
    28d8:	2280      	movs	r2, #128	; 0x80
    28da:	709a      	strb	r2, [r3, #2]
}
    28dc:	46c0      	nop			; (mov r8, r8)
    28de:	46bd      	mov	sp, r7
    28e0:	b002      	add	sp, #8
    28e2:	bd80      	pop	{r7, pc}
    28e4:	40047000 	.word	0x40047000
    28e8:	00001034 	.word	0x00001034
    28ec:	4004d000 	.word	0x4004d000

000028f0 <angle_calculation>:
    

*/

void angle_calculation(void)
 {
    28f0:	b580      	push	{r7, lr}
    28f2:	b084      	sub	sp, #16
    28f4:	af00      	add	r7, sp, #0

 /*  if (accel_count != 0) return;
   accel_count = 60; //60 msec
   */
   
   nv = (signed char)(resultx);
    28f6:	4b7b      	ldr	r3, [pc, #492]	; (2ae4 <angle_calculation+0x1f4>)
    28f8:	2200      	movs	r2, #0
    28fa:	5e9b      	ldrsh	r3, [r3, r2]
    28fc:	b25b      	sxtb	r3, r3
    28fe:	60fb      	str	r3, [r7, #12]
   X_acc = median(nv, &arr_medianas[0]);
    2900:	4a79      	ldr	r2, [pc, #484]	; (2ae8 <angle_calculation+0x1f8>)
    2902:	68fb      	ldr	r3, [r7, #12]
    2904:	0011      	movs	r1, r2
    2906:	0018      	movs	r0, r3
    2908:	f000 f93a 	bl	2b80 <median>
    290c:	0002      	movs	r2, r0
    290e:	4b77      	ldr	r3, [pc, #476]	; (2aec <angle_calculation+0x1fc>)
    2910:	601a      	str	r2, [r3, #0]
   
   
   nv = (signed char)(resulty);
    2912:	4b77      	ldr	r3, [pc, #476]	; (2af0 <angle_calculation+0x200>)
    2914:	2200      	movs	r2, #0
    2916:	5e9b      	ldrsh	r3, [r3, r2]
    2918:	b25b      	sxtb	r3, r3
    291a:	60fb      	str	r3, [r7, #12]
   Y_acc = median(nv, &arr_medianas[1]);
    291c:	4a75      	ldr	r2, [pc, #468]	; (2af4 <angle_calculation+0x204>)
    291e:	68fb      	ldr	r3, [r7, #12]
    2920:	0011      	movs	r1, r2
    2922:	0018      	movs	r0, r3
    2924:	f000 f92c 	bl	2b80 <median>
    2928:	0002      	movs	r2, r0
    292a:	4b73      	ldr	r3, [pc, #460]	; (2af8 <angle_calculation+0x208>)
    292c:	601a      	str	r2, [r3, #0]
   
   nv = (signed char)(resultz);  
    292e:	4b73      	ldr	r3, [pc, #460]	; (2afc <angle_calculation+0x20c>)
    2930:	2200      	movs	r2, #0
    2932:	5e9b      	ldrsh	r3, [r3, r2]
    2934:	b25b      	sxtb	r3, r3
    2936:	60fb      	str	r3, [r7, #12]
   Z_acc = median(nv, &arr_medianas[2]);
    2938:	4a71      	ldr	r2, [pc, #452]	; (2b00 <angle_calculation+0x210>)
    293a:	68fb      	ldr	r3, [r7, #12]
    293c:	0011      	movs	r1, r2
    293e:	0018      	movs	r0, r3
    2940:	f000 f91e 	bl	2b80 <median>
    2944:	0002      	movs	r2, r0
    2946:	4b6f      	ldr	r3, [pc, #444]	; (2b04 <angle_calculation+0x214>)
    2948:	601a      	str	r2, [r3, #0]

   x2        = X_acc*X_acc;
    294a:	4b68      	ldr	r3, [pc, #416]	; (2aec <angle_calculation+0x1fc>)
    294c:	681a      	ldr	r2, [r3, #0]
    294e:	4b67      	ldr	r3, [pc, #412]	; (2aec <angle_calculation+0x1fc>)
    2950:	681b      	ldr	r3, [r3, #0]
    2952:	4353      	muls	r3, r2
    2954:	60bb      	str	r3, [r7, #8]
   y2        = Y_acc*Y_acc;
    2956:	4b68      	ldr	r3, [pc, #416]	; (2af8 <angle_calculation+0x208>)
    2958:	681a      	ldr	r2, [r3, #0]
    295a:	4b67      	ldr	r3, [pc, #412]	; (2af8 <angle_calculation+0x208>)
    295c:	681b      	ldr	r3, [r3, #0]
    295e:	4353      	muls	r3, r2
    2960:	607b      	str	r3, [r7, #4]

   xy_mag   = sqrt_16(x2 + y2);
    2962:	68ba      	ldr	r2, [r7, #8]
    2964:	687b      	ldr	r3, [r7, #4]
    2966:	18d3      	adds	r3, r2, r3
    2968:	0018      	movs	r0, r3
    296a:	f000 f975 	bl	2c58 <sqrt_16>
    296e:	0002      	movs	r2, r0
    2970:	4b65      	ldr	r3, [pc, #404]	; (2b08 <angle_calculation+0x218>)
    2972:	601a      	str	r2, [r3, #0]
  
   if (Y_acc<0) cat = -Y_acc; else cat = Y_acc;
    2974:	4b60      	ldr	r3, [pc, #384]	; (2af8 <angle_calculation+0x208>)
    2976:	681b      	ldr	r3, [r3, #0]
    2978:	2b00      	cmp	r3, #0
    297a:	da06      	bge.n	298a <angle_calculation+0x9a>
    297c:	4b5e      	ldr	r3, [pc, #376]	; (2af8 <angle_calculation+0x208>)
    297e:	681b      	ldr	r3, [r3, #0]
    2980:	425b      	negs	r3, r3
    2982:	001a      	movs	r2, r3
    2984:	4b61      	ldr	r3, [pc, #388]	; (2b0c <angle_calculation+0x21c>)
    2986:	601a      	str	r2, [r3, #0]
    2988:	e004      	b.n	2994 <angle_calculation+0xa4>
    298a:	4b5b      	ldr	r3, [pc, #364]	; (2af8 <angle_calculation+0x208>)
    298c:	681b      	ldr	r3, [r3, #0]
    298e:	001a      	movs	r2, r3
    2990:	4b5e      	ldr	r3, [pc, #376]	; (2b0c <angle_calculation+0x21c>)
    2992:	601a      	str	r2, [r3, #0]
   
   offset = (unsigned int)(cat<<7)/(unsigned int)xy_mag;
    2994:	4b5d      	ldr	r3, [pc, #372]	; (2b0c <angle_calculation+0x21c>)
    2996:	681b      	ldr	r3, [r3, #0]
    2998:	01da      	lsls	r2, r3, #7
    299a:	4b5b      	ldr	r3, [pc, #364]	; (2b08 <angle_calculation+0x218>)
    299c:	681b      	ldr	r3, [r3, #0]
    299e:	0019      	movs	r1, r3
    29a0:	0010      	movs	r0, r2
    29a2:	f7fd fd59 	bl	458 <__udivsi3>
    29a6:	0003      	movs	r3, r0
    29a8:	001a      	movs	r2, r3
    29aa:	4b59      	ldr	r3, [pc, #356]	; (2b10 <angle_calculation+0x220>)
    29ac:	601a      	str	r2, [r3, #0]
   if (offset>127) offset = 127;    
    29ae:	4b58      	ldr	r3, [pc, #352]	; (2b10 <angle_calculation+0x220>)
    29b0:	681b      	ldr	r3, [r3, #0]
    29b2:	2b7f      	cmp	r3, #127	; 0x7f
    29b4:	d902      	bls.n	29bc <angle_calculation+0xcc>
    29b6:	4b56      	ldr	r3, [pc, #344]	; (2b10 <angle_calculation+0x220>)
    29b8:	227f      	movs	r2, #127	; 0x7f
    29ba:	601a      	str	r2, [r3, #0]
   xy_angle = asin[offset];
    29bc:	4b54      	ldr	r3, [pc, #336]	; (2b10 <angle_calculation+0x220>)
    29be:	681a      	ldr	r2, [r3, #0]
    29c0:	4b54      	ldr	r3, [pc, #336]	; (2b14 <angle_calculation+0x224>)
    29c2:	0092      	lsls	r2, r2, #2
    29c4:	58d2      	ldr	r2, [r2, r3]
    29c6:	4b54      	ldr	r3, [pc, #336]	; (2b18 <angle_calculation+0x228>)
    29c8:	601a      	str	r2, [r3, #0]
   
   if (Y_acc>0)  xy_angle = -xy_angle;
    29ca:	4b4b      	ldr	r3, [pc, #300]	; (2af8 <angle_calculation+0x208>)
    29cc:	681b      	ldr	r3, [r3, #0]
    29ce:	2b00      	cmp	r3, #0
    29d0:	dd04      	ble.n	29dc <angle_calculation+0xec>
    29d2:	4b51      	ldr	r3, [pc, #324]	; (2b18 <angle_calculation+0x228>)
    29d4:	681b      	ldr	r3, [r3, #0]
    29d6:	425a      	negs	r2, r3
    29d8:	4b4f      	ldr	r3, [pc, #316]	; (2b18 <angle_calculation+0x228>)
    29da:	601a      	str	r2, [r3, #0]
   
 
   /////////   
   
   z2        = Z_acc*Z_acc;   
    29dc:	4b49      	ldr	r3, [pc, #292]	; (2b04 <angle_calculation+0x214>)
    29de:	681a      	ldr	r2, [r3, #0]
    29e0:	4b48      	ldr	r3, [pc, #288]	; (2b04 <angle_calculation+0x214>)
    29e2:	681b      	ldr	r3, [r3, #0]
    29e4:	4353      	muls	r3, r2
    29e6:	603b      	str	r3, [r7, #0]
   xz_mag    = sqrt_16(x2 + z2);
    29e8:	68ba      	ldr	r2, [r7, #8]
    29ea:	683b      	ldr	r3, [r7, #0]
    29ec:	18d3      	adds	r3, r2, r3
    29ee:	0018      	movs	r0, r3
    29f0:	f000 f932 	bl	2c58 <sqrt_16>
    29f4:	0002      	movs	r2, r0
    29f6:	4b49      	ldr	r3, [pc, #292]	; (2b1c <angle_calculation+0x22c>)
    29f8:	601a      	str	r2, [r3, #0]
   if (X_acc<0) cat = -X_acc; else cat = X_acc;
    29fa:	4b3c      	ldr	r3, [pc, #240]	; (2aec <angle_calculation+0x1fc>)
    29fc:	681b      	ldr	r3, [r3, #0]
    29fe:	2b00      	cmp	r3, #0
    2a00:	da06      	bge.n	2a10 <angle_calculation+0x120>
    2a02:	4b3a      	ldr	r3, [pc, #232]	; (2aec <angle_calculation+0x1fc>)
    2a04:	681b      	ldr	r3, [r3, #0]
    2a06:	425b      	negs	r3, r3
    2a08:	001a      	movs	r2, r3
    2a0a:	4b40      	ldr	r3, [pc, #256]	; (2b0c <angle_calculation+0x21c>)
    2a0c:	601a      	str	r2, [r3, #0]
    2a0e:	e004      	b.n	2a1a <angle_calculation+0x12a>
    2a10:	4b36      	ldr	r3, [pc, #216]	; (2aec <angle_calculation+0x1fc>)
    2a12:	681b      	ldr	r3, [r3, #0]
    2a14:	001a      	movs	r2, r3
    2a16:	4b3d      	ldr	r3, [pc, #244]	; (2b0c <angle_calculation+0x21c>)
    2a18:	601a      	str	r2, [r3, #0]
   offset = (unsigned int)(cat<<7)/(unsigned int)xz_mag;
    2a1a:	4b3c      	ldr	r3, [pc, #240]	; (2b0c <angle_calculation+0x21c>)
    2a1c:	681b      	ldr	r3, [r3, #0]
    2a1e:	01da      	lsls	r2, r3, #7
    2a20:	4b3e      	ldr	r3, [pc, #248]	; (2b1c <angle_calculation+0x22c>)
    2a22:	681b      	ldr	r3, [r3, #0]
    2a24:	0019      	movs	r1, r3
    2a26:	0010      	movs	r0, r2
    2a28:	f7fd fd16 	bl	458 <__udivsi3>
    2a2c:	0003      	movs	r3, r0
    2a2e:	001a      	movs	r2, r3
    2a30:	4b37      	ldr	r3, [pc, #220]	; (2b10 <angle_calculation+0x220>)
    2a32:	601a      	str	r2, [r3, #0]
   if (offset>127) offset = 127;    
    2a34:	4b36      	ldr	r3, [pc, #216]	; (2b10 <angle_calculation+0x220>)
    2a36:	681b      	ldr	r3, [r3, #0]
    2a38:	2b7f      	cmp	r3, #127	; 0x7f
    2a3a:	d902      	bls.n	2a42 <angle_calculation+0x152>
    2a3c:	4b34      	ldr	r3, [pc, #208]	; (2b10 <angle_calculation+0x220>)
    2a3e:	227f      	movs	r2, #127	; 0x7f
    2a40:	601a      	str	r2, [r3, #0]
   xz_angle = asin[offset];
    2a42:	4b33      	ldr	r3, [pc, #204]	; (2b10 <angle_calculation+0x220>)
    2a44:	681a      	ldr	r2, [r3, #0]
    2a46:	4b33      	ldr	r3, [pc, #204]	; (2b14 <angle_calculation+0x224>)
    2a48:	0092      	lsls	r2, r2, #2
    2a4a:	58d2      	ldr	r2, [r2, r3]
    2a4c:	4b34      	ldr	r3, [pc, #208]	; (2b20 <angle_calculation+0x230>)
    2a4e:	601a      	str	r2, [r3, #0]
   
   if (X_acc>0)  xz_angle = -xz_angle;
    2a50:	4b26      	ldr	r3, [pc, #152]	; (2aec <angle_calculation+0x1fc>)
    2a52:	681b      	ldr	r3, [r3, #0]
    2a54:	2b00      	cmp	r3, #0
    2a56:	dd04      	ble.n	2a62 <angle_calculation+0x172>
    2a58:	4b31      	ldr	r3, [pc, #196]	; (2b20 <angle_calculation+0x230>)
    2a5a:	681b      	ldr	r3, [r3, #0]
    2a5c:	425a      	negs	r2, r3
    2a5e:	4b30      	ldr	r3, [pc, #192]	; (2b20 <angle_calculation+0x230>)
    2a60:	601a      	str	r2, [r3, #0]
   

   yz_mag    = sqrt_16(y2 + z2);
    2a62:	687a      	ldr	r2, [r7, #4]
    2a64:	683b      	ldr	r3, [r7, #0]
    2a66:	18d3      	adds	r3, r2, r3
    2a68:	0018      	movs	r0, r3
    2a6a:	f000 f8f5 	bl	2c58 <sqrt_16>
    2a6e:	0002      	movs	r2, r0
    2a70:	4b2c      	ldr	r3, [pc, #176]	; (2b24 <angle_calculation+0x234>)
    2a72:	601a      	str	r2, [r3, #0]
   if (Y_acc<0) cat = -Y_acc; else cat = Y_acc;
    2a74:	4b20      	ldr	r3, [pc, #128]	; (2af8 <angle_calculation+0x208>)
    2a76:	681b      	ldr	r3, [r3, #0]
    2a78:	2b00      	cmp	r3, #0
    2a7a:	da06      	bge.n	2a8a <angle_calculation+0x19a>
    2a7c:	4b1e      	ldr	r3, [pc, #120]	; (2af8 <angle_calculation+0x208>)
    2a7e:	681b      	ldr	r3, [r3, #0]
    2a80:	425b      	negs	r3, r3
    2a82:	001a      	movs	r2, r3
    2a84:	4b21      	ldr	r3, [pc, #132]	; (2b0c <angle_calculation+0x21c>)
    2a86:	601a      	str	r2, [r3, #0]
    2a88:	e004      	b.n	2a94 <angle_calculation+0x1a4>
    2a8a:	4b1b      	ldr	r3, [pc, #108]	; (2af8 <angle_calculation+0x208>)
    2a8c:	681b      	ldr	r3, [r3, #0]
    2a8e:	001a      	movs	r2, r3
    2a90:	4b1e      	ldr	r3, [pc, #120]	; (2b0c <angle_calculation+0x21c>)
    2a92:	601a      	str	r2, [r3, #0]
   offset = (unsigned int)(cat<<7)/(unsigned int)yz_mag;
    2a94:	4b1d      	ldr	r3, [pc, #116]	; (2b0c <angle_calculation+0x21c>)
    2a96:	681b      	ldr	r3, [r3, #0]
    2a98:	01da      	lsls	r2, r3, #7
    2a9a:	4b22      	ldr	r3, [pc, #136]	; (2b24 <angle_calculation+0x234>)
    2a9c:	681b      	ldr	r3, [r3, #0]
    2a9e:	0019      	movs	r1, r3
    2aa0:	0010      	movs	r0, r2
    2aa2:	f7fd fcd9 	bl	458 <__udivsi3>
    2aa6:	0003      	movs	r3, r0
    2aa8:	001a      	movs	r2, r3
    2aaa:	4b19      	ldr	r3, [pc, #100]	; (2b10 <angle_calculation+0x220>)
    2aac:	601a      	str	r2, [r3, #0]
   if (offset>127) offset = 127;    
    2aae:	4b18      	ldr	r3, [pc, #96]	; (2b10 <angle_calculation+0x220>)
    2ab0:	681b      	ldr	r3, [r3, #0]
    2ab2:	2b7f      	cmp	r3, #127	; 0x7f
    2ab4:	d902      	bls.n	2abc <angle_calculation+0x1cc>
    2ab6:	4b16      	ldr	r3, [pc, #88]	; (2b10 <angle_calculation+0x220>)
    2ab8:	227f      	movs	r2, #127	; 0x7f
    2aba:	601a      	str	r2, [r3, #0]
   yz_angle = asin[offset];
    2abc:	4b14      	ldr	r3, [pc, #80]	; (2b10 <angle_calculation+0x220>)
    2abe:	681a      	ldr	r2, [r3, #0]
    2ac0:	4b14      	ldr	r3, [pc, #80]	; (2b14 <angle_calculation+0x224>)
    2ac2:	0092      	lsls	r2, r2, #2
    2ac4:	58d2      	ldr	r2, [r2, r3]
    2ac6:	4b18      	ldr	r3, [pc, #96]	; (2b28 <angle_calculation+0x238>)
    2ac8:	601a      	str	r2, [r3, #0]
   if (Y_acc>0)  yz_angle = -yz_angle;
    2aca:	4b0b      	ldr	r3, [pc, #44]	; (2af8 <angle_calculation+0x208>)
    2acc:	681b      	ldr	r3, [r3, #0]
    2ace:	2b00      	cmp	r3, #0
    2ad0:	dd04      	ble.n	2adc <angle_calculation+0x1ec>
    2ad2:	4b15      	ldr	r3, [pc, #84]	; (2b28 <angle_calculation+0x238>)
    2ad4:	681b      	ldr	r3, [r3, #0]
    2ad6:	425a      	negs	r2, r3
    2ad8:	4b13      	ldr	r3, [pc, #76]	; (2b28 <angle_calculation+0x238>)
    2ada:	601a      	str	r2, [r3, #0]
    
 }
    2adc:	46c0      	nop			; (mov r8, r8)
    2ade:	46bd      	mov	sp, r7
    2ae0:	b004      	add	sp, #16
    2ae2:	bd80      	pop	{r7, pc}
    2ae4:	1ffff4e2 	.word	0x1ffff4e2
    2ae8:	1ffff540 	.word	0x1ffff540
    2aec:	1ffff5b4 	.word	0x1ffff5b4
    2af0:	1ffff526 	.word	0x1ffff526
    2af4:	1ffff564 	.word	0x1ffff564
    2af8:	1ffff5c0 	.word	0x1ffff5c0
    2afc:	1ffff4e0 	.word	0x1ffff4e0
    2b00:	1ffff588 	.word	0x1ffff588
    2b04:	1ffff5b0 	.word	0x1ffff5b0
    2b08:	1ffff5ac 	.word	0x1ffff5ac
    2b0c:	1ffff530 	.word	0x1ffff530
    2b10:	1ffff5bc 	.word	0x1ffff5bc
    2b14:	00004998 	.word	0x00004998
    2b18:	1ffff534 	.word	0x1ffff534
    2b1c:	1ffff538 	.word	0x1ffff538
    2b20:	1ffff5c4 	.word	0x1ffff5c4
    2b24:	1ffff52c 	.word	0x1ffff52c
    2b28:	1ffff5b8 	.word	0x1ffff5b8

00002b2c <detect_fall_detection>:


   /*Fall detection*/
#define FALL_LIMIT  45//50
void detect_fall_detection(void)
{
    2b2c:	b580      	push	{r7, lr}
    2b2e:	af00      	add	r7, sp, #0
   if (xy_mag<FALL_LIMIT && xz_mag < FALL_LIMIT && yz_mag < FALL_LIMIT  && !ti_fall) 
    2b30:	4b0e      	ldr	r3, [pc, #56]	; (2b6c <detect_fall_detection+0x40>)
    2b32:	681b      	ldr	r3, [r3, #0]
    2b34:	2b2c      	cmp	r3, #44	; 0x2c
    2b36:	d80f      	bhi.n	2b58 <detect_fall_detection+0x2c>
    2b38:	4b0d      	ldr	r3, [pc, #52]	; (2b70 <detect_fall_detection+0x44>)
    2b3a:	681b      	ldr	r3, [r3, #0]
    2b3c:	2b2c      	cmp	r3, #44	; 0x2c
    2b3e:	d80b      	bhi.n	2b58 <detect_fall_detection+0x2c>
    2b40:	4b0c      	ldr	r3, [pc, #48]	; (2b74 <detect_fall_detection+0x48>)
    2b42:	681b      	ldr	r3, [r3, #0]
    2b44:	2b2c      	cmp	r3, #44	; 0x2c
    2b46:	d807      	bhi.n	2b58 <detect_fall_detection+0x2c>
    2b48:	4b0b      	ldr	r3, [pc, #44]	; (2b78 <detect_fall_detection+0x4c>)
    2b4a:	881b      	ldrh	r3, [r3, #0]
    2b4c:	2b00      	cmp	r3, #0
    2b4e:	d103      	bne.n	2b58 <detect_fall_detection+0x2c>
    fall_input=1;
    2b50:	4b0a      	ldr	r3, [pc, #40]	; (2b7c <detect_fall_detection+0x50>)
    2b52:	2201      	movs	r2, #1
    2b54:	701a      	strb	r2, [r3, #0]
    2b56:	e005      	b.n	2b64 <detect_fall_detection+0x38>
   else 
   {
     fall_input = 0;
    2b58:	4b08      	ldr	r3, [pc, #32]	; (2b7c <detect_fall_detection+0x50>)
    2b5a:	2200      	movs	r2, #0
    2b5c:	701a      	strb	r2, [r3, #0]
     ti_fall = 10;
    2b5e:	4b06      	ldr	r3, [pc, #24]	; (2b78 <detect_fall_detection+0x4c>)
    2b60:	220a      	movs	r2, #10
    2b62:	801a      	strh	r2, [r3, #0]
    }
   
}
    2b64:	46c0      	nop			; (mov r8, r8)
    2b66:	46bd      	mov	sp, r7
    2b68:	bd80      	pop	{r7, pc}
    2b6a:	46c0      	nop			; (mov r8, r8)
    2b6c:	1ffff5ac 	.word	0x1ffff5ac
    2b70:	1ffff538 	.word	0x1ffff538
    2b74:	1ffff52c 	.word	0x1ffff52c
    2b78:	1ffff5ca 	.word	0x1ffff5ca
    2b7c:	1ffff53c 	.word	0x1ffff53c

00002b80 <median>:
 * \return   a median value of the last 8 samples
 * \todo
 * \warning
 */ 
int median(int new_value, struct tipo_mediana *medicion)
{
    2b80:	b580      	push	{r7, lr}
    2b82:	b08e      	sub	sp, #56	; 0x38
    2b84:	af00      	add	r7, sp, #0
    2b86:	6078      	str	r0, [r7, #4]
    2b88:	6039      	str	r1, [r7, #0]
	int buffer_ord[NUM_MUESTRAS_MEDIANA];
  	int i;
  	int temp1;
  	int bandera;
  
  	medicion->ap_muestras++;
    2b8a:	683b      	ldr	r3, [r7, #0]
    2b8c:	781b      	ldrb	r3, [r3, #0]
    2b8e:	3301      	adds	r3, #1
    2b90:	b2da      	uxtb	r2, r3
    2b92:	683b      	ldr	r3, [r7, #0]
    2b94:	701a      	strb	r2, [r3, #0]
  	medicion->ap_muestras &= 0x7;  //de 0 a 7  
    2b96:	683b      	ldr	r3, [r7, #0]
    2b98:	781b      	ldrb	r3, [r3, #0]
    2b9a:	2207      	movs	r2, #7
    2b9c:	4013      	ands	r3, r2
    2b9e:	b2da      	uxtb	r2, r3
    2ba0:	683b      	ldr	r3, [r7, #0]
    2ba2:	701a      	strb	r2, [r3, #0]
  	medicion->buffer_muestras[medicion->ap_muestras]=new_value;
    2ba4:	683b      	ldr	r3, [r7, #0]
    2ba6:	781b      	ldrb	r3, [r3, #0]
    2ba8:	683a      	ldr	r2, [r7, #0]
    2baa:	009b      	lsls	r3, r3, #2
    2bac:	18d3      	adds	r3, r2, r3
    2bae:	3304      	adds	r3, #4
    2bb0:	687a      	ldr	r2, [r7, #4]
    2bb2:	601a      	str	r2, [r3, #0]
	//copia el buffer en temporal  
  	for(i=0;i<8;i++) buffer_ord[i]=medicion->buffer_muestras[i];  	
    2bb4:	2300      	movs	r3, #0
    2bb6:	637b      	str	r3, [r7, #52]	; 0x34
    2bb8:	e00d      	b.n	2bd6 <median+0x56>
    2bba:	683a      	ldr	r2, [r7, #0]
    2bbc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2bbe:	009b      	lsls	r3, r3, #2
    2bc0:	18d3      	adds	r3, r2, r3
    2bc2:	3304      	adds	r3, #4
    2bc4:	6819      	ldr	r1, [r3, #0]
    2bc6:	230c      	movs	r3, #12
    2bc8:	18fb      	adds	r3, r7, r3
    2bca:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    2bcc:	0092      	lsls	r2, r2, #2
    2bce:	50d1      	str	r1, [r2, r3]
    2bd0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2bd2:	3301      	adds	r3, #1
    2bd4:	637b      	str	r3, [r7, #52]	; 0x34
    2bd6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2bd8:	2b07      	cmp	r3, #7
    2bda:	ddee      	ble.n	2bba <median+0x3a>
  	//ordena el buffer temporal  
  	do
  	{
   		bandera=0; 
    2bdc:	2300      	movs	r3, #0
    2bde:	633b      	str	r3, [r7, #48]	; 0x30
   		for (i=0;i<7;i++)  
    2be0:	2300      	movs	r3, #0
    2be2:	637b      	str	r3, [r7, #52]	; 0x34
    2be4:	e029      	b.n	2c3a <median+0xba>
   		{
    		if (buffer_ord[i] > buffer_ord[i+1])
    2be6:	230c      	movs	r3, #12
    2be8:	18fb      	adds	r3, r7, r3
    2bea:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    2bec:	0092      	lsls	r2, r2, #2
    2bee:	58d2      	ldr	r2, [r2, r3]
    2bf0:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2bf2:	1c59      	adds	r1, r3, #1
    2bf4:	230c      	movs	r3, #12
    2bf6:	18fb      	adds	r3, r7, r3
    2bf8:	0089      	lsls	r1, r1, #2
    2bfa:	58cb      	ldr	r3, [r1, r3]
    2bfc:	429a      	cmp	r2, r3
    2bfe:	dd19      	ble.n	2c34 <median+0xb4>
     		{
      			temp1 = buffer_ord[i];
    2c00:	230c      	movs	r3, #12
    2c02:	18fb      	adds	r3, r7, r3
    2c04:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    2c06:	0092      	lsls	r2, r2, #2
    2c08:	58d3      	ldr	r3, [r2, r3]
    2c0a:	62fb      	str	r3, [r7, #44]	; 0x2c
      			buffer_ord[i] = buffer_ord[i+1];
    2c0c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2c0e:	1c5a      	adds	r2, r3, #1
    2c10:	230c      	movs	r3, #12
    2c12:	18fb      	adds	r3, r7, r3
    2c14:	0092      	lsls	r2, r2, #2
    2c16:	58d1      	ldr	r1, [r2, r3]
    2c18:	230c      	movs	r3, #12
    2c1a:	18fb      	adds	r3, r7, r3
    2c1c:	6b7a      	ldr	r2, [r7, #52]	; 0x34
    2c1e:	0092      	lsls	r2, r2, #2
    2c20:	50d1      	str	r1, [r2, r3]
      			buffer_ord[i+1] = temp1;
    2c22:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2c24:	1c5a      	adds	r2, r3, #1
    2c26:	230c      	movs	r3, #12
    2c28:	18fb      	adds	r3, r7, r3
    2c2a:	0092      	lsls	r2, r2, #2
    2c2c:	6af9      	ldr	r1, [r7, #44]	; 0x2c
    2c2e:	50d1      	str	r1, [r2, r3]
      			bandera=1;  	
    2c30:	2301      	movs	r3, #1
    2c32:	633b      	str	r3, [r7, #48]	; 0x30
   		for (i=0;i<7;i++)  
    2c34:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2c36:	3301      	adds	r3, #1
    2c38:	637b      	str	r3, [r7, #52]	; 0x34
    2c3a:	6b7b      	ldr	r3, [r7, #52]	; 0x34
    2c3c:	2b06      	cmp	r3, #6
    2c3e:	ddd2      	ble.n	2be6 <median+0x66>
     		}	
    	}
  	}
  	
  	while (bandera);   
    2c40:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    2c42:	2b00      	cmp	r3, #0
    2c44:	d1ca      	bne.n	2bdc <median+0x5c>
  	//temp1= (buffer_ord[3] + buffer_ord[4])/2;
       	temp1= buffer_ord[3];
    2c46:	230c      	movs	r3, #12
    2c48:	18fb      	adds	r3, r7, r3
    2c4a:	68db      	ldr	r3, [r3, #12]
    2c4c:	62fb      	str	r3, [r7, #44]	; 0x2c
  	return temp1;
    2c4e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
    2c50:	0018      	movs	r0, r3
    2c52:	46bd      	mov	sp, r7
    2c54:	b00e      	add	sp, #56	; 0x38
    2c56:	bd80      	pop	{r7, pc}

00002c58 <sqrt_16>:
 * \return  (unsigend long)square root
 * \todo    
 * \warning
 */   
unsigned int sqrt_16(unsigned int value)
  {
    2c58:	b580      	push	{r7, lr}
    2c5a:	b086      	sub	sp, #24
    2c5c:	af00      	add	r7, sp, #0
    2c5e:	6078      	str	r0, [r7, #4]
  unsigned char num_iter=0;
    2c60:	2317      	movs	r3, #23
    2c62:	18fb      	adds	r3, r7, r3
    2c64:	2200      	movs	r2, #0
    2c66:	701a      	strb	r2, [r3, #0]
  unsigned long result = 1000;
    2c68:	23fa      	movs	r3, #250	; 0xfa
    2c6a:	009b      	lsls	r3, r3, #2
    2c6c:	613b      	str	r3, [r7, #16]
  unsigned long last_result = 1000;
    2c6e:	23fa      	movs	r3, #250	; 0xfa
    2c70:	009b      	lsls	r3, r3, #2
    2c72:	60fb      	str	r3, [r7, #12]
   do
    {
     last_result = result;
    2c74:	693b      	ldr	r3, [r7, #16]
    2c76:	60fb      	str	r3, [r7, #12]
     result = (result + value/result)/2;
    2c78:	6939      	ldr	r1, [r7, #16]
    2c7a:	6878      	ldr	r0, [r7, #4]
    2c7c:	f7fd fbec 	bl	458 <__udivsi3>
    2c80:	0003      	movs	r3, r0
    2c82:	001a      	movs	r2, r3
    2c84:	693b      	ldr	r3, [r7, #16]
    2c86:	18d3      	adds	r3, r2, r3
    2c88:	085b      	lsrs	r3, r3, #1
    2c8a:	613b      	str	r3, [r7, #16]
    }
   while (num_iter++<7 && last_result!= result);
    2c8c:	2317      	movs	r3, #23
    2c8e:	18fb      	adds	r3, r7, r3
    2c90:	781b      	ldrb	r3, [r3, #0]
    2c92:	2217      	movs	r2, #23
    2c94:	18ba      	adds	r2, r7, r2
    2c96:	1c59      	adds	r1, r3, #1
    2c98:	7011      	strb	r1, [r2, #0]
    2c9a:	2b06      	cmp	r3, #6
    2c9c:	d803      	bhi.n	2ca6 <sqrt_16+0x4e>
    2c9e:	68fa      	ldr	r2, [r7, #12]
    2ca0:	693b      	ldr	r3, [r7, #16]
    2ca2:	429a      	cmp	r2, r3
    2ca4:	d1e6      	bne.n	2c74 <sqrt_16+0x1c>
   return (unsigned int)result;
    2ca6:	693b      	ldr	r3, [r7, #16]
  }
    2ca8:	0018      	movs	r0, r3
    2caa:	46bd      	mov	sp, r7
    2cac:	b006      	add	sp, #24
    2cae:	bd80      	pop	{r7, pc}

00002cb0 <vfnInitUSBClock>:

void vfnfll_init (void);
void fll_init (void);

void vfnInitUSBClock (uint8 u8ClkOption)
{
    2cb0:	b580      	push	{r7, lr}
    2cb2:	b082      	sub	sp, #8
    2cb4:	af00      	add	r7, sp, #0
    2cb6:	0002      	movs	r2, r0
    2cb8:	1dfb      	adds	r3, r7, #7
    2cba:	701a      	strb	r2, [r3, #0]

  switch (u8ClkOption)
    2cbc:	1dfb      	adds	r3, r7, #7
    2cbe:	781b      	ldrb	r3, [r3, #0]
    2cc0:	2b01      	cmp	r3, #1
    2cc2:	d00d      	beq.n	2ce0 <vfnInitUSBClock+0x30>
    2cc4:	2b02      	cmp	r3, #2
    2cc6:	d01f      	beq.n	2d08 <vfnInitUSBClock+0x58>
    2cc8:	2b00      	cmp	r3, #0
    2cca:	d132      	bne.n	2d32 <vfnInitUSBClock+0x82>
  {
    case MCGPLL0:
    {
      SIM_SOPT2 |= SIM_SOPT2_PLLFLLSEL_MASK     /** PLL reference */   
    2ccc:	491f      	ldr	r1, [pc, #124]	; (2d4c <vfnInitUSBClock+0x9c>)
    2cce:	4a1f      	ldr	r2, [pc, #124]	; (2d4c <vfnInitUSBClock+0x9c>)
    2cd0:	4b1f      	ldr	r3, [pc, #124]	; (2d50 <vfnInitUSBClock+0xa0>)
    2cd2:	58d3      	ldr	r3, [r2, r3]
    2cd4:	22a0      	movs	r2, #160	; 0xa0
    2cd6:	02d2      	lsls	r2, r2, #11
    2cd8:	4313      	orrs	r3, r2
    2cda:	4a1d      	ldr	r2, [pc, #116]	; (2d50 <vfnInitUSBClock+0xa0>)
    2cdc:	508b      	str	r3, [r1, r2]
                |  SIM_SOPT2_USBSRC_MASK;       /** USB fractional divider like USB reference clock */  
      /** There are no clock dividers for the L2K PLL */
      break;     
    2cde:	e028      	b.n	2d32 <vfnInitUSBClock+0x82>
    
  
    case MCGFLL:
    {
        /** Configure FLL to generate a 48MHz core clock */
       fll_init();                            
    2ce0:	f000 f842 	bl	2d68 <fll_init>
          
        SIM_SOPT2 &= ~SIM_SOPT2_PLLFLLSEL_MASK;       /** FLL reference */   
    2ce4:	4919      	ldr	r1, [pc, #100]	; (2d4c <vfnInitUSBClock+0x9c>)
    2ce6:	4a19      	ldr	r2, [pc, #100]	; (2d4c <vfnInitUSBClock+0x9c>)
    2ce8:	4b19      	ldr	r3, [pc, #100]	; (2d50 <vfnInitUSBClock+0xa0>)
    2cea:	58d3      	ldr	r3, [r2, r3]
    2cec:	4a19      	ldr	r2, [pc, #100]	; (2d54 <vfnInitUSBClock+0xa4>)
    2cee:	4013      	ands	r3, r2
    2cf0:	4a17      	ldr	r2, [pc, #92]	; (2d50 <vfnInitUSBClock+0xa0>)
    2cf2:	508b      	str	r3, [r1, r2]
        SIM_SOPT2 |=  SIM_SOPT2_USBSRC_MASK;          /** USB fractional divider like USB reference clock */ 
    2cf4:	4915      	ldr	r1, [pc, #84]	; (2d4c <vfnInitUSBClock+0x9c>)
    2cf6:	4a15      	ldr	r2, [pc, #84]	; (2d4c <vfnInitUSBClock+0x9c>)
    2cf8:	4b15      	ldr	r3, [pc, #84]	; (2d50 <vfnInitUSBClock+0xa0>)
    2cfa:	58d3      	ldr	r3, [r2, r3]
    2cfc:	2280      	movs	r2, #128	; 0x80
    2cfe:	02d2      	lsls	r2, r2, #11
    2d00:	4313      	orrs	r3, r2
    2d02:	4a13      	ldr	r2, [pc, #76]	; (2d50 <vfnInitUSBClock+0xa0>)
    2d04:	508b      	str	r3, [r1, r2]
        break;
    2d06:	e014      	b.n	2d32 <vfnInitUSBClock+0x82>
    }
    
    case CLKIN:
    {
      SIM_SOPT2 &= (uint32)(~SIM_SOPT2_USBSRC_MASK);    /** PTA5 selected as USBFS CLK source */ 
    2d08:	4910      	ldr	r1, [pc, #64]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d0a:	4a10      	ldr	r2, [pc, #64]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d0c:	4b10      	ldr	r3, [pc, #64]	; (2d50 <vfnInitUSBClock+0xa0>)
    2d0e:	58d3      	ldr	r3, [r2, r3]
    2d10:	4a11      	ldr	r2, [pc, #68]	; (2d58 <vfnInitUSBClock+0xa8>)
    2d12:	4013      	ands	r3, r2
    2d14:	4a0e      	ldr	r2, [pc, #56]	; (2d50 <vfnInitUSBClock+0xa0>)
    2d16:	508b      	str	r3, [r1, r2]
      FLAG_SET(SIM_SCGC5_PORTA_SHIFT,SIM_SCGC5); 
    2d18:	490c      	ldr	r1, [pc, #48]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d1a:	4a0c      	ldr	r2, [pc, #48]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d1c:	4b0f      	ldr	r3, [pc, #60]	; (2d5c <vfnInitUSBClock+0xac>)
    2d1e:	58d3      	ldr	r3, [r2, r3]
    2d20:	2280      	movs	r2, #128	; 0x80
    2d22:	0092      	lsls	r2, r2, #2
    2d24:	4313      	orrs	r3, r2
    2d26:	4a0d      	ldr	r2, [pc, #52]	; (2d5c <vfnInitUSBClock+0xac>)
    2d28:	508b      	str	r3, [r1, r2]
      PORTA_PCR5=(0|PORT_PCR_MUX(2));                   // Enabling PTA5 as CLK input    
    2d2a:	4b0d      	ldr	r3, [pc, #52]	; (2d60 <vfnInitUSBClock+0xb0>)
    2d2c:	2280      	movs	r2, #128	; 0x80
    2d2e:	0092      	lsls	r2, r2, #2
    2d30:	615a      	str	r2, [r3, #20]
    }
  }
  
  SIM_SCGC4|=(SIM_SCGC4_USBOTG_MASK);             // USB Clock Gating
    2d32:	4906      	ldr	r1, [pc, #24]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d34:	4a05      	ldr	r2, [pc, #20]	; (2d4c <vfnInitUSBClock+0x9c>)
    2d36:	4b0b      	ldr	r3, [pc, #44]	; (2d64 <vfnInitUSBClock+0xb4>)
    2d38:	58d3      	ldr	r3, [r2, r3]
    2d3a:	2280      	movs	r2, #128	; 0x80
    2d3c:	02d2      	lsls	r2, r2, #11
    2d3e:	4313      	orrs	r3, r2
    2d40:	4a08      	ldr	r2, [pc, #32]	; (2d64 <vfnInitUSBClock+0xb4>)
    2d42:	508b      	str	r3, [r1, r2]
}
    2d44:	46c0      	nop			; (mov r8, r8)
    2d46:	46bd      	mov	sp, r7
    2d48:	b002      	add	sp, #8
    2d4a:	bd80      	pop	{r7, pc}
    2d4c:	40047000 	.word	0x40047000
    2d50:	00001004 	.word	0x00001004
    2d54:	fffeffff 	.word	0xfffeffff
    2d58:	fffbffff 	.word	0xfffbffff
    2d5c:	00001038 	.word	0x00001038
    2d60:	40049000 	.word	0x40049000
    2d64:	00001034 	.word	0x00001034

00002d68 <fll_init>:



void fll_init(void)
{
    2d68:	b580      	push	{r7, lr}
    2d6a:	af00      	add	r7, sp, #0
  
}
    2d6c:	46c0      	nop			; (mov r8, r8)
    2d6e:	46bd      	mov	sp, r7
    2d70:	bd80      	pop	{r7, pc}
	...

00002d74 <gpio_init>:


*/

void  gpio_init(void)
{
    2d74:	b580      	push	{r7, lr}
    2d76:	af00      	add	r7, sp, #0
 PORTC_PCR8 = PCR_OUTPUT_CONFIG;
 GPIOC_PDDR |= (1<<8) | (1<<7);
 */
  
#ifdef LED1
  LED1_PCR = PCR_OUTPUT_CONFIG;
    2d78:	4b1b      	ldr	r3, [pc, #108]	; (2de8 <gpio_init+0x74>)
    2d7a:	22a0      	movs	r2, #160	; 0xa0
    2d7c:	0052      	lsls	r2, r2, #1
    2d7e:	649a      	str	r2, [r3, #72]	; 0x48
  LED1_OFF;
    2d80:	4b1a      	ldr	r3, [pc, #104]	; (2dec <gpio_init+0x78>)
    2d82:	4a1a      	ldr	r2, [pc, #104]	; (2dec <gpio_init+0x78>)
    2d84:	6852      	ldr	r2, [r2, #4]
    2d86:	2180      	movs	r1, #128	; 0x80
    2d88:	02c9      	lsls	r1, r1, #11
    2d8a:	430a      	orrs	r2, r1
    2d8c:	605a      	str	r2, [r3, #4]
  LED1_OUTPUT_EN;
    2d8e:	4b17      	ldr	r3, [pc, #92]	; (2dec <gpio_init+0x78>)
    2d90:	4a16      	ldr	r2, [pc, #88]	; (2dec <gpio_init+0x78>)
    2d92:	6952      	ldr	r2, [r2, #20]
    2d94:	2180      	movs	r1, #128	; 0x80
    2d96:	02c9      	lsls	r1, r1, #11
    2d98:	430a      	orrs	r2, r1
    2d9a:	615a      	str	r2, [r3, #20]
#endif
    
#ifdef LED2
  LED2_PCR = PCR_OUTPUT_CONFIG;
    2d9c:	4b12      	ldr	r3, [pc, #72]	; (2de8 <gpio_init+0x74>)
    2d9e:	22a0      	movs	r2, #160	; 0xa0
    2da0:	0052      	lsls	r2, r2, #1
    2da2:	64da      	str	r2, [r3, #76]	; 0x4c
  LED2_OFF;
    2da4:	4b11      	ldr	r3, [pc, #68]	; (2dec <gpio_init+0x78>)
    2da6:	4a11      	ldr	r2, [pc, #68]	; (2dec <gpio_init+0x78>)
    2da8:	6852      	ldr	r2, [r2, #4]
    2daa:	2180      	movs	r1, #128	; 0x80
    2dac:	0309      	lsls	r1, r1, #12
    2dae:	430a      	orrs	r2, r1
    2db0:	605a      	str	r2, [r3, #4]
  LED2_OUTPUT_EN;
    2db2:	4b0e      	ldr	r3, [pc, #56]	; (2dec <gpio_init+0x78>)
    2db4:	4a0d      	ldr	r2, [pc, #52]	; (2dec <gpio_init+0x78>)
    2db6:	6952      	ldr	r2, [r2, #20]
    2db8:	2180      	movs	r1, #128	; 0x80
    2dba:	0309      	lsls	r1, r1, #12
    2dbc:	430a      	orrs	r2, r1
    2dbe:	615a      	str	r2, [r3, #20]
#endif

#ifdef LED3
  LED3_PCR = PCR_OUTPUT_CONFIG;
    2dc0:	4b0b      	ldr	r3, [pc, #44]	; (2df0 <gpio_init+0x7c>)
    2dc2:	22a0      	movs	r2, #160	; 0xa0
    2dc4:	0052      	lsls	r2, r2, #1
    2dc6:	605a      	str	r2, [r3, #4]
  LED3_OFF;
    2dc8:	4b0a      	ldr	r3, [pc, #40]	; (2df4 <gpio_init+0x80>)
    2dca:	4a0a      	ldr	r2, [pc, #40]	; (2df4 <gpio_init+0x80>)
    2dcc:	6852      	ldr	r2, [r2, #4]
    2dce:	2102      	movs	r1, #2
    2dd0:	430a      	orrs	r2, r1
    2dd2:	605a      	str	r2, [r3, #4]
  LED3_OUTPUT_EN;
    2dd4:	4b07      	ldr	r3, [pc, #28]	; (2df4 <gpio_init+0x80>)
    2dd6:	4a07      	ldr	r2, [pc, #28]	; (2df4 <gpio_init+0x80>)
    2dd8:	6952      	ldr	r2, [r2, #20]
    2dda:	2102      	movs	r1, #2
    2ddc:	430a      	orrs	r2, r1
    2dde:	615a      	str	r2, [r3, #20]
   SW2_INPUT_EN;
#endif

   
 
}
    2de0:	46c0      	nop			; (mov r8, r8)
    2de2:	46bd      	mov	sp, r7
    2de4:	bd80      	pop	{r7, pc}
    2de6:	46c0      	nop			; (mov r8, r8)
    2de8:	4004a000 	.word	0x4004a000
    2dec:	400ff040 	.word	0x400ff040
    2df0:	4004c000 	.word	0x4004c000
    2df4:	400ff0c0 	.word	0x400ff0c0

00002df8 <Pit_init>:
 * \author   b01252
 * \param    none
 * \return   none
 */  
void Pit_init(void)
{
    2df8:	b580      	push	{r7, lr}
    2dfa:	af00      	add	r7, sp, #0
    SIM_SCGC6 |= SIM_SCGC6_PIT_MASK; // enable PIT module
    2dfc:	4917      	ldr	r1, [pc, #92]	; (2e5c <Pit_init+0x64>)
    2dfe:	4a17      	ldr	r2, [pc, #92]	; (2e5c <Pit_init+0x64>)
    2e00:	4b17      	ldr	r3, [pc, #92]	; (2e60 <Pit_init+0x68>)
    2e02:	58d3      	ldr	r3, [r2, r3]
    2e04:	2280      	movs	r2, #128	; 0x80
    2e06:	0412      	lsls	r2, r2, #16
    2e08:	4313      	orrs	r3, r2
    2e0a:	4a15      	ldr	r2, [pc, #84]	; (2e60 <Pit_init+0x68>)
    2e0c:	508b      	str	r3, [r1, r2]
    
    /* Enable PIT Interrupt in NVIC*/   
    enable_irq(INT_PIT - 16);
    2e0e:	2016      	movs	r0, #22
    2e10:	f7fe f8ec 	bl	fec <enable_irq>
       
    PIT_MCR = 0x00;  // MDIS = 0  enables timer
    2e14:	4b13      	ldr	r3, [pc, #76]	; (2e64 <Pit_init+0x6c>)
    2e16:	2200      	movs	r2, #0
    2e18:	601a      	str	r2, [r3, #0]
    PIT_TCTRL1 = 0x00; // disable PIT0
    2e1a:	4a12      	ldr	r2, [pc, #72]	; (2e64 <Pit_init+0x6c>)
    2e1c:	238c      	movs	r3, #140	; 0x8c
    2e1e:	005b      	lsls	r3, r3, #1
    2e20:	2100      	movs	r1, #0
    2e22:	50d1      	str	r1, [r2, r3]
    PIT_LDVAL1 = 48000; // 
    2e24:	4a0f      	ldr	r2, [pc, #60]	; (2e64 <Pit_init+0x6c>)
    2e26:	2388      	movs	r3, #136	; 0x88
    2e28:	005b      	lsls	r3, r3, #1
    2e2a:	490f      	ldr	r1, [pc, #60]	; (2e68 <Pit_init+0x70>)
    2e2c:	50d1      	str	r1, [r2, r3]
    PIT_TCTRL1 = PIT_TCTRL_TIE_MASK; // enable PIT0 and interrupt
    2e2e:	4a0d      	ldr	r2, [pc, #52]	; (2e64 <Pit_init+0x6c>)
    2e30:	238c      	movs	r3, #140	; 0x8c
    2e32:	005b      	lsls	r3, r3, #1
    2e34:	2102      	movs	r1, #2
    2e36:	50d1      	str	r1, [r2, r3]
    PIT_TFLG1 = 0x01; // clear flag
    2e38:	4a0a      	ldr	r2, [pc, #40]	; (2e64 <Pit_init+0x6c>)
    2e3a:	238e      	movs	r3, #142	; 0x8e
    2e3c:	005b      	lsls	r3, r3, #1
    2e3e:	2101      	movs	r1, #1
    2e40:	50d1      	str	r1, [r2, r3]
    PIT_TCTRL1 |= PIT_TCTRL_TEN_MASK;
    2e42:	4908      	ldr	r1, [pc, #32]	; (2e64 <Pit_init+0x6c>)
    2e44:	4a07      	ldr	r2, [pc, #28]	; (2e64 <Pit_init+0x6c>)
    2e46:	238c      	movs	r3, #140	; 0x8c
    2e48:	005b      	lsls	r3, r3, #1
    2e4a:	58d3      	ldr	r3, [r2, r3]
    2e4c:	2201      	movs	r2, #1
    2e4e:	431a      	orrs	r2, r3
    2e50:	238c      	movs	r3, #140	; 0x8c
    2e52:	005b      	lsls	r3, r3, #1
    2e54:	50ca      	str	r2, [r1, r3]
   
}
    2e56:	46c0      	nop			; (mov r8, r8)
    2e58:	46bd      	mov	sp, r7
    2e5a:	bd80      	pop	{r7, pc}
    2e5c:	40047000 	.word	0x40047000
    2e60:	0000103c 	.word	0x0000103c
    2e64:	40037000 	.word	0x40037000
    2e68:	0000bb80 	.word	0x0000bb80

00002e6c <Pit1_isrv>:
 * \param    none
 * \return   none
 */  

void Pit1_isrv(void)
{  
    2e6c:	b580      	push	{r7, lr}
    2e6e:	af00      	add	r7, sp, #0
    static char count_mseg=125;
    PIT_TFLG1 = 0x01; // clear flag
    2e70:	4a21      	ldr	r2, [pc, #132]	; (2ef8 <Pit1_isrv+0x8c>)
    2e72:	238e      	movs	r3, #142	; 0x8e
    2e74:	005b      	lsls	r3, r3, #1
    2e76:	2101      	movs	r1, #1
    2e78:	50d1      	str	r1, [r2, r3]
    if (count_mseg)count_mseg--;
    2e7a:	4b20      	ldr	r3, [pc, #128]	; (2efc <Pit1_isrv+0x90>)
    2e7c:	781b      	ldrb	r3, [r3, #0]
    2e7e:	2b00      	cmp	r3, #0
    2e80:	d005      	beq.n	2e8e <Pit1_isrv+0x22>
    2e82:	4b1e      	ldr	r3, [pc, #120]	; (2efc <Pit1_isrv+0x90>)
    2e84:	781b      	ldrb	r3, [r3, #0]
    2e86:	3b01      	subs	r3, #1
    2e88:	b2da      	uxtb	r2, r3
    2e8a:	4b1c      	ldr	r3, [pc, #112]	; (2efc <Pit1_isrv+0x90>)
    2e8c:	701a      	strb	r2, [r3, #0]
    if (ti_accel_sampling) ti_accel_sampling--;
    2e8e:	4b1c      	ldr	r3, [pc, #112]	; (2f00 <Pit1_isrv+0x94>)
    2e90:	881b      	ldrh	r3, [r3, #0]
    2e92:	2b00      	cmp	r3, #0
    2e94:	d006      	beq.n	2ea4 <Pit1_isrv+0x38>
    2e96:	4b1a      	ldr	r3, [pc, #104]	; (2f00 <Pit1_isrv+0x94>)
    2e98:	881b      	ldrh	r3, [r3, #0]
    2e9a:	3b01      	subs	r3, #1
    2e9c:	b29a      	uxth	r2, r3
    2e9e:	4b18      	ldr	r3, [pc, #96]	; (2f00 <Pit1_isrv+0x94>)
    2ea0:	801a      	strh	r2, [r3, #0]
    2ea2:	e008      	b.n	2eb6 <Pit1_isrv+0x4a>
    else
    {
     count_mseg=125;
    2ea4:	4b15      	ldr	r3, [pc, #84]	; (2efc <Pit1_isrv+0x90>)
    2ea6:	227d      	movs	r2, #125	; 0x7d
    2ea8:	701a      	strb	r2, [r3, #0]
     base_time125m++; 
    2eaa:	4b16      	ldr	r3, [pc, #88]	; (2f04 <Pit1_isrv+0x98>)
    2eac:	881b      	ldrh	r3, [r3, #0]
    2eae:	3301      	adds	r3, #1
    2eb0:	b29a      	uxth	r2, r3
    2eb2:	4b14      	ldr	r3, [pc, #80]	; (2f04 <Pit1_isrv+0x98>)
    2eb4:	801a      	strh	r2, [r3, #0]
    }
   if (ti_task) ti_task--;
    2eb6:	4b14      	ldr	r3, [pc, #80]	; (2f08 <Pit1_isrv+0x9c>)
    2eb8:	881b      	ldrh	r3, [r3, #0]
    2eba:	2b00      	cmp	r3, #0
    2ebc:	d005      	beq.n	2eca <Pit1_isrv+0x5e>
    2ebe:	4b12      	ldr	r3, [pc, #72]	; (2f08 <Pit1_isrv+0x9c>)
    2ec0:	881b      	ldrh	r3, [r3, #0]
    2ec2:	3b01      	subs	r3, #1
    2ec4:	b29a      	uxth	r2, r3
    2ec6:	4b10      	ldr	r3, [pc, #64]	; (2f08 <Pit1_isrv+0x9c>)
    2ec8:	801a      	strh	r2, [r3, #0]
   if (ti_delay) ti_delay--;
    2eca:	4b10      	ldr	r3, [pc, #64]	; (2f0c <Pit1_isrv+0xa0>)
    2ecc:	881b      	ldrh	r3, [r3, #0]
    2ece:	2b00      	cmp	r3, #0
    2ed0:	d005      	beq.n	2ede <Pit1_isrv+0x72>
    2ed2:	4b0e      	ldr	r3, [pc, #56]	; (2f0c <Pit1_isrv+0xa0>)
    2ed4:	881b      	ldrh	r3, [r3, #0]
    2ed6:	3b01      	subs	r3, #1
    2ed8:	b29a      	uxth	r2, r3
    2eda:	4b0c      	ldr	r3, [pc, #48]	; (2f0c <Pit1_isrv+0xa0>)
    2edc:	801a      	strh	r2, [r3, #0]
   if (ti_print) ti_print--;
    2ede:	4b0c      	ldr	r3, [pc, #48]	; (2f10 <Pit1_isrv+0xa4>)
    2ee0:	881b      	ldrh	r3, [r3, #0]
    2ee2:	2b00      	cmp	r3, #0
    2ee4:	d005      	beq.n	2ef2 <Pit1_isrv+0x86>
    2ee6:	4b0a      	ldr	r3, [pc, #40]	; (2f10 <Pit1_isrv+0xa4>)
    2ee8:	881b      	ldrh	r3, [r3, #0]
    2eea:	3b01      	subs	r3, #1
    2eec:	b29a      	uxth	r2, r3
    2eee:	4b08      	ldr	r3, [pc, #32]	; (2f10 <Pit1_isrv+0xa4>)
    2ef0:	801a      	strh	r2, [r3, #0]
   //if (ti_console) ti_console--;
}
    2ef2:	46c0      	nop			; (mov r8, r8)
    2ef4:	46bd      	mov	sp, r7
    2ef6:	bd80      	pop	{r7, pc}
    2ef8:	40037000 	.word	0x40037000
    2efc:	1ffff410 	.word	0x1ffff410
    2f00:	1ffff5e0 	.word	0x1ffff5e0
    2f04:	1ffff5d0 	.word	0x1ffff5d0
    2f08:	1ffff5dc 	.word	0x1ffff5dc
    2f0c:	1ffff5d2 	.word	0x1ffff5d2
    2f10:	1ffff5d6 	.word	0x1ffff5d6

00002f14 <TSI_SelfCalibration>:
uint8 AbsolutePercentegePosition = NO_TOUCH;
uint8 AbsoluteDistancePosition = NO_TOUCH;


void TSI_SelfCalibration(void)
{
    2f14:	b580      	push	{r7, lr}
    2f16:	b082      	sub	sp, #8
    2f18:	af00      	add	r7, sp, #0
  unsigned char cnt;
  unsigned char trigger_backup;
  
  
  TSI0_GENCS |= TSI_GENCS_EOSF_MASK;      // Clear End of Scan Flag 
    2f1a:	4b47      	ldr	r3, [pc, #284]	; (3038 <TSI_SelfCalibration+0x124>)
    2f1c:	4a46      	ldr	r2, [pc, #280]	; (3038 <TSI_SelfCalibration+0x124>)
    2f1e:	6812      	ldr	r2, [r2, #0]
    2f20:	2104      	movs	r1, #4
    2f22:	430a      	orrs	r2, r1
    2f24:	601a      	str	r2, [r3, #0]
  TSI0_GENCS &= ~TSI_GENCS_TSIEN_MASK;    // Disable TSI module
    2f26:	4b44      	ldr	r3, [pc, #272]	; (3038 <TSI_SelfCalibration+0x124>)
    2f28:	4a43      	ldr	r2, [pc, #268]	; (3038 <TSI_SelfCalibration+0x124>)
    2f2a:	6812      	ldr	r2, [r2, #0]
    2f2c:	2180      	movs	r1, #128	; 0x80
    2f2e:	438a      	bics	r2, r1
    2f30:	601a      	str	r2, [r3, #0]
  
  if(TSI0_GENCS & TSI_GENCS_STM_MASK)     // Back-up TSI Trigger mode from Application 
    2f32:	4b41      	ldr	r3, [pc, #260]	; (3038 <TSI_SelfCalibration+0x124>)
    2f34:	681b      	ldr	r3, [r3, #0]
    2f36:	2210      	movs	r2, #16
    2f38:	4013      	ands	r3, r2
    2f3a:	d003      	beq.n	2f44 <TSI_SelfCalibration+0x30>
       trigger_backup = TRUE;
    2f3c:	1dbb      	adds	r3, r7, #6
    2f3e:	2201      	movs	r2, #1
    2f40:	701a      	strb	r2, [r3, #0]
    2f42:	e002      	b.n	2f4a <TSI_SelfCalibration+0x36>
  else
       trigger_backup = FALSE;
    2f44:	1dbb      	adds	r3, r7, #6
    2f46:	2200      	movs	r2, #0
    2f48:	701a      	strb	r2, [r3, #0]
  
  TSI0_GENCS &= ~TSI_GENCS_STM_MASK;      // Use SW trigger
    2f4a:	4b3b      	ldr	r3, [pc, #236]	; (3038 <TSI_SelfCalibration+0x124>)
    2f4c:	4a3a      	ldr	r2, [pc, #232]	; (3038 <TSI_SelfCalibration+0x124>)
    2f4e:	6812      	ldr	r2, [r2, #0]
    2f50:	2110      	movs	r1, #16
    2f52:	438a      	bics	r2, r1
    2f54:	601a      	str	r2, [r3, #0]
  TSI0_GENCS &= ~TSI_GENCS_TSIIEN_MASK;    // Enable TSI interrupts
    2f56:	4b38      	ldr	r3, [pc, #224]	; (3038 <TSI_SelfCalibration+0x124>)
    2f58:	4a37      	ldr	r2, [pc, #220]	; (3038 <TSI_SelfCalibration+0x124>)
    2f5a:	6812      	ldr	r2, [r2, #0]
    2f5c:	2140      	movs	r1, #64	; 0x40
    2f5e:	438a      	bics	r2, r1
    2f60:	601a      	str	r2, [r3, #0]
  
  TSI0_GENCS |= TSI_GENCS_TSIEN_MASK;     // Enable TSI module
    2f62:	4b35      	ldr	r3, [pc, #212]	; (3038 <TSI_SelfCalibration+0x124>)
    2f64:	4a34      	ldr	r2, [pc, #208]	; (3038 <TSI_SelfCalibration+0x124>)
    2f66:	6812      	ldr	r2, [r2, #0]
    2f68:	2180      	movs	r1, #128	; 0x80
    2f6a:	430a      	orrs	r2, r1
    2f6c:	601a      	str	r2, [r3, #0]
  
  for(cnt=0; cnt < total_electrode; cnt++)  // Get Counts when Electrode not pressed
    2f6e:	1dfb      	adds	r3, r7, #7
    2f70:	2200      	movs	r2, #0
    2f72:	701a      	strb	r2, [r3, #0]
    2f74:	e026      	b.n	2fc4 <TSI_SelfCalibration+0xb0>
  {
    TSI0_DATA = ((elec_array[cnt] << TSI_DATA_TSICH_SHIFT) );
    2f76:	4b30      	ldr	r3, [pc, #192]	; (3038 <TSI_SelfCalibration+0x124>)
    2f78:	1dfa      	adds	r2, r7, #7
    2f7a:	7812      	ldrb	r2, [r2, #0]
    2f7c:	492f      	ldr	r1, [pc, #188]	; (303c <TSI_SelfCalibration+0x128>)
    2f7e:	5c8a      	ldrb	r2, [r1, r2]
    2f80:	0712      	lsls	r2, r2, #28
    2f82:	605a      	str	r2, [r3, #4]
    TSI0_DATA |= TSI_DATA_SWTS_MASK;
    2f84:	4b2c      	ldr	r3, [pc, #176]	; (3038 <TSI_SelfCalibration+0x124>)
    2f86:	4a2c      	ldr	r2, [pc, #176]	; (3038 <TSI_SelfCalibration+0x124>)
    2f88:	6852      	ldr	r2, [r2, #4]
    2f8a:	2180      	movs	r1, #128	; 0x80
    2f8c:	03c9      	lsls	r1, r1, #15
    2f8e:	430a      	orrs	r2, r1
    2f90:	605a      	str	r2, [r3, #4]
    while(!(TSI0_GENCS & TSI_GENCS_EOSF_MASK));
    2f92:	46c0      	nop			; (mov r8, r8)
    2f94:	4b28      	ldr	r3, [pc, #160]	; (3038 <TSI_SelfCalibration+0x124>)
    2f96:	681b      	ldr	r3, [r3, #0]
    2f98:	2204      	movs	r2, #4
    2f9a:	4013      	ands	r3, r2
    2f9c:	d0fa      	beq.n	2f94 <TSI_SelfCalibration+0x80>
    TSI0_GENCS |= TSI_GENCS_EOSF_MASK;
    2f9e:	4b26      	ldr	r3, [pc, #152]	; (3038 <TSI_SelfCalibration+0x124>)
    2fa0:	4a25      	ldr	r2, [pc, #148]	; (3038 <TSI_SelfCalibration+0x124>)
    2fa2:	6812      	ldr	r2, [r2, #0]
    2fa4:	2104      	movs	r1, #4
    2fa6:	430a      	orrs	r2, r1
    2fa8:	601a      	str	r2, [r3, #0]
    gu16Baseline[cnt] = (TSI0_DATA & TSI_DATA_TSICNT_MASK); 
    2faa:	1dfb      	adds	r3, r7, #7
    2fac:	781a      	ldrb	r2, [r3, #0]
    2fae:	4b22      	ldr	r3, [pc, #136]	; (3038 <TSI_SelfCalibration+0x124>)
    2fb0:	685b      	ldr	r3, [r3, #4]
    2fb2:	b299      	uxth	r1, r3
    2fb4:	4b22      	ldr	r3, [pc, #136]	; (3040 <TSI_SelfCalibration+0x12c>)
    2fb6:	0052      	lsls	r2, r2, #1
    2fb8:	52d1      	strh	r1, [r2, r3]
  for(cnt=0; cnt < total_electrode; cnt++)  // Get Counts when Electrode not pressed
    2fba:	1dfb      	adds	r3, r7, #7
    2fbc:	781a      	ldrb	r2, [r3, #0]
    2fbe:	1dfb      	adds	r3, r7, #7
    2fc0:	3201      	adds	r2, #1
    2fc2:	701a      	strb	r2, [r3, #0]
    2fc4:	4b1f      	ldr	r3, [pc, #124]	; (3044 <TSI_SelfCalibration+0x130>)
    2fc6:	781b      	ldrb	r3, [r3, #0]
    2fc8:	1dfa      	adds	r2, r7, #7
    2fca:	7812      	ldrb	r2, [r2, #0]
    2fcc:	429a      	cmp	r2, r3
    2fce:	d3d2      	bcc.n	2f76 <TSI_SelfCalibration+0x62>
  }
  
  TSI0_GENCS &= ~TSI_GENCS_TSIEN_MASK;    // Disable TSI module
    2fd0:	4b19      	ldr	r3, [pc, #100]	; (3038 <TSI_SelfCalibration+0x124>)
    2fd2:	4a19      	ldr	r2, [pc, #100]	; (3038 <TSI_SelfCalibration+0x124>)
    2fd4:	6812      	ldr	r2, [r2, #0]
    2fd6:	2180      	movs	r1, #128	; 0x80
    2fd8:	438a      	bics	r2, r1
    2fda:	601a      	str	r2, [r3, #0]
  TSI0_GENCS |= TSI_GENCS_TSIIEN_MASK;     // Enale TSI interrupt
    2fdc:	4b16      	ldr	r3, [pc, #88]	; (3038 <TSI_SelfCalibration+0x124>)
    2fde:	4a16      	ldr	r2, [pc, #88]	; (3038 <TSI_SelfCalibration+0x124>)
    2fe0:	6812      	ldr	r2, [r2, #0]
    2fe2:	2140      	movs	r1, #64	; 0x40
    2fe4:	430a      	orrs	r2, r1
    2fe6:	601a      	str	r2, [r3, #0]
  if(trigger_backup)                      // Restore trigger mode
    2fe8:	1dbb      	adds	r3, r7, #6
    2fea:	781b      	ldrb	r3, [r3, #0]
    2fec:	2b00      	cmp	r3, #0
    2fee:	d006      	beq.n	2ffe <TSI_SelfCalibration+0xea>
    TSI0_GENCS |= TSI_GENCS_STM_MASK;
    2ff0:	4b11      	ldr	r3, [pc, #68]	; (3038 <TSI_SelfCalibration+0x124>)
    2ff2:	4a11      	ldr	r2, [pc, #68]	; (3038 <TSI_SelfCalibration+0x124>)
    2ff4:	6812      	ldr	r2, [r2, #0]
    2ff6:	2110      	movs	r1, #16
    2ff8:	430a      	orrs	r2, r1
    2ffa:	601a      	str	r2, [r3, #0]
    2ffc:	e005      	b.n	300a <TSI_SelfCalibration+0xf6>
  else
    TSI0_GENCS &= ~TSI_GENCS_STM_MASK;
    2ffe:	4b0e      	ldr	r3, [pc, #56]	; (3038 <TSI_SelfCalibration+0x124>)
    3000:	4a0d      	ldr	r2, [pc, #52]	; (3038 <TSI_SelfCalibration+0x124>)
    3002:	6812      	ldr	r2, [r2, #0]
    3004:	2110      	movs	r1, #16
    3006:	438a      	bics	r2, r1
    3008:	601a      	str	r2, [r3, #0]
  
  TSI0_GENCS |= TSI_GENCS_TSIEN_MASK;     // Enable TSI module
    300a:	4b0b      	ldr	r3, [pc, #44]	; (3038 <TSI_SelfCalibration+0x124>)
    300c:	4a0a      	ldr	r2, [pc, #40]	; (3038 <TSI_SelfCalibration+0x124>)
    300e:	6812      	ldr	r2, [r2, #0]
    3010:	2180      	movs	r1, #128	; 0x80
    3012:	430a      	orrs	r2, r1
    3014:	601a      	str	r2, [r3, #0]
  
   TSI0_DATA = ((elec_array[0]<<TSI_DATA_TSICH_SHIFT) );
    3016:	4b08      	ldr	r3, [pc, #32]	; (3038 <TSI_SelfCalibration+0x124>)
    3018:	4a08      	ldr	r2, [pc, #32]	; (303c <TSI_SelfCalibration+0x128>)
    301a:	7812      	ldrb	r2, [r2, #0]
    301c:	0712      	lsls	r2, r2, #28
    301e:	605a      	str	r2, [r3, #4]
   TSI0_DATA |= TSI_DATA_SWTS_MASK;
    3020:	4b05      	ldr	r3, [pc, #20]	; (3038 <TSI_SelfCalibration+0x124>)
    3022:	4a05      	ldr	r2, [pc, #20]	; (3038 <TSI_SelfCalibration+0x124>)
    3024:	6852      	ldr	r2, [r2, #4]
    3026:	2180      	movs	r1, #128	; 0x80
    3028:	03c9      	lsls	r1, r1, #15
    302a:	430a      	orrs	r2, r1
    302c:	605a      	str	r2, [r3, #4]
  
}
    302e:	46c0      	nop			; (mov r8, r8)
    3030:	46bd      	mov	sp, r7
    3032:	b002      	add	sp, #8
    3034:	bd80      	pop	{r7, pc}
    3036:	46c0      	nop			; (mov r8, r8)
    3038:	40045000 	.word	0x40045000
    303c:	1ffff414 	.word	0x1ffff414
    3040:	1ffff610 	.word	0x1ffff610
    3044:	1ffff411 	.word	0x1ffff411

00003048 <TSI_Init>:

void TSI_Init (void)
{
    3048:	b580      	push	{r7, lr}
    304a:	af00      	add	r7, sp, #0
  SIM_SCGC5 |= SIM_SCGC5_TSI_MASK;  // Enable clock gating for TSI
    304c:	4910      	ldr	r1, [pc, #64]	; (3090 <TSI_Init+0x48>)
    304e:	4a10      	ldr	r2, [pc, #64]	; (3090 <TSI_Init+0x48>)
    3050:	4b10      	ldr	r3, [pc, #64]	; (3094 <TSI_Init+0x4c>)
    3052:	58d3      	ldr	r3, [r2, r3]
    3054:	2220      	movs	r2, #32
    3056:	4313      	orrs	r3, r2
    3058:	4a0e      	ldr	r2, [pc, #56]	; (3094 <TSI_Init+0x4c>)
    305a:	508b      	str	r3, [r1, r2]
  
  /* Enable proper GPIO as TSI channels */
  PORTB_PCR16 = PORT_PCR_MUX(0);   // PTB16 as TSI channel 9
    305c:	4b0e      	ldr	r3, [pc, #56]	; (3098 <TSI_Init+0x50>)
    305e:	2200      	movs	r2, #0
    3060:	641a      	str	r2, [r3, #64]	; 0x40
  PORTB_PCR17 =  PORT_PCR_MUX(0);   // PTB17 as TSI channel 10
    3062:	4b0d      	ldr	r3, [pc, #52]	; (3098 <TSI_Init+0x50>)
    3064:	2200      	movs	r2, #0
    3066:	645a      	str	r2, [r3, #68]	; 0x44

  enable_irq(TSI_irq_no);
    3068:	201a      	movs	r0, #26
    306a:	f7fd ffbf 	bl	fec <enable_irq>
  
  TSI0_GENCS |= (TSI_GENCS_ESOR_MASK
    306e:	4b0b      	ldr	r3, [pc, #44]	; (309c <TSI_Init+0x54>)
    3070:	4a0a      	ldr	r2, [pc, #40]	; (309c <TSI_Init+0x54>)
    3072:	6812      	ldr	r2, [r2, #0]
    3074:	490a      	ldr	r1, [pc, #40]	; (30a0 <TSI_Init+0x58>)
    3076:	430a      	orrs	r2, r1
    3078:	601a      	str	r2, [r3, #0]
                   | TSI_GENCS_TSIIEN_MASK 
                   | TSI_GENCS_STPE_MASK
                   //| TSI_GENCS_STM_MASK     //Trigger for the module 0=Sofware 
                   );
  
  TSI0_GENCS |= TSI_GENCS_TSIEN_MASK; 
    307a:	4b08      	ldr	r3, [pc, #32]	; (309c <TSI_Init+0x54>)
    307c:	4a07      	ldr	r2, [pc, #28]	; (309c <TSI_Init+0x54>)
    307e:	6812      	ldr	r2, [r2, #0]
    3080:	2180      	movs	r1, #128	; 0x80
    3082:	430a      	orrs	r2, r1
    3084:	601a      	str	r2, [r3, #0]
  
  TSI_SelfCalibration();
    3086:	f7ff ff45 	bl	2f14 <TSI_SelfCalibration>
}
    308a:	46c0      	nop			; (mov r8, r8)
    308c:	46bd      	mov	sp, r7
    308e:	bd80      	pop	{r7, pc}
    3090:	40047000 	.word	0x40047000
    3094:	00001038 	.word	0x00001038
    3098:	4004a000 	.word	0x4004a000
    309c:	40045000 	.word	0x40045000
    30a0:	10878b60 	.word	0x10878b60

000030a4 <change_electrode>:


void change_electrode(void)
{
    30a4:	b580      	push	{r7, lr}
    30a6:	b082      	sub	sp, #8
    30a8:	af00      	add	r7, sp, #0
    int16_t u16temp_delta;
    
    gu16TSICount[ongoing_elec] = (TSI0_DATA & TSI_DATA_TSICNT_MASK);          // Save Counts for current electrode
    30aa:	4b2b      	ldr	r3, [pc, #172]	; (3158 <change_electrode+0xb4>)
    30ac:	781b      	ldrb	r3, [r3, #0]
    30ae:	001a      	movs	r2, r3
    30b0:	4b2a      	ldr	r3, [pc, #168]	; (315c <change_electrode+0xb8>)
    30b2:	685b      	ldr	r3, [r3, #4]
    30b4:	b299      	uxth	r1, r3
    30b6:	4b2a      	ldr	r3, [pc, #168]	; (3160 <change_electrode+0xbc>)
    30b8:	0052      	lsls	r2, r2, #1
    30ba:	52d1      	strh	r1, [r2, r3]
    u16temp_delta = gu16TSICount[ongoing_elec] - gu16Baseline[ongoing_elec];  // Obtains Counts Delta from callibration reference
    30bc:	4b26      	ldr	r3, [pc, #152]	; (3158 <change_electrode+0xb4>)
    30be:	781b      	ldrb	r3, [r3, #0]
    30c0:	001a      	movs	r2, r3
    30c2:	4b27      	ldr	r3, [pc, #156]	; (3160 <change_electrode+0xbc>)
    30c4:	0052      	lsls	r2, r2, #1
    30c6:	5ad2      	ldrh	r2, [r2, r3]
    30c8:	4b23      	ldr	r3, [pc, #140]	; (3158 <change_electrode+0xb4>)
    30ca:	781b      	ldrb	r3, [r3, #0]
    30cc:	0019      	movs	r1, r3
    30ce:	4b25      	ldr	r3, [pc, #148]	; (3164 <change_electrode+0xc0>)
    30d0:	0049      	lsls	r1, r1, #1
    30d2:	5acb      	ldrh	r3, [r1, r3]
    30d4:	1ad3      	subs	r3, r2, r3
    30d6:	b29a      	uxth	r2, r3
    30d8:	1dbb      	adds	r3, r7, #6
    30da:	801a      	strh	r2, [r3, #0]
    if( u16temp_delta < 0)
    30dc:	1dbb      	adds	r3, r7, #6
    30de:	2200      	movs	r2, #0
    30e0:	5e9b      	ldrsh	r3, [r3, r2]
    30e2:	2b00      	cmp	r3, #0
    30e4:	da07      	bge.n	30f6 <change_electrode+0x52>
            gu16Delta[ongoing_elec] = 0;
    30e6:	4b1c      	ldr	r3, [pc, #112]	; (3158 <change_electrode+0xb4>)
    30e8:	781b      	ldrb	r3, [r3, #0]
    30ea:	001a      	movs	r2, r3
    30ec:	4b1e      	ldr	r3, [pc, #120]	; (3168 <change_electrode+0xc4>)
    30ee:	0052      	lsls	r2, r2, #1
    30f0:	2100      	movs	r1, #0
    30f2:	52d1      	strh	r1, [r2, r3]
    30f4:	e007      	b.n	3106 <change_electrode+0x62>
    else
            gu16Delta[ongoing_elec] = u16temp_delta;
    30f6:	4b18      	ldr	r3, [pc, #96]	; (3158 <change_electrode+0xb4>)
    30f8:	781b      	ldrb	r3, [r3, #0]
    30fa:	001a      	movs	r2, r3
    30fc:	1dbb      	adds	r3, r7, #6
    30fe:	8819      	ldrh	r1, [r3, #0]
    3100:	4b19      	ldr	r3, [pc, #100]	; (3168 <change_electrode+0xc4>)
    3102:	0052      	lsls	r2, r2, #1
    3104:	52d1      	strh	r1, [r2, r3]
    
    if(total_electrode > 1)  //Change Electrode to Scan
    3106:	4b19      	ldr	r3, [pc, #100]	; (316c <change_electrode+0xc8>)
    3108:	781b      	ldrb	r3, [r3, #0]
    310a:	2b01      	cmp	r3, #1
    310c:	d91f      	bls.n	314e <change_electrode+0xaa>
    {
            if((total_electrode-1) > ongoing_elec) ongoing_elec++;
    310e:	4b17      	ldr	r3, [pc, #92]	; (316c <change_electrode+0xc8>)
    3110:	781b      	ldrb	r3, [r3, #0]
    3112:	3b01      	subs	r3, #1
    3114:	4a10      	ldr	r2, [pc, #64]	; (3158 <change_electrode+0xb4>)
    3116:	7812      	ldrb	r2, [r2, #0]
    3118:	4293      	cmp	r3, r2
    311a:	dd06      	ble.n	312a <change_electrode+0x86>
    311c:	4b0e      	ldr	r3, [pc, #56]	; (3158 <change_electrode+0xb4>)
    311e:	781b      	ldrb	r3, [r3, #0]
    3120:	3301      	adds	r3, #1
    3122:	b2da      	uxtb	r2, r3
    3124:	4b0c      	ldr	r3, [pc, #48]	; (3158 <change_electrode+0xb4>)
    3126:	701a      	strb	r2, [r3, #0]
    3128:	e002      	b.n	3130 <change_electrode+0x8c>
            else   ongoing_elec = 0;
    312a:	4b0b      	ldr	r3, [pc, #44]	; (3158 <change_electrode+0xb4>)
    312c:	2200      	movs	r2, #0
    312e:	701a      	strb	r2, [r3, #0]
            
            TSI0_DATA = ((elec_array[ongoing_elec]<<TSI_DATA_TSICH_SHIFT) );
    3130:	4b0a      	ldr	r3, [pc, #40]	; (315c <change_electrode+0xb8>)
    3132:	4a09      	ldr	r2, [pc, #36]	; (3158 <change_electrode+0xb4>)
    3134:	7812      	ldrb	r2, [r2, #0]
    3136:	0011      	movs	r1, r2
    3138:	4a0d      	ldr	r2, [pc, #52]	; (3170 <change_electrode+0xcc>)
    313a:	5c52      	ldrb	r2, [r2, r1]
    313c:	0712      	lsls	r2, r2, #28
    313e:	605a      	str	r2, [r3, #4]
            TSI0_DATA |= TSI_DATA_SWTS_MASK; 
    3140:	4b06      	ldr	r3, [pc, #24]	; (315c <change_electrode+0xb8>)
    3142:	4a06      	ldr	r2, [pc, #24]	; (315c <change_electrode+0xb8>)
    3144:	6852      	ldr	r2, [r2, #4]
    3146:	2180      	movs	r1, #128	; 0x80
    3148:	03c9      	lsls	r1, r1, #15
    314a:	430a      	orrs	r2, r1
    314c:	605a      	str	r2, [r3, #4]
    }
}
    314e:	46c0      	nop			; (mov r8, r8)
    3150:	46bd      	mov	sp, r7
    3152:	b002      	add	sp, #8
    3154:	bd80      	pop	{r7, pc}
    3156:	46c0      	nop			; (mov r8, r8)
    3158:	1ffff60c 	.word	0x1ffff60c
    315c:	40045000 	.word	0x40045000
    3160:	1ffff5ec 	.word	0x1ffff5ec
    3164:	1ffff610 	.word	0x1ffff610
    3168:	1ffff630 	.word	0x1ffff630
    316c:	1ffff411 	.word	0x1ffff411
    3170:	1ffff414 	.word	0x1ffff414

00003174 <TSI_SliderRead>:
          AbsoluteDistancePosition

*/

void TSI_SliderRead(void )
{
    3174:	b580      	push	{r7, lr}
    3176:	af00      	add	r7, sp, #0
     if(end_flag)
    3178:	4b45      	ldr	r3, [pc, #276]	; (3290 <TSI_SliderRead+0x11c>)
    317a:	781b      	ldrb	r3, [r3, #0]
    317c:	2b00      	cmp	r3, #0
    317e:	d100      	bne.n	3182 <TSI_SliderRead+0xe>
    3180:	e083      	b.n	328a <TSI_SliderRead+0x116>
      {    
       // printf(" Percentage = %d %           Distance = %d mm          \r", AbsolutePercentegePosition, AbsoluteDistancePosition );   
        end_flag = FALSE;
    3182:	4b43      	ldr	r3, [pc, #268]	; (3290 <TSI_SliderRead+0x11c>)
    3184:	2200      	movs	r2, #0
    3186:	701a      	strb	r2, [r3, #0]

        if((gu16Delta[0] > gu16Threshold[0])||(gu16Delta[1] > gu16Threshold[1]))
    3188:	4b42      	ldr	r3, [pc, #264]	; (3294 <TSI_SliderRead+0x120>)
    318a:	881a      	ldrh	r2, [r3, #0]
    318c:	4b42      	ldr	r3, [pc, #264]	; (3298 <TSI_SliderRead+0x124>)
    318e:	881b      	ldrh	r3, [r3, #0]
    3190:	429a      	cmp	r2, r3
    3192:	d805      	bhi.n	31a0 <TSI_SliderRead+0x2c>
    3194:	4b3f      	ldr	r3, [pc, #252]	; (3294 <TSI_SliderRead+0x120>)
    3196:	885a      	ldrh	r2, [r3, #2]
    3198:	4b3f      	ldr	r3, [pc, #252]	; (3298 <TSI_SliderRead+0x124>)
    319a:	885b      	ldrh	r3, [r3, #2]
    319c:	429a      	cmp	r2, r3
    319e:	d962      	bls.n	3266 <TSI_SliderRead+0xf2>
         {
           SliderPercentegePosition[0] = (gu16Delta[0]*100)/(gu16Delta[0]+gu16Delta[1]);
    31a0:	4b3c      	ldr	r3, [pc, #240]	; (3294 <TSI_SliderRead+0x120>)
    31a2:	881b      	ldrh	r3, [r3, #0]
    31a4:	001a      	movs	r2, r3
    31a6:	2364      	movs	r3, #100	; 0x64
    31a8:	435a      	muls	r2, r3
    31aa:	4b3a      	ldr	r3, [pc, #232]	; (3294 <TSI_SliderRead+0x120>)
    31ac:	881b      	ldrh	r3, [r3, #0]
    31ae:	0019      	movs	r1, r3
    31b0:	4b38      	ldr	r3, [pc, #224]	; (3294 <TSI_SliderRead+0x120>)
    31b2:	885b      	ldrh	r3, [r3, #2]
    31b4:	18cb      	adds	r3, r1, r3
    31b6:	0019      	movs	r1, r3
    31b8:	0010      	movs	r0, r2
    31ba:	f7fd f9d7 	bl	56c <__divsi3>
    31be:	0003      	movs	r3, r0
    31c0:	b2da      	uxtb	r2, r3
    31c2:	4b36      	ldr	r3, [pc, #216]	; (329c <TSI_SliderRead+0x128>)
    31c4:	701a      	strb	r2, [r3, #0]
           
           SliderPercentegePosition[1] = (gu16Delta[1]*100)/(gu16Delta[0]+gu16Delta[1]);
    31c6:	4b33      	ldr	r3, [pc, #204]	; (3294 <TSI_SliderRead+0x120>)
    31c8:	885b      	ldrh	r3, [r3, #2]
    31ca:	001a      	movs	r2, r3
    31cc:	2364      	movs	r3, #100	; 0x64
    31ce:	435a      	muls	r2, r3
    31d0:	4b30      	ldr	r3, [pc, #192]	; (3294 <TSI_SliderRead+0x120>)
    31d2:	881b      	ldrh	r3, [r3, #0]
    31d4:	0019      	movs	r1, r3
    31d6:	4b2f      	ldr	r3, [pc, #188]	; (3294 <TSI_SliderRead+0x120>)
    31d8:	885b      	ldrh	r3, [r3, #2]
    31da:	18cb      	adds	r3, r1, r3
    31dc:	0019      	movs	r1, r3
    31de:	0010      	movs	r0, r2
    31e0:	f7fd f9c4 	bl	56c <__divsi3>
    31e4:	0003      	movs	r3, r0
    31e6:	b2da      	uxtb	r2, r3
    31e8:	4b2c      	ldr	r3, [pc, #176]	; (329c <TSI_SliderRead+0x128>)
    31ea:	705a      	strb	r2, [r3, #1]
           
           SliderDistancePosition[0] = (SliderPercentegePosition[0]* SLIDER_LENGTH)/100;
    31ec:	4b2b      	ldr	r3, [pc, #172]	; (329c <TSI_SliderRead+0x128>)
    31ee:	781b      	ldrb	r3, [r3, #0]
    31f0:	001a      	movs	r2, r3
    31f2:	0013      	movs	r3, r2
    31f4:	009b      	lsls	r3, r3, #2
    31f6:	189b      	adds	r3, r3, r2
    31f8:	00db      	lsls	r3, r3, #3
    31fa:	2164      	movs	r1, #100	; 0x64
    31fc:	0018      	movs	r0, r3
    31fe:	f7fd f9b5 	bl	56c <__divsi3>
    3202:	0003      	movs	r3, r0
    3204:	b2da      	uxtb	r2, r3
    3206:	4b26      	ldr	r3, [pc, #152]	; (32a0 <TSI_SliderRead+0x12c>)
    3208:	701a      	strb	r2, [r3, #0]
             
           SliderDistancePosition[1] = (SliderPercentegePosition[1]* SLIDER_LENGTH)/100;
    320a:	4b24      	ldr	r3, [pc, #144]	; (329c <TSI_SliderRead+0x128>)
    320c:	785b      	ldrb	r3, [r3, #1]
    320e:	001a      	movs	r2, r3
    3210:	0013      	movs	r3, r2
    3212:	009b      	lsls	r3, r3, #2
    3214:	189b      	adds	r3, r3, r2
    3216:	00db      	lsls	r3, r3, #3
    3218:	2164      	movs	r1, #100	; 0x64
    321a:	0018      	movs	r0, r3
    321c:	f7fd f9a6 	bl	56c <__divsi3>
    3220:	0003      	movs	r3, r0
    3222:	b2da      	uxtb	r2, r3
    3224:	4b1e      	ldr	r3, [pc, #120]	; (32a0 <TSI_SliderRead+0x12c>)
    3226:	705a      	strb	r2, [r3, #1]
           
          AbsolutePercentegePosition = ((100 - SliderPercentegePosition[0]) + SliderPercentegePosition[1])/2;
    3228:	4b1c      	ldr	r3, [pc, #112]	; (329c <TSI_SliderRead+0x128>)
    322a:	781b      	ldrb	r3, [r3, #0]
    322c:	001a      	movs	r2, r3
    322e:	2364      	movs	r3, #100	; 0x64
    3230:	1a9b      	subs	r3, r3, r2
    3232:	4a1a      	ldr	r2, [pc, #104]	; (329c <TSI_SliderRead+0x128>)
    3234:	7852      	ldrb	r2, [r2, #1]
    3236:	189b      	adds	r3, r3, r2
    3238:	2b00      	cmp	r3, #0
    323a:	da00      	bge.n	323e <TSI_SliderRead+0xca>
    323c:	3301      	adds	r3, #1
    323e:	105b      	asrs	r3, r3, #1
    3240:	b2da      	uxtb	r2, r3
    3242:	4b18      	ldr	r3, [pc, #96]	; (32a4 <TSI_SliderRead+0x130>)
    3244:	701a      	strb	r2, [r3, #0]
          AbsoluteDistancePosition = ((SLIDER_LENGTH - SliderDistancePosition[0]) + SliderDistancePosition[1])/2;
    3246:	4b16      	ldr	r3, [pc, #88]	; (32a0 <TSI_SliderRead+0x12c>)
    3248:	781b      	ldrb	r3, [r3, #0]
    324a:	001a      	movs	r2, r3
    324c:	2328      	movs	r3, #40	; 0x28
    324e:	1a9b      	subs	r3, r3, r2
    3250:	4a13      	ldr	r2, [pc, #76]	; (32a0 <TSI_SliderRead+0x12c>)
    3252:	7852      	ldrb	r2, [r2, #1]
    3254:	189b      	adds	r3, r3, r2
    3256:	2b00      	cmp	r3, #0
    3258:	da00      	bge.n	325c <TSI_SliderRead+0xe8>
    325a:	3301      	adds	r3, #1
    325c:	105b      	asrs	r3, r3, #1
    325e:	b2da      	uxtb	r2, r3
    3260:	4b11      	ldr	r3, [pc, #68]	; (32a8 <TSI_SliderRead+0x134>)
    3262:	701a      	strb	r2, [r3, #0]
            AbsolutePercentegePosition = NO_TOUCH; 
            AbsoluteDistancePosition = NO_TOUCH; 
         }
      }
 
}
    3264:	e011      	b.n	328a <TSI_SliderRead+0x116>
            SliderPercentegePosition[0] = NO_TOUCH;  
    3266:	4b0d      	ldr	r3, [pc, #52]	; (329c <TSI_SliderRead+0x128>)
    3268:	2200      	movs	r2, #0
    326a:	701a      	strb	r2, [r3, #0]
            SliderPercentegePosition[1] = NO_TOUCH; 
    326c:	4b0b      	ldr	r3, [pc, #44]	; (329c <TSI_SliderRead+0x128>)
    326e:	2200      	movs	r2, #0
    3270:	705a      	strb	r2, [r3, #1]
            SliderDistancePosition[0] = NO_TOUCH; 
    3272:	4b0b      	ldr	r3, [pc, #44]	; (32a0 <TSI_SliderRead+0x12c>)
    3274:	2200      	movs	r2, #0
    3276:	701a      	strb	r2, [r3, #0]
            SliderDistancePosition[1] = NO_TOUCH; 
    3278:	4b09      	ldr	r3, [pc, #36]	; (32a0 <TSI_SliderRead+0x12c>)
    327a:	2200      	movs	r2, #0
    327c:	705a      	strb	r2, [r3, #1]
            AbsolutePercentegePosition = NO_TOUCH; 
    327e:	4b09      	ldr	r3, [pc, #36]	; (32a4 <TSI_SliderRead+0x130>)
    3280:	2200      	movs	r2, #0
    3282:	701a      	strb	r2, [r3, #0]
            AbsoluteDistancePosition = NO_TOUCH; 
    3284:	4b08      	ldr	r3, [pc, #32]	; (32a8 <TSI_SliderRead+0x134>)
    3286:	2200      	movs	r2, #0
    3288:	701a      	strb	r2, [r3, #0]
}
    328a:	46c0      	nop			; (mov r8, r8)
    328c:	46bd      	mov	sp, r7
    328e:	bd80      	pop	{r7, pc}
    3290:	1ffff444 	.word	0x1ffff444
    3294:	1ffff630 	.word	0x1ffff630
    3298:	1ffff424 	.word	0x1ffff424
    329c:	1ffff4b8 	.word	0x1ffff4b8
    32a0:	1ffff4bc 	.word	0x1ffff4bc
    32a4:	1ffff4be 	.word	0x1ffff4be
    32a8:	1ffff4bf 	.word	0x1ffff4bf

000032ac <TSI_ISR>:



void TSI_ISR(void)
{
    32ac:	b580      	push	{r7, lr}
    32ae:	af00      	add	r7, sp, #0
  end_flag = TRUE;
    32b0:	4b06      	ldr	r3, [pc, #24]	; (32cc <TSI_ISR+0x20>)
    32b2:	2201      	movs	r2, #1
    32b4:	701a      	strb	r2, [r3, #0]
  TSI0_GENCS |= TSI_GENCS_EOSF_MASK; // Clear End of Scan Flag
    32b6:	4b06      	ldr	r3, [pc, #24]	; (32d0 <TSI_ISR+0x24>)
    32b8:	4a05      	ldr	r2, [pc, #20]	; (32d0 <TSI_ISR+0x24>)
    32ba:	6812      	ldr	r2, [r2, #0]
    32bc:	2104      	movs	r1, #4
    32be:	430a      	orrs	r2, r1
    32c0:	601a      	str	r2, [r3, #0]
  change_electrode();
    32c2:	f7ff feef 	bl	30a4 <change_electrode>

    32c6:	46c0      	nop			; (mov r8, r8)
    32c8:	46bd      	mov	sp, r7
    32ca:	bd80      	pop	{r7, pc}
    32cc:	1ffff444 	.word	0x1ffff444
    32d0:	40045000 	.word	0x40045000

000032d4 <Buffer_Init>:
volatile uint8 gu8BufferOverFlow;


/********************************************************/
void Buffer_Init(uint8* pu8BufferPointer ,uint8 u8MaxSize)
{
    32d4:	b580      	push	{r7, lr}
    32d6:	b082      	sub	sp, #8
    32d8:	af00      	add	r7, sp, #0
    32da:	6078      	str	r0, [r7, #4]
    32dc:	000a      	movs	r2, r1
    32de:	1cfb      	adds	r3, r7, #3
    32e0:	701a      	strb	r2, [r3, #0]
    /* Buffer Initialization */
    OUT_EndAddress = pu8BufferPointer + u8MaxSize - 1;
    32e2:	1cfb      	adds	r3, r7, #3
    32e4:	781b      	ldrb	r3, [r3, #0]
    32e6:	3b01      	subs	r3, #1
    32e8:	687a      	ldr	r2, [r7, #4]
    32ea:	18d2      	adds	r2, r2, r3
    32ec:	4b0a      	ldr	r3, [pc, #40]	; (3318 <Buffer_Init+0x44>)
    32ee:	601a      	str	r2, [r3, #0]
    OUT_StartAddress = pu8BufferPointer;
    32f0:	4b0a      	ldr	r3, [pc, #40]	; (331c <Buffer_Init+0x48>)
    32f2:	687a      	ldr	r2, [r7, #4]
    32f4:	601a      	str	r2, [r3, #0]
    gu8BufferMaxSize = u8MaxSize;
    32f6:	4b0a      	ldr	r3, [pc, #40]	; (3320 <Buffer_Init+0x4c>)
    32f8:	1cfa      	adds	r2, r7, #3
    32fa:	7812      	ldrb	r2, [r2, #0]
    32fc:	701a      	strb	r2, [r3, #0]
    OUT_UsbPointer = pu8BufferPointer;
    32fe:	4b09      	ldr	r3, [pc, #36]	; (3324 <Buffer_Init+0x50>)
    3300:	687a      	ldr	r2, [r7, #4]
    3302:	601a      	str	r2, [r3, #0]
    OUT_SciPointer = pu8BufferPointer;
    3304:	4b08      	ldr	r3, [pc, #32]	; (3328 <Buffer_Init+0x54>)
    3306:	687a      	ldr	r2, [r7, #4]
    3308:	601a      	str	r2, [r3, #0]
    gu8BufferOverFlow = 0;
    330a:	4b08      	ldr	r3, [pc, #32]	; (332c <Buffer_Init+0x58>)
    330c:	2200      	movs	r2, #0
    330e:	701a      	strb	r2, [r3, #0]
}
    3310:	46c0      	nop			; (mov r8, r8)
    3312:	46bd      	mov	sp, r7
    3314:	b002      	add	sp, #8
    3316:	bd80      	pop	{r7, pc}
    3318:	1ffff650 	.word	0x1ffff650
    331c:	1ffff658 	.word	0x1ffff658
    3320:	1ffff661 	.word	0x1ffff661
    3324:	1ffff65c 	.word	0x1ffff65c
    3328:	1ffff654 	.word	0x1ffff654
    332c:	1ffff660 	.word	0x1ffff660

00003330 <USB_Init>:
        puLocalPointer+=4;
    }  
}
/**********************************************************/
void USB_Init(void)
{  
    3330:	b580      	push	{r7, lr}
    3332:	af00      	add	r7, sp, #0
    /* Software Configuration */
    Setup_Pkt=(tUSB_Setup*)BufferPointer[bEP0OUT_ODD];
    3334:	4b38      	ldr	r3, [pc, #224]	; (3418 <USB_Init+0xe8>)
    3336:	681a      	ldr	r2, [r3, #0]
    3338:	4b38      	ldr	r3, [pc, #224]	; (341c <USB_Init+0xec>)
    333a:	601a      	str	r2, [r3, #0]
    gu8USB_State=uPOWER;
    333c:	4b38      	ldr	r3, [pc, #224]	; (3420 <USB_Init+0xf0>)
    333e:	2200      	movs	r2, #0
    3340:	701a      	strb	r2, [r3, #0]

    /* MPU Configuration */
     // MPU_CESR=0;                                    MPU is disable. All accesses from all bus masters are allowed

    /** Feed 48MHz to the USB FS clock */
    vfnInitUSBClock(USB_CLOCK);       
    3342:	2000      	movs	r0, #0
    3344:	f7ff fcb4 	bl	2cb0 <vfnInitUSBClock>

    /* NVIC Configuration */
    extern uint32 __VECTOR_RAM[];           //Get vector table that was copied to RAM
    __VECTOR_RAM[51]=(uint32)USB_ISR;       //replace ISR
    3348:	4a36      	ldr	r2, [pc, #216]	; (3424 <USB_Init+0xf4>)
    334a:	4b37      	ldr	r3, [pc, #220]	; (3428 <USB_Init+0xf8>)
    334c:	21cc      	movs	r1, #204	; 0xcc
    334e:	505a      	str	r2, [r3, r1]
    enable_irq(24);                         //IRQ 24 for USBOTG and USBCDC on Flycatcher
    3350:	2018      	movs	r0, #24
    3352:	f7fd fe4b 	bl	fec <enable_irq>

        
    /* USB Module Configuration */
    // Reset USB Module
    USB0_USBTRC0 |= USB_USBTRC0_USBRESET_MASK;
    3356:	4935      	ldr	r1, [pc, #212]	; (342c <USB_Init+0xfc>)
    3358:	4a34      	ldr	r2, [pc, #208]	; (342c <USB_Init+0xfc>)
    335a:	2386      	movs	r3, #134	; 0x86
    335c:	005b      	lsls	r3, r3, #1
    335e:	5cd3      	ldrb	r3, [r2, r3]
    3360:	b2db      	uxtb	r3, r3
    3362:	2280      	movs	r2, #128	; 0x80
    3364:	4252      	negs	r2, r2
    3366:	4313      	orrs	r3, r2
    3368:	b2da      	uxtb	r2, r3
    336a:	2386      	movs	r3, #134	; 0x86
    336c:	005b      	lsls	r3, r3, #1
    336e:	54ca      	strb	r2, [r1, r3]
    while(FLAG_CHK(USB_USBTRC0_USBRESET_SHIFT,USB0_USBTRC0)){};
    3370:	46c0      	nop			; (mov r8, r8)
    3372:	4a2e      	ldr	r2, [pc, #184]	; (342c <USB_Init+0xfc>)
    3374:	2386      	movs	r3, #134	; 0x86
    3376:	005b      	lsls	r3, r3, #1
    3378:	5cd3      	ldrb	r3, [r2, r3]
    337a:	b2db      	uxtb	r3, r3
    337c:	b25b      	sxtb	r3, r3
    337e:	2b00      	cmp	r3, #0
    3380:	dbf7      	blt.n	3372 <USB_Init+0x42>
    
    // Set BDT Base Register
    USB0_BDTPAGE1=(uint8)((uint32)tBDTtable>>8);
    3382:	4a2a      	ldr	r2, [pc, #168]	; (342c <USB_Init+0xfc>)
    3384:	4b2a      	ldr	r3, [pc, #168]	; (3430 <USB_Init+0x100>)
    3386:	0a1b      	lsrs	r3, r3, #8
    3388:	b2d9      	uxtb	r1, r3
    338a:	239c      	movs	r3, #156	; 0x9c
    338c:	54d1      	strb	r1, [r2, r3]
    USB0_BDTPAGE2=(uint8)((uint32)tBDTtable>>16);
    338e:	4a27      	ldr	r2, [pc, #156]	; (342c <USB_Init+0xfc>)
    3390:	4b27      	ldr	r3, [pc, #156]	; (3430 <USB_Init+0x100>)
    3392:	0c1b      	lsrs	r3, r3, #16
    3394:	b2d9      	uxtb	r1, r3
    3396:	23b0      	movs	r3, #176	; 0xb0
    3398:	54d1      	strb	r1, [r2, r3]
    USB0_BDTPAGE3=(uint8)((uint32)tBDTtable>>24);
    339a:	4a24      	ldr	r2, [pc, #144]	; (342c <USB_Init+0xfc>)
    339c:	4b24      	ldr	r3, [pc, #144]	; (3430 <USB_Init+0x100>)
    339e:	0e1b      	lsrs	r3, r3, #24
    33a0:	b2d9      	uxtb	r1, r3
    33a2:	23b4      	movs	r3, #180	; 0xb4
    33a4:	54d1      	strb	r1, [r2, r3]

    // Clear USB Reset flag
    FLAG_SET(USB_ISTAT_USBRST_MASK,USB0_ISTAT);
    33a6:	4a21      	ldr	r2, [pc, #132]	; (342c <USB_Init+0xfc>)
    33a8:	4920      	ldr	r1, [pc, #128]	; (342c <USB_Init+0xfc>)
    33aa:	2380      	movs	r3, #128	; 0x80
    33ac:	5ccb      	ldrb	r3, [r1, r3]
    33ae:	b2db      	uxtb	r3, r3
    33b0:	2102      	movs	r1, #2
    33b2:	430b      	orrs	r3, r1
    33b4:	b2d9      	uxtb	r1, r3
    33b6:	2380      	movs	r3, #128	; 0x80
    33b8:	54d1      	strb	r1, [r2, r3]

    // Enable USB Reset Interrupt
    FLAG_SET(USB_INTEN_USBRSTEN_SHIFT,USB0_INTEN);
    33ba:	4a1c      	ldr	r2, [pc, #112]	; (342c <USB_Init+0xfc>)
    33bc:	491b      	ldr	r1, [pc, #108]	; (342c <USB_Init+0xfc>)
    33be:	2384      	movs	r3, #132	; 0x84
    33c0:	5ccb      	ldrb	r3, [r1, r3]
    33c2:	b2db      	uxtb	r3, r3
    33c4:	2101      	movs	r1, #1
    33c6:	430b      	orrs	r3, r1
    33c8:	b2d9      	uxtb	r1, r3
    33ca:	2384      	movs	r3, #132	; 0x84
    33cc:	54d1      	strb	r1, [r2, r3]
    
    // Enable weak pull downs
    //USB0_USBCTRL = USB_USBCTRL_PDE_MASK;
    // Disable weak pull downs 
    USB0_USBCTRL &= ~(uint8)(USB_USBCTRL_PDE_MASK | USB_USBCTRL_SUSP_MASK);   
    33ce:	4a17      	ldr	r2, [pc, #92]	; (342c <USB_Init+0xfc>)
    33d0:	4916      	ldr	r1, [pc, #88]	; (342c <USB_Init+0xfc>)
    33d2:	2380      	movs	r3, #128	; 0x80
    33d4:	005b      	lsls	r3, r3, #1
    33d6:	5ccb      	ldrb	r3, [r1, r3]
    33d8:	b2db      	uxtb	r3, r3
    33da:	213f      	movs	r1, #63	; 0x3f
    33dc:	400b      	ands	r3, r1
    33de:	b2d9      	uxtb	r1, r3
    33e0:	2380      	movs	r3, #128	; 0x80
    33e2:	005b      	lsls	r3, r3, #1
    33e4:	54d1      	strb	r1, [r2, r3]
    
    
    USB0_USBTRC0|=0x40;
    33e6:	4a11      	ldr	r2, [pc, #68]	; (342c <USB_Init+0xfc>)
    33e8:	4910      	ldr	r1, [pc, #64]	; (342c <USB_Init+0xfc>)
    33ea:	2386      	movs	r3, #134	; 0x86
    33ec:	005b      	lsls	r3, r3, #1
    33ee:	5ccb      	ldrb	r3, [r1, r3]
    33f0:	b2db      	uxtb	r3, r3
    33f2:	2140      	movs	r1, #64	; 0x40
    33f4:	430b      	orrs	r3, r1
    33f6:	b2d9      	uxtb	r1, r3
    33f8:	2386      	movs	r3, #134	; 0x86
    33fa:	005b      	lsls	r3, r3, #1
    33fc:	54d1      	strb	r1, [r2, r3]

    USB0_CTL|=0x01;
    33fe:	4a0b      	ldr	r2, [pc, #44]	; (342c <USB_Init+0xfc>)
    3400:	490a      	ldr	r1, [pc, #40]	; (342c <USB_Init+0xfc>)
    3402:	2394      	movs	r3, #148	; 0x94
    3404:	5ccb      	ldrb	r3, [r1, r3]
    3406:	b2db      	uxtb	r3, r3
    3408:	2101      	movs	r1, #1
    340a:	430b      	orrs	r3, r1
    340c:	b2d9      	uxtb	r1, r3
    340e:	2394      	movs	r3, #148	; 0x94
    3410:	54d1      	strb	r1, [r2, r3]
    
    // Pull up enable
//    FLAG_SET(USB_CONTROL_DPPULLUPNONOTG_SHIFT,USB0_CONTROL);    
}
    3412:	46c0      	nop			; (mov r8, r8)
    3414:	46bd      	mov	sp, r7
    3416:	bd80      	pop	{r7, pc}
    3418:	1ffff448 	.word	0x1ffff448
    341c:	1ffff6a8 	.word	0x1ffff6a8
    3420:	1ffff7e0 	.word	0x1ffff7e0
    3424:	00003cc1 	.word	0x00003cc1
    3428:	1ffff000 	.word	0x1ffff000
    342c:	40072000 	.word	0x40072000
    3430:	1ffff804 	.word	0x1ffff804

00003434 <EP_IN_Transfer>:



/**********************************************************/
void EP_IN_Transfer(uint8 u8EP,uint8 *pu8DataPointer,uint8 u8DataSize)
{
    3434:	b580      	push	{r7, lr}
    3436:	b086      	sub	sp, #24
    3438:	af00      	add	r7, sp, #0
    343a:	6039      	str	r1, [r7, #0]
    343c:	0011      	movs	r1, r2
    343e:	1dfb      	adds	r3, r7, #7
    3440:	1c02      	adds	r2, r0, #0
    3442:	701a      	strb	r2, [r3, #0]
    3444:	1dbb      	adds	r3, r7, #6
    3446:	1c0a      	adds	r2, r1, #0
    3448:	701a      	strb	r2, [r3, #0]
    uint8 *pu8EPBuffer;
    uint8 u8EPSize; 
    uint16 u16Lenght=0;    
    344a:	2310      	movs	r3, #16
    344c:	18fb      	adds	r3, r7, r3
    344e:	2200      	movs	r2, #0
    3450:	801a      	strh	r2, [r3, #0]
    uint8 u8EndPointFlag;    

    /* Adjust the buffer location */
    u8EndPointFlag=u8EP;
    3452:	230f      	movs	r3, #15
    3454:	18fb      	adds	r3, r7, r3
    3456:	1dfa      	adds	r2, r7, #7
    3458:	7812      	ldrb	r2, [r2, #0]
    345a:	701a      	strb	r2, [r3, #0]
    if(u8EP)
    345c:	1dfb      	adds	r3, r7, #7
    345e:	781b      	ldrb	r3, [r3, #0]
    3460:	2b00      	cmp	r3, #0
    3462:	d004      	beq.n	346e <EP_IN_Transfer+0x3a>
        u8EP=(uint8)(u8EP<<2);
    3464:	1dfb      	adds	r3, r7, #7
    3466:	1dfa      	adds	r2, r7, #7
    3468:	7812      	ldrb	r2, [r2, #0]
    346a:	0092      	lsls	r2, r2, #2
    346c:	701a      	strb	r2, [r3, #0]
    u8EP+=2;
    346e:	1dfb      	adds	r3, r7, #7
    3470:	1dfa      	adds	r2, r7, #7
    3472:	7812      	ldrb	r2, [r2, #0]
    3474:	3202      	adds	r2, #2
    3476:	701a      	strb	r2, [r3, #0]
    
    
    
    /* Assign the proper EP buffer */
    pu8EPBuffer=BufferPointer[u8EP];
    3478:	1dfb      	adds	r3, r7, #7
    347a:	781a      	ldrb	r2, [r3, #0]
    347c:	4b5d      	ldr	r3, [pc, #372]	; (35f4 <EP_IN_Transfer+0x1c0>)
    347e:	0092      	lsls	r2, r2, #2
    3480:	58d3      	ldr	r3, [r2, r3]
    3482:	617b      	str	r3, [r7, #20]
    
    /* Check if is a pending transfer */
    if(FLAG_CHK(fIN,gu8USBClearFlags))
    3484:	4b5c      	ldr	r3, [pc, #368]	; (35f8 <EP_IN_Transfer+0x1c4>)
    3486:	781b      	ldrb	r3, [r3, #0]
    3488:	001a      	movs	r2, r3
    348a:	2301      	movs	r3, #1
    348c:	4013      	ands	r3, r2
    348e:	d025      	beq.n	34dc <EP_IN_Transfer+0xa8>
    {
        pu8IN_DataPointer=pu8DataPointer;
    3490:	4b5a      	ldr	r3, [pc, #360]	; (35fc <EP_IN_Transfer+0x1c8>)
    3492:	683a      	ldr	r2, [r7, #0]
    3494:	601a      	str	r2, [r3, #0]
        gu8IN_Counter=u8DataSize;       
    3496:	4b5a      	ldr	r3, [pc, #360]	; (3600 <EP_IN_Transfer+0x1cc>)
    3498:	1dba      	adds	r2, r7, #6
    349a:	7812      	ldrb	r2, [r2, #0]
    349c:	701a      	strb	r2, [r3, #0]

        u16Lenght=(Setup_Pkt->wLength_h<<8)+Setup_Pkt->wLength_l ;
    349e:	4b59      	ldr	r3, [pc, #356]	; (3604 <EP_IN_Transfer+0x1d0>)
    34a0:	681b      	ldr	r3, [r3, #0]
    34a2:	79db      	ldrb	r3, [r3, #7]
    34a4:	b29b      	uxth	r3, r3
    34a6:	021b      	lsls	r3, r3, #8
    34a8:	b299      	uxth	r1, r3
    34aa:	4b56      	ldr	r3, [pc, #344]	; (3604 <EP_IN_Transfer+0x1d0>)
    34ac:	681b      	ldr	r3, [r3, #0]
    34ae:	799b      	ldrb	r3, [r3, #6]
    34b0:	b29a      	uxth	r2, r3
    34b2:	2310      	movs	r3, #16
    34b4:	18fb      	adds	r3, r7, r3
    34b6:	188a      	adds	r2, r1, r2
    34b8:	801a      	strh	r2, [r3, #0]
        if((u16Lenght < u8DataSize) && (u8EP==2))
    34ba:	1dbb      	adds	r3, r7, #6
    34bc:	781b      	ldrb	r3, [r3, #0]
    34be:	b29b      	uxth	r3, r3
    34c0:	2210      	movs	r2, #16
    34c2:	18ba      	adds	r2, r7, r2
    34c4:	8812      	ldrh	r2, [r2, #0]
    34c6:	429a      	cmp	r2, r3
    34c8:	d208      	bcs.n	34dc <EP_IN_Transfer+0xa8>
    34ca:	1dfb      	adds	r3, r7, #7
    34cc:	781b      	ldrb	r3, [r3, #0]
    34ce:	2b02      	cmp	r3, #2
    34d0:	d104      	bne.n	34dc <EP_IN_Transfer+0xa8>
        {
            gu8IN_Counter=Setup_Pkt->wLength_l;
    34d2:	4b4c      	ldr	r3, [pc, #304]	; (3604 <EP_IN_Transfer+0x1d0>)
    34d4:	681b      	ldr	r3, [r3, #0]
    34d6:	799a      	ldrb	r2, [r3, #6]
    34d8:	4b49      	ldr	r3, [pc, #292]	; (3600 <EP_IN_Transfer+0x1cc>)
    34da:	701a      	strb	r2, [r3, #0]
        }
    }

    /* Check transfer Size */
    if(gu8IN_Counter > cEP_Size[u8EP])
    34dc:	1dfb      	adds	r3, r7, #7
    34de:	781b      	ldrb	r3, [r3, #0]
    34e0:	4a49      	ldr	r2, [pc, #292]	; (3608 <EP_IN_Transfer+0x1d4>)
    34e2:	5cd2      	ldrb	r2, [r2, r3]
    34e4:	4b46      	ldr	r3, [pc, #280]	; (3600 <EP_IN_Transfer+0x1cc>)
    34e6:	781b      	ldrb	r3, [r3, #0]
    34e8:	429a      	cmp	r2, r3
    34ea:	d218      	bcs.n	351e <EP_IN_Transfer+0xea>
    {
        u8EPSize = cEP_Size[u8EP];
    34ec:	1dfb      	adds	r3, r7, #7
    34ee:	781a      	ldrb	r2, [r3, #0]
    34f0:	2313      	movs	r3, #19
    34f2:	18fb      	adds	r3, r7, r3
    34f4:	4944      	ldr	r1, [pc, #272]	; (3608 <EP_IN_Transfer+0x1d4>)
    34f6:	5c8a      	ldrb	r2, [r1, r2]
    34f8:	701a      	strb	r2, [r3, #0]
        gu8IN_Counter-=cEP_Size[u8EP];
    34fa:	4b41      	ldr	r3, [pc, #260]	; (3600 <EP_IN_Transfer+0x1cc>)
    34fc:	781a      	ldrb	r2, [r3, #0]
    34fe:	1dfb      	adds	r3, r7, #7
    3500:	781b      	ldrb	r3, [r3, #0]
    3502:	4941      	ldr	r1, [pc, #260]	; (3608 <EP_IN_Transfer+0x1d4>)
    3504:	5ccb      	ldrb	r3, [r1, r3]
    3506:	1ad3      	subs	r3, r2, r3
    3508:	b2da      	uxtb	r2, r3
    350a:	4b3d      	ldr	r3, [pc, #244]	; (3600 <EP_IN_Transfer+0x1cc>)
    350c:	701a      	strb	r2, [r3, #0]
        FLAG_CLR(fIN,gu8USBClearFlags);
    350e:	4b3a      	ldr	r3, [pc, #232]	; (35f8 <EP_IN_Transfer+0x1c4>)
    3510:	781b      	ldrb	r3, [r3, #0]
    3512:	2201      	movs	r2, #1
    3514:	4393      	bics	r3, r2
    3516:	b2da      	uxtb	r2, r3
    3518:	4b37      	ldr	r3, [pc, #220]	; (35f8 <EP_IN_Transfer+0x1c4>)
    351a:	701a      	strb	r2, [r3, #0]
    351c:	e00e      	b.n	353c <EP_IN_Transfer+0x108>
    }
    else
    {
        u8EPSize = gu8IN_Counter;
    351e:	2313      	movs	r3, #19
    3520:	18fb      	adds	r3, r7, r3
    3522:	4a37      	ldr	r2, [pc, #220]	; (3600 <EP_IN_Transfer+0x1cc>)
    3524:	7812      	ldrb	r2, [r2, #0]
    3526:	701a      	strb	r2, [r3, #0]
        gu8IN_Counter=0;
    3528:	4b35      	ldr	r3, [pc, #212]	; (3600 <EP_IN_Transfer+0x1cc>)
    352a:	2200      	movs	r2, #0
    352c:	701a      	strb	r2, [r3, #0]
        FLAG_SET(fIN,gu8USBClearFlags);
    352e:	4b32      	ldr	r3, [pc, #200]	; (35f8 <EP_IN_Transfer+0x1c4>)
    3530:	781b      	ldrb	r3, [r3, #0]
    3532:	2201      	movs	r2, #1
    3534:	4313      	orrs	r3, r2
    3536:	b2da      	uxtb	r2, r3
    3538:	4b2f      	ldr	r3, [pc, #188]	; (35f8 <EP_IN_Transfer+0x1c4>)
    353a:	701a      	strb	r2, [r3, #0]
    }
    
    /* Copy User buffer to EP buffer */
    tBDTtable[u8EP].Cnt=(u8EPSize);
    353c:	1dfb      	adds	r3, r7, #7
    353e:	781b      	ldrb	r3, [r3, #0]
    3540:	2213      	movs	r2, #19
    3542:	18ba      	adds	r2, r7, r2
    3544:	7812      	ldrb	r2, [r2, #0]
    3546:	b291      	uxth	r1, r2
    3548:	4a30      	ldr	r2, [pc, #192]	; (360c <EP_IN_Transfer+0x1d8>)
    354a:	00db      	lsls	r3, r3, #3
    354c:	18d3      	adds	r3, r2, r3
    354e:	3302      	adds	r3, #2
    3550:	1c0a      	adds	r2, r1, #0
    3552:	801a      	strh	r2, [r3, #0]
    
    while(u8EPSize--)
    3554:	e009      	b.n	356a <EP_IN_Transfer+0x136>
         *pu8EPBuffer++=*pu8IN_DataPointer++;
    3556:	697b      	ldr	r3, [r7, #20]
    3558:	1c5a      	adds	r2, r3, #1
    355a:	617a      	str	r2, [r7, #20]
    355c:	4a27      	ldr	r2, [pc, #156]	; (35fc <EP_IN_Transfer+0x1c8>)
    355e:	6812      	ldr	r2, [r2, #0]
    3560:	1c50      	adds	r0, r2, #1
    3562:	4926      	ldr	r1, [pc, #152]	; (35fc <EP_IN_Transfer+0x1c8>)
    3564:	6008      	str	r0, [r1, #0]
    3566:	7812      	ldrb	r2, [r2, #0]
    3568:	701a      	strb	r2, [r3, #0]
    while(u8EPSize--)
    356a:	2313      	movs	r3, #19
    356c:	18fb      	adds	r3, r7, r3
    356e:	781b      	ldrb	r3, [r3, #0]
    3570:	2213      	movs	r2, #19
    3572:	18ba      	adds	r2, r7, r2
    3574:	1e59      	subs	r1, r3, #1
    3576:	7011      	strb	r1, [r2, #0]
    3578:	2b00      	cmp	r3, #0
    357a:	d1ec      	bne.n	3556 <EP_IN_Transfer+0x122>
                                                             

    /* USB Flags Handling */
    if(FLAG_CHK(u8EndPointFlag,gu8USB_Toogle_flags))
    357c:	4b24      	ldr	r3, [pc, #144]	; (3610 <EP_IN_Transfer+0x1dc>)
    357e:	781b      	ldrb	r3, [r3, #0]
    3580:	001a      	movs	r2, r3
    3582:	230f      	movs	r3, #15
    3584:	18fb      	adds	r3, r7, r3
    3586:	781b      	ldrb	r3, [r3, #0]
    3588:	411a      	asrs	r2, r3
    358a:	0013      	movs	r3, r2
    358c:	2201      	movs	r2, #1
    358e:	4013      	ands	r3, r2
    3590:	d017      	beq.n	35c2 <EP_IN_Transfer+0x18e>
    {
        tBDTtable[u8EP].Stat._byte= kUDATA0;
    3592:	1dfb      	adds	r3, r7, #7
    3594:	781a      	ldrb	r2, [r3, #0]
    3596:	4b1d      	ldr	r3, [pc, #116]	; (360c <EP_IN_Transfer+0x1d8>)
    3598:	00d2      	lsls	r2, r2, #3
    359a:	2188      	movs	r1, #136	; 0x88
    359c:	54d1      	strb	r1, [r2, r3]
        FLAG_CLR(u8EndPointFlag,gu8USB_Toogle_flags);
    359e:	230f      	movs	r3, #15
    35a0:	18fb      	adds	r3, r7, r3
    35a2:	781b      	ldrb	r3, [r3, #0]
    35a4:	2201      	movs	r2, #1
    35a6:	409a      	lsls	r2, r3
    35a8:	0013      	movs	r3, r2
    35aa:	b25b      	sxtb	r3, r3
    35ac:	43db      	mvns	r3, r3
    35ae:	b25b      	sxtb	r3, r3
    35b0:	4a17      	ldr	r2, [pc, #92]	; (3610 <EP_IN_Transfer+0x1dc>)
    35b2:	7812      	ldrb	r2, [r2, #0]
    35b4:	b252      	sxtb	r2, r2
    35b6:	4013      	ands	r3, r2
    35b8:	b25b      	sxtb	r3, r3
    35ba:	b2da      	uxtb	r2, r3
    35bc:	4b14      	ldr	r3, [pc, #80]	; (3610 <EP_IN_Transfer+0x1dc>)
    35be:	701a      	strb	r2, [r3, #0]
    {
        tBDTtable[u8EP].Stat._byte= kUDATA1;
        FLAG_SET(u8EndPointFlag,gu8USB_Toogle_flags);
    }

}
    35c0:	e014      	b.n	35ec <EP_IN_Transfer+0x1b8>
        tBDTtable[u8EP].Stat._byte= kUDATA1;
    35c2:	1dfb      	adds	r3, r7, #7
    35c4:	781a      	ldrb	r2, [r3, #0]
    35c6:	4b11      	ldr	r3, [pc, #68]	; (360c <EP_IN_Transfer+0x1d8>)
    35c8:	00d2      	lsls	r2, r2, #3
    35ca:	21c8      	movs	r1, #200	; 0xc8
    35cc:	54d1      	strb	r1, [r2, r3]
        FLAG_SET(u8EndPointFlag,gu8USB_Toogle_flags);
    35ce:	230f      	movs	r3, #15
    35d0:	18fb      	adds	r3, r7, r3
    35d2:	781b      	ldrb	r3, [r3, #0]
    35d4:	2201      	movs	r2, #1
    35d6:	409a      	lsls	r2, r3
    35d8:	0013      	movs	r3, r2
    35da:	b25a      	sxtb	r2, r3
    35dc:	4b0c      	ldr	r3, [pc, #48]	; (3610 <EP_IN_Transfer+0x1dc>)
    35de:	781b      	ldrb	r3, [r3, #0]
    35e0:	b25b      	sxtb	r3, r3
    35e2:	4313      	orrs	r3, r2
    35e4:	b25b      	sxtb	r3, r3
    35e6:	b2da      	uxtb	r2, r3
    35e8:	4b09      	ldr	r3, [pc, #36]	; (3610 <EP_IN_Transfer+0x1dc>)
    35ea:	701a      	strb	r2, [r3, #0]
}
    35ec:	46c0      	nop			; (mov r8, r8)
    35ee:	46bd      	mov	sp, r7
    35f0:	b006      	add	sp, #24
    35f2:	bd80      	pop	{r7, pc}
    35f4:	1ffff448 	.word	0x1ffff448
    35f8:	1ffff79c 	.word	0x1ffff79c
    35fc:	1ffff884 	.word	0x1ffff884
    3600:	1ffff684 	.word	0x1ffff684
    3604:	1ffff6a8 	.word	0x1ffff6a8
    3608:	00004c30 	.word	0x00004c30
    360c:	1ffff804 	.word	0x1ffff804
    3610:	1ffff734 	.word	0x1ffff734

00003614 <EP_OUT_Transfer>:


/**********************************************************/
uint8 EP_OUT_Transfer(uint8 u8EP,uint8 *pu8DataPointer)
{
    3614:	b580      	push	{r7, lr}
    3616:	b084      	sub	sp, #16
    3618:	af00      	add	r7, sp, #0
    361a:	0002      	movs	r2, r0
    361c:	6039      	str	r1, [r7, #0]
    361e:	1dfb      	adds	r3, r7, #7
    3620:	701a      	strb	r2, [r3, #0]
    uint8 *pu8EPBuffer;
    uint8 u8EPSize; 
    

    /* Adjust the buffer location */
    u8EP++;
    3622:	1dfb      	adds	r3, r7, #7
    3624:	781a      	ldrb	r2, [r3, #0]
    3626:	1dfb      	adds	r3, r7, #7
    3628:	3201      	adds	r2, #1
    362a:	701a      	strb	r2, [r3, #0]

    /* Assign the proper EP buffer */
    pu8EPBuffer=BufferPointer[u8EP];
    362c:	1dfb      	adds	r3, r7, #7
    362e:	781a      	ldrb	r2, [r3, #0]
    3630:	4b15      	ldr	r3, [pc, #84]	; (3688 <EP_OUT_Transfer+0x74>)
    3632:	0092      	lsls	r2, r2, #2
    3634:	58d3      	ldr	r3, [r2, r3]
    3636:	60fb      	str	r3, [r7, #12]
    
    /* Copy User buffer to EP buffer */
    u8EPSize=tBDTtable[u8EP].Cnt;
    3638:	1dfb      	adds	r3, r7, #7
    363a:	781b      	ldrb	r3, [r3, #0]
    363c:	4a13      	ldr	r2, [pc, #76]	; (368c <EP_OUT_Transfer+0x78>)
    363e:	00db      	lsls	r3, r3, #3
    3640:	18d3      	adds	r3, r2, r3
    3642:	3302      	adds	r3, #2
    3644:	881a      	ldrh	r2, [r3, #0]
    3646:	230b      	movs	r3, #11
    3648:	18fb      	adds	r3, r7, r3
    364a:	701a      	strb	r2, [r3, #0]
    u8EP=u8EPSize;
    364c:	1dfb      	adds	r3, r7, #7
    364e:	220b      	movs	r2, #11
    3650:	18ba      	adds	r2, r7, r2
    3652:	7812      	ldrb	r2, [r2, #0]
    3654:	701a      	strb	r2, [r3, #0]
    
    while(u8EPSize--)
    3656:	e007      	b.n	3668 <EP_OUT_Transfer+0x54>
         *pu8DataPointer++=*pu8EPBuffer++;
    3658:	683b      	ldr	r3, [r7, #0]
    365a:	1c5a      	adds	r2, r3, #1
    365c:	603a      	str	r2, [r7, #0]
    365e:	68fa      	ldr	r2, [r7, #12]
    3660:	1c51      	adds	r1, r2, #1
    3662:	60f9      	str	r1, [r7, #12]
    3664:	7812      	ldrb	r2, [r2, #0]
    3666:	701a      	strb	r2, [r3, #0]
    while(u8EPSize--)
    3668:	230b      	movs	r3, #11
    366a:	18fb      	adds	r3, r7, r3
    366c:	781b      	ldrb	r3, [r3, #0]
    366e:	220b      	movs	r2, #11
    3670:	18ba      	adds	r2, r7, r2
    3672:	1e59      	subs	r1, r3, #1
    3674:	7011      	strb	r1, [r2, #0]
    3676:	2b00      	cmp	r3, #0
    3678:	d1ee      	bne.n	3658 <EP_OUT_Transfer+0x44>
    return(u8EP);
    367a:	1dfb      	adds	r3, r7, #7
    367c:	781b      	ldrb	r3, [r3, #0]
}
    367e:	0018      	movs	r0, r3
    3680:	46bd      	mov	sp, r7
    3682:	b004      	add	sp, #16
    3684:	bd80      	pop	{r7, pc}
    3686:	46c0      	nop			; (mov r8, r8)
    3688:	1ffff448 	.word	0x1ffff448
    368c:	1ffff804 	.word	0x1ffff804

00003690 <USB_EP_OUT_SizeCheck>:

/**********************************************************/
uint16 USB_EP_OUT_SizeCheck(uint8 u8EP)
{
    3690:	b580      	push	{r7, lr}
    3692:	b084      	sub	sp, #16
    3694:	af00      	add	r7, sp, #0
    3696:	0002      	movs	r2, r0
    3698:	1dfb      	adds	r3, r7, #7
    369a:	701a      	strb	r2, [r3, #0]
    uint8 u8EPSize; 
    /* Read Buffer Size */
    u8EPSize=SWAP16(tBDTtable[u8EP<<2].Cnt);
    369c:	1dfb      	adds	r3, r7, #7
    369e:	781b      	ldrb	r3, [r3, #0]
    36a0:	009b      	lsls	r3, r3, #2
    36a2:	4a0f      	ldr	r2, [pc, #60]	; (36e0 <USB_EP_OUT_SizeCheck+0x50>)
    36a4:	00db      	lsls	r3, r3, #3
    36a6:	18d3      	adds	r3, r2, r3
    36a8:	3302      	adds	r3, #2
    36aa:	881b      	ldrh	r3, [r3, #0]
    36ac:	0a1b      	lsrs	r3, r3, #8
    36ae:	b29b      	uxth	r3, r3
    36b0:	b25a      	sxtb	r2, r3
    36b2:	1dfb      	adds	r3, r7, #7
    36b4:	781b      	ldrb	r3, [r3, #0]
    36b6:	009b      	lsls	r3, r3, #2
    36b8:	4909      	ldr	r1, [pc, #36]	; (36e0 <USB_EP_OUT_SizeCheck+0x50>)
    36ba:	00db      	lsls	r3, r3, #3
    36bc:	18cb      	adds	r3, r1, r3
    36be:	3302      	adds	r3, #2
    36c0:	881b      	ldrh	r3, [r3, #0]
    36c2:	021b      	lsls	r3, r3, #8
    36c4:	b25b      	sxtb	r3, r3
    36c6:	4313      	orrs	r3, r2
    36c8:	b25a      	sxtb	r2, r3
    36ca:	230f      	movs	r3, #15
    36cc:	18fb      	adds	r3, r7, r3
    36ce:	701a      	strb	r2, [r3, #0]
    return(u8EPSize&0x03FF);
    36d0:	230f      	movs	r3, #15
    36d2:	18fb      	adds	r3, r7, r3
    36d4:	781b      	ldrb	r3, [r3, #0]
    36d6:	b29b      	uxth	r3, r3
}
    36d8:	0018      	movs	r0, r3
    36da:	46bd      	mov	sp, r7
    36dc:	b004      	add	sp, #16
    36de:	bd80      	pop	{r7, pc}
    36e0:	1ffff804 	.word	0x1ffff804

000036e4 <USB_Set_Interface>:

/**********************************************************/
void USB_Set_Interface(void)
{
    36e4:	b580      	push	{r7, lr}
    36e6:	af00      	add	r7, sp, #0
    /* EndPoint Register settings */
    USB0_ENDPT1= EP1_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    36e8:	4a1d      	ldr	r2, [pc, #116]	; (3760 <USB_Set_Interface+0x7c>)
    36ea:	23c4      	movs	r3, #196	; 0xc4
    36ec:	2105      	movs	r1, #5
    36ee:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT2= EP2_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    36f0:	4a1b      	ldr	r2, [pc, #108]	; (3760 <USB_Set_Interface+0x7c>)
    36f2:	23c8      	movs	r3, #200	; 0xc8
    36f4:	2105      	movs	r1, #5
    36f6:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT3= EP3_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    36f8:	4a19      	ldr	r2, [pc, #100]	; (3760 <USB_Set_Interface+0x7c>)
    36fa:	23cc      	movs	r3, #204	; 0xcc
    36fc:	2109      	movs	r1, #9
    36fe:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT4= EP4_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    3700:	4a17      	ldr	r2, [pc, #92]	; (3760 <USB_Set_Interface+0x7c>)
    3702:	23d0      	movs	r3, #208	; 0xd0
    3704:	2101      	movs	r1, #1
    3706:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT5= EP5_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    3708:	4a15      	ldr	r2, [pc, #84]	; (3760 <USB_Set_Interface+0x7c>)
    370a:	23d4      	movs	r3, #212	; 0xd4
    370c:	2101      	movs	r1, #1
    370e:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT6= EP6_VALUE | USB_ENDPT_EPHSHK_MASK;                         
    3710:	4a13      	ldr	r2, [pc, #76]	; (3760 <USB_Set_Interface+0x7c>)
    3712:	23d8      	movs	r3, #216	; 0xd8
    3714:	2101      	movs	r1, #1
    3716:	54d1      	strb	r1, [r2, r3]
  

    /* EndPoint 1 BDT Settings*/
    tBDTtable[bEP1IN_ODD].Stat._byte= kMCU;
    3718:	4b12      	ldr	r3, [pc, #72]	; (3764 <USB_Set_Interface+0x80>)
    371a:	2230      	movs	r2, #48	; 0x30
    371c:	2100      	movs	r1, #0
    371e:	5499      	strb	r1, [r3, r2]
    tBDTtable[bEP1IN_ODD].Cnt = 0x00;
    3720:	4b10      	ldr	r3, [pc, #64]	; (3764 <USB_Set_Interface+0x80>)
    3722:	2200      	movs	r2, #0
    3724:	865a      	strh	r2, [r3, #50]	; 0x32
    tBDTtable[bEP1IN_ODD].Addr =(uint32)gu8EP1_IN_ODD_Buffer;
    3726:	4a10      	ldr	r2, [pc, #64]	; (3768 <USB_Set_Interface+0x84>)
    3728:	4b0e      	ldr	r3, [pc, #56]	; (3764 <USB_Set_Interface+0x80>)
    372a:	635a      	str	r2, [r3, #52]	; 0x34

    /* EndPoint 2 BDT Settings*/
    tBDTtable[bEP2IN_ODD].Stat._byte= kMCU;
    372c:	4b0d      	ldr	r3, [pc, #52]	; (3764 <USB_Set_Interface+0x80>)
    372e:	2250      	movs	r2, #80	; 0x50
    3730:	2100      	movs	r1, #0
    3732:	5499      	strb	r1, [r3, r2]
    tBDTtable[bEP2IN_ODD].Cnt = 0x00;
    3734:	4b0b      	ldr	r3, [pc, #44]	; (3764 <USB_Set_Interface+0x80>)
    3736:	2252      	movs	r2, #82	; 0x52
    3738:	2100      	movs	r1, #0
    373a:	5299      	strh	r1, [r3, r2]
    tBDTtable[bEP2IN_ODD].Addr =(uint32)gu8EP2_IN_ODD_Buffer;            
    373c:	4a0b      	ldr	r2, [pc, #44]	; (376c <USB_Set_Interface+0x88>)
    373e:	4b09      	ldr	r3, [pc, #36]	; (3764 <USB_Set_Interface+0x80>)
    3740:	655a      	str	r2, [r3, #84]	; 0x54

    /* EndPoint 3 BDT Settings*/
    tBDTtable[bEP3OUT_ODD].Stat._byte= kSIE;
    3742:	4b08      	ldr	r3, [pc, #32]	; (3764 <USB_Set_Interface+0x80>)
    3744:	2260      	movs	r2, #96	; 0x60
    3746:	2180      	movs	r1, #128	; 0x80
    3748:	5499      	strb	r1, [r3, r2]
    tBDTtable[bEP3OUT_ODD].Cnt = 0xFF;
    374a:	4b06      	ldr	r3, [pc, #24]	; (3764 <USB_Set_Interface+0x80>)
    374c:	2262      	movs	r2, #98	; 0x62
    374e:	21ff      	movs	r1, #255	; 0xff
    3750:	5299      	strh	r1, [r3, r2]
    tBDTtable[bEP3OUT_ODD].Addr =(uint32)gu8EP3_OUT_ODD_Buffer;            
    3752:	4a07      	ldr	r2, [pc, #28]	; (3770 <USB_Set_Interface+0x8c>)
    3754:	4b03      	ldr	r3, [pc, #12]	; (3764 <USB_Set_Interface+0x80>)
    3756:	665a      	str	r2, [r3, #100]	; 0x64
}
    3758:	46c0      	nop			; (mov r8, r8)
    375a:	46bd      	mov	sp, r7
    375c:	bd80      	pop	{r7, pc}
    375e:	46c0      	nop			; (mov r8, r8)
    3760:	40072000 	.word	0x40072000
    3764:	1ffff804 	.word	0x1ffff804
    3768:	1ffff6f4 	.word	0x1ffff6f4
    376c:	1ffff6d0 	.word	0x1ffff6d0
    3770:	1ffff8c8 	.word	0x1ffff8c8

00003774 <USB_StdReq_Handler>:


/**********************************************************/
void USB_StdReq_Handler(void)
{
    3774:	b580      	push	{r7, lr}
    3776:	af00      	add	r7, sp, #0

    switch(Setup_Pkt->bRequest)
    3778:	4b3c      	ldr	r3, [pc, #240]	; (386c <USB_StdReq_Handler+0xf8>)
    377a:	681b      	ldr	r3, [r3, #0]
    377c:	785b      	ldrb	r3, [r3, #1]
    377e:	2b09      	cmp	r3, #9
    3780:	d86c      	bhi.n	385c <USB_StdReq_Handler+0xe8>
    3782:	009a      	lsls	r2, r3, #2
    3784:	4b3a      	ldr	r3, [pc, #232]	; (3870 <USB_StdReq_Handler+0xfc>)
    3786:	18d3      	adds	r3, r2, r3
    3788:	681b      	ldr	r3, [r3, #0]
    378a:	469f      	mov	pc, r3
    {
        case mSET_ADDRESS:
            EP_IN_Transfer(EP0,0,0);
    378c:	2200      	movs	r2, #0
    378e:	2100      	movs	r1, #0
    3790:	2000      	movs	r0, #0
    3792:	f7ff fe4f 	bl	3434 <EP_IN_Transfer>
            gu8USB_State=uADDRESS;
    3796:	4b37      	ldr	r3, [pc, #220]	; (3874 <USB_StdReq_Handler+0x100>)
    3798:	2203      	movs	r2, #3
    379a:	701a      	strb	r2, [r3, #0]
            break;
    379c:	e062      	b.n	3864 <USB_StdReq_Handler+0xf0>
      
        case mGET_DESC:
            switch(Setup_Pkt->wValue_h) 
    379e:	4b33      	ldr	r3, [pc, #204]	; (386c <USB_StdReq_Handler+0xf8>)
    37a0:	681b      	ldr	r3, [r3, #0]
    37a2:	78db      	ldrb	r3, [r3, #3]
    37a4:	2b02      	cmp	r3, #2
    37a6:	d00a      	beq.n	37be <USB_StdReq_Handler+0x4a>
    37a8:	2b03      	cmp	r3, #3
    37aa:	d00f      	beq.n	37cc <USB_StdReq_Handler+0x58>
    37ac:	2b01      	cmp	r3, #1
    37ae:	d121      	bne.n	37f4 <USB_StdReq_Handler+0x80>
            {
                case mDEVICE:
                    EP_IN_Transfer(EP0,(uint8*)Device_Descriptor,sizeof(Device_Descriptor));
    37b0:	4b31      	ldr	r3, [pc, #196]	; (3878 <USB_StdReq_Handler+0x104>)
    37b2:	2212      	movs	r2, #18
    37b4:	0019      	movs	r1, r3
    37b6:	2000      	movs	r0, #0
    37b8:	f7ff fe3c 	bl	3434 <EP_IN_Transfer>
                    break;
    37bc:	e01d      	b.n	37fa <USB_StdReq_Handler+0x86>
                    
                case mCONFIGURATION:
                    EP_IN_Transfer(EP0,(uint8*)Configuration_Descriptor,sizeof(Configuration_Descriptor));
    37be:	4b2f      	ldr	r3, [pc, #188]	; (387c <USB_StdReq_Handler+0x108>)
    37c0:	2243      	movs	r2, #67	; 0x43
    37c2:	0019      	movs	r1, r3
    37c4:	2000      	movs	r0, #0
    37c6:	f7ff fe35 	bl	3434 <EP_IN_Transfer>
                    break;
    37ca:	e016      	b.n	37fa <USB_StdReq_Handler+0x86>
        
                case mSTRING:
                    EP_IN_Transfer(EP0,(uint8*)String_Table[Setup_Pkt->wValue_l],String_Table[Setup_Pkt->wValue_l][0]);
    37cc:	4b27      	ldr	r3, [pc, #156]	; (386c <USB_StdReq_Handler+0xf8>)
    37ce:	681b      	ldr	r3, [r3, #0]
    37d0:	789b      	ldrb	r3, [r3, #2]
    37d2:	001a      	movs	r2, r3
    37d4:	4b2a      	ldr	r3, [pc, #168]	; (3880 <USB_StdReq_Handler+0x10c>)
    37d6:	0092      	lsls	r2, r2, #2
    37d8:	58d1      	ldr	r1, [r2, r3]
    37da:	4b24      	ldr	r3, [pc, #144]	; (386c <USB_StdReq_Handler+0xf8>)
    37dc:	681b      	ldr	r3, [r3, #0]
    37de:	789b      	ldrb	r3, [r3, #2]
    37e0:	001a      	movs	r2, r3
    37e2:	4b27      	ldr	r3, [pc, #156]	; (3880 <USB_StdReq_Handler+0x10c>)
    37e4:	0092      	lsls	r2, r2, #2
    37e6:	58d3      	ldr	r3, [r2, r3]
    37e8:	781b      	ldrb	r3, [r3, #0]
    37ea:	001a      	movs	r2, r3
    37ec:	2000      	movs	r0, #0
    37ee:	f7ff fe21 	bl	3434 <EP_IN_Transfer>
                    break;
    37f2:	e002      	b.n	37fa <USB_StdReq_Handler+0x86>

                default:
                    USB_EP0_Stall();
    37f4:	f000 f96e 	bl	3ad4 <USB_EP0_Stall>
                    break;  
    37f8:	46c0      	nop			; (mov r8, r8)
            }
            break;
    37fa:	e033      	b.n	3864 <USB_StdReq_Handler+0xf0>

        case mSET_CONFIG:
            gu8Dummy=Setup_Pkt->wValue_h+Setup_Pkt->wValue_l;
    37fc:	4b1b      	ldr	r3, [pc, #108]	; (386c <USB_StdReq_Handler+0xf8>)
    37fe:	681b      	ldr	r3, [r3, #0]
    3800:	78da      	ldrb	r2, [r3, #3]
    3802:	4b1a      	ldr	r3, [pc, #104]	; (386c <USB_StdReq_Handler+0xf8>)
    3804:	681b      	ldr	r3, [r3, #0]
    3806:	789b      	ldrb	r3, [r3, #2]
    3808:	18d3      	adds	r3, r2, r3
    380a:	b2da      	uxtb	r2, r3
    380c:	4b1d      	ldr	r3, [pc, #116]	; (3884 <USB_StdReq_Handler+0x110>)
    380e:	701a      	strb	r2, [r3, #0]
            if(Setup_Pkt->wValue_h+Setup_Pkt->wValue_l) 
    3810:	4b16      	ldr	r3, [pc, #88]	; (386c <USB_StdReq_Handler+0xf8>)
    3812:	681b      	ldr	r3, [r3, #0]
    3814:	78db      	ldrb	r3, [r3, #3]
    3816:	001a      	movs	r2, r3
    3818:	4b14      	ldr	r3, [pc, #80]	; (386c <USB_StdReq_Handler+0xf8>)
    381a:	681b      	ldr	r3, [r3, #0]
    381c:	789b      	ldrb	r3, [r3, #2]
    381e:	18d3      	adds	r3, r2, r3
    3820:	2b00      	cmp	r3, #0
    3822:	d01e      	beq.n	3862 <USB_StdReq_Handler+0xee>
            {
                USB_Set_Interface();                         
    3824:	f7ff ff5e 	bl	36e4 <USB_Set_Interface>
                EP_IN_Transfer(EP0,0,0);
    3828:	2200      	movs	r2, #0
    382a:	2100      	movs	r1, #0
    382c:	2000      	movs	r0, #0
    382e:	f7ff fe01 	bl	3434 <EP_IN_Transfer>
                gu8USB_State=uENUMERATED;
    3832:	4b10      	ldr	r3, [pc, #64]	; (3874 <USB_StdReq_Handler+0x100>)
    3834:	2201      	movs	r2, #1
    3836:	701a      	strb	r2, [r3, #0]
            }
            break;
    3838:	e013      	b.n	3862 <USB_StdReq_Handler+0xee>
      
        case mGET_CONFIG:
            EP_IN_Transfer(EP0,(uint8*)&gu8Dummy,1);
    383a:	4b12      	ldr	r3, [pc, #72]	; (3884 <USB_StdReq_Handler+0x110>)
    383c:	2201      	movs	r2, #1
    383e:	0019      	movs	r1, r3
    3840:	2000      	movs	r0, #0
    3842:	f7ff fdf7 	bl	3434 <EP_IN_Transfer>
            break;
    3846:	e00d      	b.n	3864 <USB_StdReq_Handler+0xf0>

        case mGET_STATUS:
            gu8Status=0;
    3848:	4b0f      	ldr	r3, [pc, #60]	; (3888 <USB_StdReq_Handler+0x114>)
    384a:	2200      	movs	r2, #0
    384c:	801a      	strh	r2, [r3, #0]
            EP_IN_Transfer(EP0,(uint8*)&gu8Status,2);
    384e:	4b0e      	ldr	r3, [pc, #56]	; (3888 <USB_StdReq_Handler+0x114>)
    3850:	2202      	movs	r2, #2
    3852:	0019      	movs	r1, r3
    3854:	2000      	movs	r0, #0
    3856:	f7ff fded 	bl	3434 <EP_IN_Transfer>
            break;
    385a:	e003      	b.n	3864 <USB_StdReq_Handler+0xf0>


        default:
            USB_EP0_Stall();                              
    385c:	f000 f93a 	bl	3ad4 <USB_EP0_Stall>
            break;
    3860:	e000      	b.n	3864 <USB_StdReq_Handler+0xf0>
            break;
    3862:	46c0      	nop			; (mov r8, r8)
    }
}
    3864:	46c0      	nop			; (mov r8, r8)
    3866:	46bd      	mov	sp, r7
    3868:	bd80      	pop	{r7, pc}
    386a:	46c0      	nop			; (mov r8, r8)
    386c:	1ffff6a8 	.word	0x1ffff6a8
    3870:	00004c40 	.word	0x00004c40
    3874:	1ffff7e0 	.word	0x1ffff7e0
    3878:	00004b98 	.word	0x00004b98
    387c:	00004bec 	.word	0x00004bec
    3880:	1ffff488 	.word	0x1ffff488
    3884:	1ffff7e1 	.word	0x1ffff7e1
    3888:	1ffff6f0 	.word	0x1ffff6f0

0000388c <USB_Setup_Handler>:

/**********************************************************/
void USB_Setup_Handler(void)
{
    388c:	b590      	push	{r4, r7, lr}
    388e:	b083      	sub	sp, #12
    3890:	af00      	add	r7, sp, #0
    uint8 u8State;
    
    FLAG_CLR(0,gu8USB_Toogle_flags);
    3892:	4b24      	ldr	r3, [pc, #144]	; (3924 <USB_Setup_Handler+0x98>)
    3894:	781b      	ldrb	r3, [r3, #0]
    3896:	2201      	movs	r2, #1
    3898:	4393      	bics	r3, r2
    389a:	b2da      	uxtb	r2, r3
    389c:	4b21      	ldr	r3, [pc, #132]	; (3924 <USB_Setup_Handler+0x98>)
    389e:	701a      	strb	r2, [r3, #0]
    switch(Setup_Pkt->bmRequestType & 0x1F)
    38a0:	4b21      	ldr	r3, [pc, #132]	; (3928 <USB_Setup_Handler+0x9c>)
    38a2:	681b      	ldr	r3, [r3, #0]
    38a4:	781b      	ldrb	r3, [r3, #0]
    38a6:	001a      	movs	r2, r3
    38a8:	231f      	movs	r3, #31
    38aa:	4013      	ands	r3, r2
    38ac:	2b01      	cmp	r3, #1
    38ae:	d010      	beq.n	38d2 <USB_Setup_Handler+0x46>
    38b0:	2b02      	cmp	r3, #2
    38b2:	d01f      	beq.n	38f4 <USB_Setup_Handler+0x68>
    38b4:	2b00      	cmp	r3, #0
    38b6:	d123      	bne.n	3900 <USB_Setup_Handler+0x74>
    {
        case DEVICE_REQ:
            if((Setup_Pkt->bmRequestType & 0x1F)== STANDARD_REQ)
    38b8:	4b1b      	ldr	r3, [pc, #108]	; (3928 <USB_Setup_Handler+0x9c>)
    38ba:	681b      	ldr	r3, [r3, #0]
    38bc:	781b      	ldrb	r3, [r3, #0]
    38be:	001a      	movs	r2, r3
    38c0:	231f      	movs	r3, #31
    38c2:	4013      	ands	r3, r2
    38c4:	d101      	bne.n	38ca <USB_Setup_Handler+0x3e>
            {
                //tBDTtable[bEP0IN_ODD].Stat._byte= kUDATA1;
                
                USB_StdReq_Handler();            
    38c6:	f7ff ff55 	bl	3774 <USB_StdReq_Handler>
            }
            tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
    38ca:	4b18      	ldr	r3, [pc, #96]	; (392c <USB_Setup_Handler+0xa0>)
    38cc:	2288      	movs	r2, #136	; 0x88
    38ce:	701a      	strb	r2, [r3, #0]
            break;        
    38d0:	e019      	b.n	3906 <USB_Setup_Handler+0x7a>

        case INTERFACE_REQ:
            u8State=USB_InterfaceReq_Handler();    
    38d2:	1dfc      	adds	r4, r7, #7
    38d4:	f000 fad0 	bl	3e78 <CDC_InterfaceReq_Handler>
    38d8:	0003      	movs	r3, r0
    38da:	7023      	strb	r3, [r4, #0]

            if(u8State==uSETUP)
    38dc:	1dfb      	adds	r3, r7, #7
    38de:	781b      	ldrb	r3, [r3, #0]
    38e0:	2b00      	cmp	r3, #0
    38e2:	d103      	bne.n	38ec <USB_Setup_Handler+0x60>
                tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
    38e4:	4b11      	ldr	r3, [pc, #68]	; (392c <USB_Setup_Handler+0xa0>)
    38e6:	2288      	movs	r2, #136	; 0x88
    38e8:	701a      	strb	r2, [r3, #0]
            else
                tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA1;            
            break;        
    38ea:	e00c      	b.n	3906 <USB_Setup_Handler+0x7a>
                tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA1;            
    38ec:	4b0f      	ldr	r3, [pc, #60]	; (392c <USB_Setup_Handler+0xa0>)
    38ee:	22c8      	movs	r2, #200	; 0xc8
    38f0:	701a      	strb	r2, [r3, #0]
            break;        
    38f2:	e008      	b.n	3906 <USB_Setup_Handler+0x7a>

        case ENDPOINT_REQ:
            USB_Endpoint_Setup_Handler();
    38f4:	f000 f81e 	bl	3934 <USB_Endpoint_Setup_Handler>
            tBDTtable[bEP0OUT_ODD].Stat._byte= kUDATA0;
    38f8:	4b0c      	ldr	r3, [pc, #48]	; (392c <USB_Setup_Handler+0xa0>)
    38fa:	2288      	movs	r2, #136	; 0x88
    38fc:	701a      	strb	r2, [r3, #0]
            break;        
    38fe:	e002      	b.n	3906 <USB_Setup_Handler+0x7a>

        default:
            USB_EP0_Stall();  
    3900:	f000 f8e8 	bl	3ad4 <USB_EP0_Stall>
            break;        
    3904:	46c0      	nop			; (mov r8, r8)
    }
        
    //USB0_CTL&=!USB_CTL_TXSUSPENDTOKENBUSY_MASK;
      
    //CTL_TXSUSPEND_TOKENBUSY=0;
    FLAG_CLR(USB_CTL_TXSUSPENDTOKENBUSY_SHIFT,USB0_CTL);
    3906:	4a0a      	ldr	r2, [pc, #40]	; (3930 <USB_Setup_Handler+0xa4>)
    3908:	4909      	ldr	r1, [pc, #36]	; (3930 <USB_Setup_Handler+0xa4>)
    390a:	2394      	movs	r3, #148	; 0x94
    390c:	5ccb      	ldrb	r3, [r1, r3]
    390e:	b2db      	uxtb	r3, r3
    3910:	2120      	movs	r1, #32
    3912:	438b      	bics	r3, r1
    3914:	b2d9      	uxtb	r1, r3
    3916:	2394      	movs	r3, #148	; 0x94
    3918:	54d1      	strb	r1, [r2, r3]
}
    391a:	46c0      	nop			; (mov r8, r8)
    391c:	46bd      	mov	sp, r7
    391e:	b003      	add	sp, #12
    3920:	bd90      	pop	{r4, r7, pc}
    3922:	46c0      	nop			; (mov r8, r8)
    3924:	1ffff734 	.word	0x1ffff734
    3928:	1ffff6a8 	.word	0x1ffff6a8
    392c:	1ffff804 	.word	0x1ffff804
    3930:	40072000 	.word	0x40072000

00003934 <USB_Endpoint_Setup_Handler>:

/**********************************************************/
void USB_Endpoint_Setup_Handler(void)
{
    3934:	b580      	push	{r7, lr}
    3936:	b082      	sub	sp, #8
    3938:	af00      	add	r7, sp, #0
    uint16 u16Status;
    

    switch(Setup_Pkt->bRequest)
    393a:	4b2a      	ldr	r3, [pc, #168]	; (39e4 <USB_Endpoint_Setup_Handler+0xb0>)
    393c:	681b      	ldr	r3, [r3, #0]
    393e:	785b      	ldrb	r3, [r3, #1]
    3940:	2b01      	cmp	r3, #1
    3942:	d01e      	beq.n	3982 <USB_Endpoint_Setup_Handler+0x4e>
    3944:	2b03      	cmp	r3, #3
    3946:	d033      	beq.n	39b0 <USB_Endpoint_Setup_Handler+0x7c>
    3948:	2b00      	cmp	r3, #0
    394a:	d000      	beq.n	394e <USB_Endpoint_Setup_Handler+0x1a>
            FLAG_SET(Setup_Pkt->wIndex_h,gu8HALT_EP); 
            EP_IN_Transfer(EP0,0,0);
            break;

        default:
            break;
    394c:	e045      	b.n	39da <USB_Endpoint_Setup_Handler+0xa6>
            if(FLAG_CHK(Setup_Pkt->wIndex_h,gu8HALT_EP))
    394e:	4b26      	ldr	r3, [pc, #152]	; (39e8 <USB_Endpoint_Setup_Handler+0xb4>)
    3950:	781b      	ldrb	r3, [r3, #0]
    3952:	001a      	movs	r2, r3
    3954:	4b23      	ldr	r3, [pc, #140]	; (39e4 <USB_Endpoint_Setup_Handler+0xb0>)
    3956:	681b      	ldr	r3, [r3, #0]
    3958:	795b      	ldrb	r3, [r3, #5]
    395a:	411a      	asrs	r2, r3
    395c:	0013      	movs	r3, r2
    395e:	2201      	movs	r2, #1
    3960:	4013      	ands	r3, r2
    3962:	d004      	beq.n	396e <USB_Endpoint_Setup_Handler+0x3a>
                u16Status=0x0100;
    3964:	1dbb      	adds	r3, r7, #6
    3966:	2280      	movs	r2, #128	; 0x80
    3968:	0052      	lsls	r2, r2, #1
    396a:	801a      	strh	r2, [r3, #0]
    396c:	e002      	b.n	3974 <USB_Endpoint_Setup_Handler+0x40>
                u16Status=0x0000;
    396e:	1dbb      	adds	r3, r7, #6
    3970:	2200      	movs	r2, #0
    3972:	801a      	strh	r2, [r3, #0]
            EP_IN_Transfer(EP0,(uint8*)&u16Status,2);
    3974:	1dbb      	adds	r3, r7, #6
    3976:	2202      	movs	r2, #2
    3978:	0019      	movs	r1, r3
    397a:	2000      	movs	r0, #0
    397c:	f7ff fd5a 	bl	3434 <EP_IN_Transfer>
            break;
    3980:	e02b      	b.n	39da <USB_Endpoint_Setup_Handler+0xa6>
            FLAG_CLR(Setup_Pkt->wIndex_h,gu8HALT_EP); 
    3982:	4b18      	ldr	r3, [pc, #96]	; (39e4 <USB_Endpoint_Setup_Handler+0xb0>)
    3984:	681b      	ldr	r3, [r3, #0]
    3986:	795b      	ldrb	r3, [r3, #5]
    3988:	001a      	movs	r2, r3
    398a:	2301      	movs	r3, #1
    398c:	4093      	lsls	r3, r2
    398e:	b25b      	sxtb	r3, r3
    3990:	43db      	mvns	r3, r3
    3992:	b25b      	sxtb	r3, r3
    3994:	4a14      	ldr	r2, [pc, #80]	; (39e8 <USB_Endpoint_Setup_Handler+0xb4>)
    3996:	7812      	ldrb	r2, [r2, #0]
    3998:	b252      	sxtb	r2, r2
    399a:	4013      	ands	r3, r2
    399c:	b25b      	sxtb	r3, r3
    399e:	b2da      	uxtb	r2, r3
    39a0:	4b11      	ldr	r3, [pc, #68]	; (39e8 <USB_Endpoint_Setup_Handler+0xb4>)
    39a2:	701a      	strb	r2, [r3, #0]
            EP_IN_Transfer(EP0,0,0);
    39a4:	2200      	movs	r2, #0
    39a6:	2100      	movs	r1, #0
    39a8:	2000      	movs	r0, #0
    39aa:	f7ff fd43 	bl	3434 <EP_IN_Transfer>
            break;
    39ae:	e014      	b.n	39da <USB_Endpoint_Setup_Handler+0xa6>
            FLAG_SET(Setup_Pkt->wIndex_h,gu8HALT_EP); 
    39b0:	4b0c      	ldr	r3, [pc, #48]	; (39e4 <USB_Endpoint_Setup_Handler+0xb0>)
    39b2:	681b      	ldr	r3, [r3, #0]
    39b4:	795b      	ldrb	r3, [r3, #5]
    39b6:	001a      	movs	r2, r3
    39b8:	2301      	movs	r3, #1
    39ba:	4093      	lsls	r3, r2
    39bc:	b25a      	sxtb	r2, r3
    39be:	4b0a      	ldr	r3, [pc, #40]	; (39e8 <USB_Endpoint_Setup_Handler+0xb4>)
    39c0:	781b      	ldrb	r3, [r3, #0]
    39c2:	b25b      	sxtb	r3, r3
    39c4:	4313      	orrs	r3, r2
    39c6:	b25b      	sxtb	r3, r3
    39c8:	b2da      	uxtb	r2, r3
    39ca:	4b07      	ldr	r3, [pc, #28]	; (39e8 <USB_Endpoint_Setup_Handler+0xb4>)
    39cc:	701a      	strb	r2, [r3, #0]
            EP_IN_Transfer(EP0,0,0);
    39ce:	2200      	movs	r2, #0
    39d0:	2100      	movs	r1, #0
    39d2:	2000      	movs	r0, #0
    39d4:	f7ff fd2e 	bl	3434 <EP_IN_Transfer>
            break;
    39d8:	46c0      	nop			; (mov r8, r8)
    }
}
    39da:	46c0      	nop			; (mov r8, r8)
    39dc:	46bd      	mov	sp, r7
    39de:	b002      	add	sp, #8
    39e0:	bd80      	pop	{r7, pc}
    39e2:	46c0      	nop			; (mov r8, r8)
    39e4:	1ffff6a8 	.word	0x1ffff6a8
    39e8:	1ffff6cc 	.word	0x1ffff6cc

000039ec <USB_Handler>:

/**********************************************************/
void USB_Handler(void)
{
    39ec:	b580      	push	{r7, lr}
    39ee:	b082      	sub	sp, #8
    39f0:	af00      	add	r7, sp, #0
    uint8 u8EndPoint;
    uint8 u8IN;
    
    u8IN=USB0_STAT & 0x08;
    39f2:	4a22      	ldr	r2, [pc, #136]	; (3a7c <USB_Handler+0x90>)
    39f4:	2390      	movs	r3, #144	; 0x90
    39f6:	5cd3      	ldrb	r3, [r2, r3]
    39f8:	b2da      	uxtb	r2, r3
    39fa:	1dfb      	adds	r3, r7, #7
    39fc:	2108      	movs	r1, #8
    39fe:	400a      	ands	r2, r1
    3a00:	701a      	strb	r2, [r3, #0]
    u8EndPoint=USB0_STAT >> 4;
    3a02:	4a1e      	ldr	r2, [pc, #120]	; (3a7c <USB_Handler+0x90>)
    3a04:	2390      	movs	r3, #144	; 0x90
    3a06:	5cd3      	ldrb	r3, [r2, r3]
    3a08:	b2da      	uxtb	r2, r3
    3a0a:	1dbb      	adds	r3, r7, #6
    3a0c:	0912      	lsrs	r2, r2, #4
    3a0e:	701a      	strb	r2, [r3, #0]
    

    /* Data EndPoints */
    if(u8EndPoint)
    3a10:	1dbb      	adds	r3, r7, #6
    3a12:	781b      	ldrb	r3, [r3, #0]
    3a14:	2b00      	cmp	r3, #0
    3a16:	d019      	beq.n	3a4c <USB_Handler+0x60>
    {
        if(!u8IN)
    3a18:	1dfb      	adds	r3, r7, #7
    3a1a:	781b      	ldrb	r3, [r3, #0]
    3a1c:	2b00      	cmp	r3, #0
    3a1e:	d128      	bne.n	3a72 <USB_Handler+0x86>
        {
            usbMCU_CONTROL(u8EndPoint);
    3a20:	1dbb      	adds	r3, r7, #6
    3a22:	781b      	ldrb	r3, [r3, #0]
    3a24:	009a      	lsls	r2, r3, #2
    3a26:	4b16      	ldr	r3, [pc, #88]	; (3a80 <USB_Handler+0x94>)
    3a28:	00d2      	lsls	r2, r2, #3
    3a2a:	2100      	movs	r1, #0
    3a2c:	54d1      	strb	r1, [r2, r3]
            FLAG_SET(u8EndPoint,gu8USB_Flags);  
    3a2e:	1dbb      	adds	r3, r7, #6
    3a30:	781b      	ldrb	r3, [r3, #0]
    3a32:	2201      	movs	r2, #1
    3a34:	409a      	lsls	r2, r3
    3a36:	0013      	movs	r3, r2
    3a38:	b25a      	sxtb	r2, r3
    3a3a:	4b12      	ldr	r3, [pc, #72]	; (3a84 <USB_Handler+0x98>)
    3a3c:	781b      	ldrb	r3, [r3, #0]
    3a3e:	b25b      	sxtb	r3, r3
    3a40:	4313      	orrs	r3, r2
    3a42:	b25b      	sxtb	r3, r3
    3a44:	b2da      	uxtb	r2, r3
    3a46:	4b0f      	ldr	r3, [pc, #60]	; (3a84 <USB_Handler+0x98>)
    3a48:	701a      	strb	r2, [r3, #0]
            else
                USB_EP0_OUT_Handler();
        }

    }
}
    3a4a:	e012      	b.n	3a72 <USB_Handler+0x86>
        if(u8IN)
    3a4c:	1dfb      	adds	r3, r7, #7
    3a4e:	781b      	ldrb	r3, [r3, #0]
    3a50:	2b00      	cmp	r3, #0
    3a52:	d002      	beq.n	3a5a <USB_Handler+0x6e>
            USB_EP0_IN_Handler();        
    3a54:	f000 f818 	bl	3a88 <USB_EP0_IN_Handler>
}
    3a58:	e00b      	b.n	3a72 <USB_Handler+0x86>
            if(tBDTtable[bEP0OUT_ODD].Stat.RecPid.PID == mSETUP_TOKEN)
    3a5a:	4b09      	ldr	r3, [pc, #36]	; (3a80 <USB_Handler+0x94>)
    3a5c:	781b      	ldrb	r3, [r3, #0]
    3a5e:	223c      	movs	r2, #60	; 0x3c
    3a60:	4013      	ands	r3, r2
    3a62:	b2db      	uxtb	r3, r3
    3a64:	2b34      	cmp	r3, #52	; 0x34
    3a66:	d102      	bne.n	3a6e <USB_Handler+0x82>
                USB_Setup_Handler();
    3a68:	f7ff ff10 	bl	388c <USB_Setup_Handler>
}
    3a6c:	e001      	b.n	3a72 <USB_Handler+0x86>
                USB_EP0_OUT_Handler();
    3a6e:	f000 f84b 	bl	3b08 <USB_EP0_OUT_Handler>
}
    3a72:	46c0      	nop			; (mov r8, r8)
    3a74:	46bd      	mov	sp, r7
    3a76:	b002      	add	sp, #8
    3a78:	bd80      	pop	{r7, pc}
    3a7a:	46c0      	nop			; (mov r8, r8)
    3a7c:	40072000 	.word	0x40072000
    3a80:	1ffff804 	.word	0x1ffff804
    3a84:	1ffff778 	.word	0x1ffff778

00003a88 <USB_EP0_IN_Handler>:

/**********************************************************/
void USB_EP0_IN_Handler(void)
{
    3a88:	b580      	push	{r7, lr}
    3a8a:	af00      	add	r7, sp, #0
    if(gu8USB_State==uADDRESS)
    3a8c:	4b0d      	ldr	r3, [pc, #52]	; (3ac4 <USB_EP0_IN_Handler+0x3c>)
    3a8e:	781b      	ldrb	r3, [r3, #0]
    3a90:	2b03      	cmp	r3, #3
    3a92:	d10f      	bne.n	3ab4 <USB_EP0_IN_Handler+0x2c>
    {
        USB0_ADDR = Setup_Pkt->wValue_l;
    3a94:	4a0c      	ldr	r2, [pc, #48]	; (3ac8 <USB_EP0_IN_Handler+0x40>)
    3a96:	4b0d      	ldr	r3, [pc, #52]	; (3acc <USB_EP0_IN_Handler+0x44>)
    3a98:	681b      	ldr	r3, [r3, #0]
    3a9a:	7899      	ldrb	r1, [r3, #2]
    3a9c:	2398      	movs	r3, #152	; 0x98
    3a9e:	54d1      	strb	r1, [r2, r3]
        gu8USB_State=uREADY;
    3aa0:	4b08      	ldr	r3, [pc, #32]	; (3ac4 <USB_EP0_IN_Handler+0x3c>)
    3aa2:	2204      	movs	r2, #4
    3aa4:	701a      	strb	r2, [r3, #0]
        FLAG_SET(fIN,gu8USBClearFlags);
    3aa6:	4b0a      	ldr	r3, [pc, #40]	; (3ad0 <USB_EP0_IN_Handler+0x48>)
    3aa8:	781b      	ldrb	r3, [r3, #0]
    3aaa:	2201      	movs	r2, #1
    3aac:	4313      	orrs	r3, r2
    3aae:	b2da      	uxtb	r2, r3
    3ab0:	4b07      	ldr	r3, [pc, #28]	; (3ad0 <USB_EP0_IN_Handler+0x48>)
    3ab2:	701a      	strb	r2, [r3, #0]
    }
    EP_IN_Transfer(0,0,0);    
    3ab4:	2200      	movs	r2, #0
    3ab6:	2100      	movs	r1, #0
    3ab8:	2000      	movs	r0, #0
    3aba:	f7ff fcbb 	bl	3434 <EP_IN_Transfer>
}
    3abe:	46c0      	nop			; (mov r8, r8)
    3ac0:	46bd      	mov	sp, r7
    3ac2:	bd80      	pop	{r7, pc}
    3ac4:	1ffff7e0 	.word	0x1ffff7e0
    3ac8:	40072000 	.word	0x40072000
    3acc:	1ffff6a8 	.word	0x1ffff6a8
    3ad0:	1ffff79c 	.word	0x1ffff79c

00003ad4 <USB_EP0_Stall>:


/**********************************************************/
void USB_EP0_Stall(void)
{
    3ad4:	b580      	push	{r7, lr}
    3ad6:	af00      	add	r7, sp, #0
   
    FLAG_SET(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0);
    3ad8:	4a09      	ldr	r2, [pc, #36]	; (3b00 <USB_EP0_Stall+0x2c>)
    3ada:	4909      	ldr	r1, [pc, #36]	; (3b00 <USB_EP0_Stall+0x2c>)
    3adc:	23c0      	movs	r3, #192	; 0xc0
    3ade:	5ccb      	ldrb	r3, [r1, r3]
    3ae0:	b2db      	uxtb	r3, r3
    3ae2:	2102      	movs	r1, #2
    3ae4:	430b      	orrs	r3, r1
    3ae6:	b2d9      	uxtb	r1, r3
    3ae8:	23c0      	movs	r3, #192	; 0xc0
    3aea:	54d1      	strb	r1, [r2, r3]
    //ENDPT0_EP_STALL = 1;                      
    tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA0; 
    3aec:	4b05      	ldr	r3, [pc, #20]	; (3b04 <USB_EP0_Stall+0x30>)
    3aee:	2288      	movs	r2, #136	; 0x88
    3af0:	701a      	strb	r2, [r3, #0]
    tBDTtable[bEP0OUT_ODD].Cnt = EP0_SIZE;       
    3af2:	4b04      	ldr	r3, [pc, #16]	; (3b04 <USB_EP0_Stall+0x30>)
    3af4:	2220      	movs	r2, #32
    3af6:	805a      	strh	r2, [r3, #2]
}
    3af8:	46c0      	nop			; (mov r8, r8)
    3afa:	46bd      	mov	sp, r7
    3afc:	bd80      	pop	{r7, pc}
    3afe:	46c0      	nop			; (mov r8, r8)
    3b00:	40072000 	.word	0x40072000
    3b04:	1ffff804 	.word	0x1ffff804

00003b08 <USB_EP0_OUT_Handler>:


/**********************************************************/
void USB_EP0_OUT_Handler(void)
{
    3b08:	b580      	push	{r7, lr}
    3b0a:	af00      	add	r7, sp, #0
    
    FLAG_SET(0,gu8USB_Flags);
    3b0c:	4b06      	ldr	r3, [pc, #24]	; (3b28 <USB_EP0_OUT_Handler+0x20>)
    3b0e:	781b      	ldrb	r3, [r3, #0]
    3b10:	2201      	movs	r2, #1
    3b12:	4313      	orrs	r3, r2
    3b14:	b2da      	uxtb	r2, r3
    3b16:	4b04      	ldr	r3, [pc, #16]	; (3b28 <USB_EP0_OUT_Handler+0x20>)
    3b18:	701a      	strb	r2, [r3, #0]
    //tBDTtable[bEP0OUT_ODD].Cnt = EP0_SIZE; 
    tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA0;
    3b1a:	4b04      	ldr	r3, [pc, #16]	; (3b2c <USB_EP0_OUT_Handler+0x24>)
    3b1c:	2288      	movs	r2, #136	; 0x88
    3b1e:	701a      	strb	r2, [r3, #0]
    //tBDTtable[bEP0IN].Stat._byte = kUDATA1;      
    
}
    3b20:	46c0      	nop			; (mov r8, r8)
    3b22:	46bd      	mov	sp, r7
    3b24:	bd80      	pop	{r7, pc}
    3b26:	46c0      	nop			; (mov r8, r8)
    3b28:	1ffff778 	.word	0x1ffff778
    3b2c:	1ffff804 	.word	0x1ffff804

00003b30 <USB_Stall_Handler>:


/**********************************************************/
void USB_Stall_Handler(void) 
{
    3b30:	b580      	push	{r7, lr}
    3b32:	af00      	add	r7, sp, #0
    if(FLAG_CHK(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0))
    3b34:	4a0f      	ldr	r2, [pc, #60]	; (3b74 <USB_Stall_Handler+0x44>)
    3b36:	23c0      	movs	r3, #192	; 0xc0
    3b38:	5cd3      	ldrb	r3, [r2, r3]
    3b3a:	b2db      	uxtb	r3, r3
    3b3c:	001a      	movs	r2, r3
    3b3e:	2302      	movs	r3, #2
    3b40:	4013      	ands	r3, r2
    3b42:	d009      	beq.n	3b58 <USB_Stall_Handler+0x28>
        FLAG_CLR(USB_ENDPT_EPSTALL_SHIFT,USB0_ENDPT0);
    3b44:	4a0b      	ldr	r2, [pc, #44]	; (3b74 <USB_Stall_Handler+0x44>)
    3b46:	490b      	ldr	r1, [pc, #44]	; (3b74 <USB_Stall_Handler+0x44>)
    3b48:	23c0      	movs	r3, #192	; 0xc0
    3b4a:	5ccb      	ldrb	r3, [r1, r3]
    3b4c:	b2db      	uxtb	r3, r3
    3b4e:	2102      	movs	r1, #2
    3b50:	438b      	bics	r3, r1
    3b52:	b2d9      	uxtb	r1, r3
    3b54:	23c0      	movs	r3, #192	; 0xc0
    3b56:	54d1      	strb	r1, [r2, r3]
    FLAG_SET(USB_ISTAT_STALL_SHIFT,USB0_ISTAT);
    3b58:	4906      	ldr	r1, [pc, #24]	; (3b74 <USB_Stall_Handler+0x44>)
    3b5a:	4a06      	ldr	r2, [pc, #24]	; (3b74 <USB_Stall_Handler+0x44>)
    3b5c:	2380      	movs	r3, #128	; 0x80
    3b5e:	5cd3      	ldrb	r3, [r2, r3]
    3b60:	b2db      	uxtb	r3, r3
    3b62:	2280      	movs	r2, #128	; 0x80
    3b64:	4252      	negs	r2, r2
    3b66:	4313      	orrs	r3, r2
    3b68:	b2da      	uxtb	r2, r3
    3b6a:	2380      	movs	r3, #128	; 0x80
    3b6c:	54ca      	strb	r2, [r1, r3]
}
    3b6e:	46c0      	nop			; (mov r8, r8)
    3b70:	46bd      	mov	sp, r7
    3b72:	bd80      	pop	{r7, pc}
    3b74:	40072000 	.word	0x40072000

00003b78 <USB_Reset_Handler>:


/**********************************************************/
void USB_Reset_Handler(void)
{
    3b78:	b580      	push	{r7, lr}
    3b7a:	af00      	add	r7, sp, #0
    /* Software Flags */
    gu8USBClearFlags=0xFF;
    3b7c:	4b47      	ldr	r3, [pc, #284]	; (3c9c <USB_Reset_Handler+0x124>)
    3b7e:	22ff      	movs	r2, #255	; 0xff
    3b80:	701a      	strb	r2, [r3, #0]
    gu8USB_Toogle_flags=0;
    3b82:	4b47      	ldr	r3, [pc, #284]	; (3ca0 <USB_Reset_Handler+0x128>)
    3b84:	2200      	movs	r2, #0
    3b86:	701a      	strb	r2, [r3, #0]
    gu8USB_PingPong_flags=0x00;
    3b88:	4b46      	ldr	r3, [pc, #280]	; (3ca4 <USB_Reset_Handler+0x12c>)
    3b8a:	2200      	movs	r2, #0
    3b8c:	701a      	strb	r2, [r3, #0]
    
    /* Disable all data EP registers */
    USB0_ENDPT1=0x00;
    3b8e:	4a46      	ldr	r2, [pc, #280]	; (3ca8 <USB_Reset_Handler+0x130>)
    3b90:	23c4      	movs	r3, #196	; 0xc4
    3b92:	2100      	movs	r1, #0
    3b94:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT2=0x00;
    3b96:	4a44      	ldr	r2, [pc, #272]	; (3ca8 <USB_Reset_Handler+0x130>)
    3b98:	23c8      	movs	r3, #200	; 0xc8
    3b9a:	2100      	movs	r1, #0
    3b9c:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT3=0x00;
    3b9e:	4a42      	ldr	r2, [pc, #264]	; (3ca8 <USB_Reset_Handler+0x130>)
    3ba0:	23cc      	movs	r3, #204	; 0xcc
    3ba2:	2100      	movs	r1, #0
    3ba4:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT4=0x00;
    3ba6:	4a40      	ldr	r2, [pc, #256]	; (3ca8 <USB_Reset_Handler+0x130>)
    3ba8:	23d0      	movs	r3, #208	; 0xd0
    3baa:	2100      	movs	r1, #0
    3bac:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT5=0x00;
    3bae:	4a3e      	ldr	r2, [pc, #248]	; (3ca8 <USB_Reset_Handler+0x130>)
    3bb0:	23d4      	movs	r3, #212	; 0xd4
    3bb2:	2100      	movs	r1, #0
    3bb4:	54d1      	strb	r1, [r2, r3]
    USB0_ENDPT6=0x00;
    3bb6:	4a3c      	ldr	r2, [pc, #240]	; (3ca8 <USB_Reset_Handler+0x130>)
    3bb8:	23d8      	movs	r3, #216	; 0xd8
    3bba:	2100      	movs	r1, #0
    3bbc:	54d1      	strb	r1, [r2, r3]

    /* EP0 BDT Setup */
    // EP0 OUT BDT Settings
    tBDTtable[bEP0OUT_ODD].Cnt = EP0_SIZE;
    3bbe:	4b3b      	ldr	r3, [pc, #236]	; (3cac <USB_Reset_Handler+0x134>)
    3bc0:	2220      	movs	r2, #32
    3bc2:	805a      	strh	r2, [r3, #2]
    tBDTtable[bEP0OUT_ODD].Addr =(uint32)gu8EP0_OUT_ODD_Buffer;
    3bc4:	4a3a      	ldr	r2, [pc, #232]	; (3cb0 <USB_Reset_Handler+0x138>)
    3bc6:	4b39      	ldr	r3, [pc, #228]	; (3cac <USB_Reset_Handler+0x134>)
    3bc8:	605a      	str	r2, [r3, #4]
    tBDTtable[bEP0OUT_ODD].Stat._byte = kUDATA1;         
    3bca:	4b38      	ldr	r3, [pc, #224]	; (3cac <USB_Reset_Handler+0x134>)
    3bcc:	22c8      	movs	r2, #200	; 0xc8
    3bce:	701a      	strb	r2, [r3, #0]
    // EP0 OUT BDT Settings 
    tBDTtable[bEP0OUT_EVEN].Cnt = EP0_SIZE;
    3bd0:	4b36      	ldr	r3, [pc, #216]	; (3cac <USB_Reset_Handler+0x134>)
    3bd2:	2220      	movs	r2, #32
    3bd4:	815a      	strh	r2, [r3, #10]
    tBDTtable[bEP0OUT_EVEN].Addr =(uint32)gu8EP0_OUT_EVEN_Buffer;
    3bd6:	4a37      	ldr	r2, [pc, #220]	; (3cb4 <USB_Reset_Handler+0x13c>)
    3bd8:	4b34      	ldr	r3, [pc, #208]	; (3cac <USB_Reset_Handler+0x134>)
    3bda:	60da      	str	r2, [r3, #12]
    tBDTtable[bEP0OUT_EVEN].Stat._byte = kUDATA1;         
    3bdc:	4b33      	ldr	r3, [pc, #204]	; (3cac <USB_Reset_Handler+0x134>)
    3bde:	22c8      	movs	r2, #200	; 0xc8
    3be0:	721a      	strb	r2, [r3, #8]
    // EP0 IN BDT Settings 
    tBDTtable[bEP0IN_ODD].Cnt = EP0_SIZE;              
    3be2:	4b32      	ldr	r3, [pc, #200]	; (3cac <USB_Reset_Handler+0x134>)
    3be4:	2220      	movs	r2, #32
    3be6:	825a      	strh	r2, [r3, #18]
    tBDTtable[bEP0IN_ODD].Addr =(uint32)gu8EP0_IN_ODD_Buffer;      
    3be8:	4a33      	ldr	r2, [pc, #204]	; (3cb8 <USB_Reset_Handler+0x140>)
    3bea:	4b30      	ldr	r3, [pc, #192]	; (3cac <USB_Reset_Handler+0x134>)
    3bec:	615a      	str	r2, [r3, #20]
    tBDTtable[bEP0IN_ODD].Stat._byte = kUDATA0;   
    3bee:	4b2f      	ldr	r3, [pc, #188]	; (3cac <USB_Reset_Handler+0x134>)
    3bf0:	2288      	movs	r2, #136	; 0x88
    3bf2:	741a      	strb	r2, [r3, #16]
    // EP0 IN BDT Settings 
    tBDTtable[bEP0IN_EVEN].Cnt = (EP0_SIZE);              
    3bf4:	4b2d      	ldr	r3, [pc, #180]	; (3cac <USB_Reset_Handler+0x134>)
    3bf6:	2220      	movs	r2, #32
    3bf8:	835a      	strh	r2, [r3, #26]
    tBDTtable[bEP0IN_EVEN].Addr =(uint32)gu8EP0_IN_EVEN_Buffer;      
    3bfa:	4a30      	ldr	r2, [pc, #192]	; (3cbc <USB_Reset_Handler+0x144>)
    3bfc:	4b2b      	ldr	r3, [pc, #172]	; (3cac <USB_Reset_Handler+0x134>)
    3bfe:	61da      	str	r2, [r3, #28]
    tBDTtable[bEP0IN_EVEN].Stat._byte = kUDATA0;        
    3c00:	4b2a      	ldr	r3, [pc, #168]	; (3cac <USB_Reset_Handler+0x134>)
    3c02:	2288      	movs	r2, #136	; 0x88
    3c04:	761a      	strb	r2, [r3, #24]

    // Enable EP0
    USB0_ENDPT0=0x0D;
    3c06:	4a28      	ldr	r2, [pc, #160]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c08:	23c0      	movs	r3, #192	; 0xc0
    3c0a:	210d      	movs	r1, #13
    3c0c:	54d1      	strb	r1, [r2, r3]

    // Clear all Error flags
    USB0_ERRSTAT=0xFF;
    3c0e:	4a26      	ldr	r2, [pc, #152]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c10:	2388      	movs	r3, #136	; 0x88
    3c12:	21ff      	movs	r1, #255	; 0xff
    3c14:	54d1      	strb	r1, [r2, r3]
    
    // CLear all USB ISR flags
    USB0_ISTAT=0xFF;
    3c16:	4a24      	ldr	r2, [pc, #144]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c18:	2380      	movs	r3, #128	; 0x80
    3c1a:	21ff      	movs	r1, #255	; 0xff
    3c1c:	54d1      	strb	r1, [r2, r3]

    // Set default Address
    USB0_ADDR=0x00;
    3c1e:	4a22      	ldr	r2, [pc, #136]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c20:	2398      	movs	r3, #152	; 0x98
    3c22:	2100      	movs	r1, #0
    3c24:	54d1      	strb	r1, [r2, r3]

    // Enable all error sources
    USB0_ERREN=0xFF;
    3c26:	4a20      	ldr	r2, [pc, #128]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c28:	238c      	movs	r3, #140	; 0x8c
    3c2a:	21ff      	movs	r1, #255	; 0xff
    3c2c:	54d1      	strb	r1, [r2, r3]

    // USB Interrupt Enablers
    FLAG_SET(USB_INTEN_TOKDNEEN_SHIFT,USB0_INTEN);
    3c2e:	4a1e      	ldr	r2, [pc, #120]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c30:	491d      	ldr	r1, [pc, #116]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c32:	2384      	movs	r3, #132	; 0x84
    3c34:	5ccb      	ldrb	r3, [r1, r3]
    3c36:	b2db      	uxtb	r3, r3
    3c38:	2108      	movs	r1, #8
    3c3a:	430b      	orrs	r3, r1
    3c3c:	b2d9      	uxtb	r1, r3
    3c3e:	2384      	movs	r3, #132	; 0x84
    3c40:	54d1      	strb	r1, [r2, r3]
    FLAG_SET(USB_INTEN_SOFTOKEN_SHIFT,USB0_INTEN);
    3c42:	4a19      	ldr	r2, [pc, #100]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c44:	4918      	ldr	r1, [pc, #96]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c46:	2384      	movs	r3, #132	; 0x84
    3c48:	5ccb      	ldrb	r3, [r1, r3]
    3c4a:	b2db      	uxtb	r3, r3
    3c4c:	2104      	movs	r1, #4
    3c4e:	430b      	orrs	r3, r1
    3c50:	b2d9      	uxtb	r1, r3
    3c52:	2384      	movs	r3, #132	; 0x84
    3c54:	54d1      	strb	r1, [r2, r3]
    FLAG_SET(USB_INTEN_ERROREN_SHIFT,USB0_INTEN); 
    3c56:	4a14      	ldr	r2, [pc, #80]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c58:	4913      	ldr	r1, [pc, #76]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c5a:	2384      	movs	r3, #132	; 0x84
    3c5c:	5ccb      	ldrb	r3, [r1, r3]
    3c5e:	b2db      	uxtb	r3, r3
    3c60:	2102      	movs	r1, #2
    3c62:	430b      	orrs	r3, r1
    3c64:	b2d9      	uxtb	r1, r3
    3c66:	2384      	movs	r3, #132	; 0x84
    3c68:	54d1      	strb	r1, [r2, r3]
    FLAG_SET(USB_INTEN_USBRSTEN_SHIFT,USB0_INTEN);
    3c6a:	4a0f      	ldr	r2, [pc, #60]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c6c:	490e      	ldr	r1, [pc, #56]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c6e:	2384      	movs	r3, #132	; 0x84
    3c70:	5ccb      	ldrb	r3, [r1, r3]
    3c72:	b2db      	uxtb	r3, r3
    3c74:	2101      	movs	r1, #1
    3c76:	430b      	orrs	r3, r1
    3c78:	b2d9      	uxtb	r1, r3
    3c7a:	2384      	movs	r3, #132	; 0x84
    3c7c:	54d1      	strb	r1, [r2, r3]
    FLAG_SET(USB_INTEN_STALLEN_SHIFT,USB0_INTEN);    
    3c7e:	490a      	ldr	r1, [pc, #40]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c80:	4a09      	ldr	r2, [pc, #36]	; (3ca8 <USB_Reset_Handler+0x130>)
    3c82:	2384      	movs	r3, #132	; 0x84
    3c84:	5cd3      	ldrb	r3, [r2, r3]
    3c86:	b2db      	uxtb	r3, r3
    3c88:	2280      	movs	r2, #128	; 0x80
    3c8a:	4252      	negs	r2, r2
    3c8c:	4313      	orrs	r3, r2
    3c8e:	b2da      	uxtb	r2, r3
    3c90:	2384      	movs	r3, #132	; 0x84
    3c92:	54ca      	strb	r2, [r1, r3]
}
    3c94:	46c0      	nop			; (mov r8, r8)
    3c96:	46bd      	mov	sp, r7
    3c98:	bd80      	pop	{r7, pc}
    3c9a:	46c0      	nop			; (mov r8, r8)
    3c9c:	1ffff79c 	.word	0x1ffff79c
    3ca0:	1ffff734 	.word	0x1ffff734
    3ca4:	1ffff6cd 	.word	0x1ffff6cd
    3ca8:	40072000 	.word	0x40072000
    3cac:	1ffff804 	.word	0x1ffff804
    3cb0:	1ffff714 	.word	0x1ffff714
    3cb4:	1ffff7c0 	.word	0x1ffff7c0
    3cb8:	1ffff7a0 	.word	0x1ffff7a0
    3cbc:	1ffff888 	.word	0x1ffff888

00003cc0 <USB_ISR>:



/**********************************************************/
void USB_ISR(void)
{
    3cc0:	b580      	push	{r7, lr}
    3cc2:	af00      	add	r7, sp, #0
  
    if(FLAG_CHK(USB_ISTAT_USBRST_SHIFT,USB0_ISTAT)) 
    3cc4:	4a33      	ldr	r2, [pc, #204]	; (3d94 <USB_ISR+0xd4>)
    3cc6:	2380      	movs	r3, #128	; 0x80
    3cc8:	5cd3      	ldrb	r3, [r2, r3]
    3cca:	b2db      	uxtb	r3, r3
    3ccc:	001a      	movs	r2, r3
    3cce:	2301      	movs	r3, #1
    3cd0:	4013      	ands	r3, r2
    3cd2:	d002      	beq.n	3cda <USB_ISR+0x1a>
    {
        // Clear Reset Flag 
        //USB0_ISTAT = USB_ISTAT_USBRST_MASK;   

        // Handle RESET Interrupt 
        USB_Reset_Handler();
    3cd4:	f7ff ff50 	bl	3b78 <USB_Reset_Handler>
        // Clearing this bit allows the SIE to continue token processing
        //   and clear suspend condition 
        //CTL_TXSUSPEND_TOKENBUSY = 0;
        //FLAG_CLR(USB_CTL_TXSUSPENDTOKENBUSY_SHIFT,USB0_CTL);
        // No need to process other interrupts 
        return;
    3cd8:	e05a      	b.n	3d90 <USB_ISR+0xd0>
    }
    
    
    if(FLAG_CHK(USB_ISTAT_SOFTOK_SHIFT,USB0_ISTAT)) 
    3cda:	4a2e      	ldr	r2, [pc, #184]	; (3d94 <USB_ISR+0xd4>)
    3cdc:	2380      	movs	r3, #128	; 0x80
    3cde:	5cd3      	ldrb	r3, [r2, r3]
    3ce0:	b2db      	uxtb	r3, r3
    3ce2:	001a      	movs	r2, r3
    3ce4:	2304      	movs	r3, #4
    3ce6:	4013      	ands	r3, r2
    3ce8:	d003      	beq.n	3cf2 <USB_ISR+0x32>
    {
        USB0_ISTAT = USB_ISTAT_SOFTOK_MASK;   
    3cea:	4a2a      	ldr	r2, [pc, #168]	; (3d94 <USB_ISR+0xd4>)
    3cec:	2380      	movs	r3, #128	; 0x80
    3cee:	2104      	movs	r1, #4
    3cf0:	54d1      	strb	r1, [r2, r3]
    }
    
    
    
    if(FLAG_CHK(USB_ISTAT_STALL_SHIFT,USB0_ISTAT)) 
    3cf2:	4a28      	ldr	r2, [pc, #160]	; (3d94 <USB_ISR+0xd4>)
    3cf4:	2380      	movs	r3, #128	; 0x80
    3cf6:	5cd3      	ldrb	r3, [r2, r3]
    3cf8:	b2db      	uxtb	r3, r3
    3cfa:	b25b      	sxtb	r3, r3
    3cfc:	2b00      	cmp	r3, #0
    3cfe:	da01      	bge.n	3d04 <USB_ISR+0x44>
    //if(INT_STAT_STALL && INT_ENB_STALL_EN )
    {
        USB_Stall_Handler();
    3d00:	f7ff ff16 	bl	3b30 <USB_Stall_Handler>
    }
    
    
     if(FLAG_CHK(USB_ISTAT_TOKDNE_SHIFT,USB0_ISTAT)) 
    3d04:	4a23      	ldr	r2, [pc, #140]	; (3d94 <USB_ISR+0xd4>)
    3d06:	2380      	movs	r3, #128	; 0x80
    3d08:	5cd3      	ldrb	r3, [r2, r3]
    3d0a:	b2db      	uxtb	r3, r3
    3d0c:	001a      	movs	r2, r3
    3d0e:	2308      	movs	r3, #8
    3d10:	4013      	ands	r3, r2
    3d12:	d015      	beq.n	3d40 <USB_ISR+0x80>
    {

        FLAG_SET(USB_CTL_ODDRST_SHIFT,USB0_CTL);
    3d14:	4a1f      	ldr	r2, [pc, #124]	; (3d94 <USB_ISR+0xd4>)
    3d16:	491f      	ldr	r1, [pc, #124]	; (3d94 <USB_ISR+0xd4>)
    3d18:	2394      	movs	r3, #148	; 0x94
    3d1a:	5ccb      	ldrb	r3, [r1, r3]
    3d1c:	b2db      	uxtb	r3, r3
    3d1e:	2102      	movs	r1, #2
    3d20:	430b      	orrs	r3, r1
    3d22:	b2d9      	uxtb	r1, r3
    3d24:	2394      	movs	r3, #148	; 0x94
    3d26:	54d1      	strb	r1, [r2, r3]
        USB_Handler();
    3d28:	f7ff fe60 	bl	39ec <USB_Handler>
        FLAG_SET(USB_ISTAT_TOKDNE_SHIFT,USB0_ISTAT);
    3d2c:	4a19      	ldr	r2, [pc, #100]	; (3d94 <USB_ISR+0xd4>)
    3d2e:	4919      	ldr	r1, [pc, #100]	; (3d94 <USB_ISR+0xd4>)
    3d30:	2380      	movs	r3, #128	; 0x80
    3d32:	5ccb      	ldrb	r3, [r1, r3]
    3d34:	b2db      	uxtb	r3, r3
    3d36:	2108      	movs	r1, #8
    3d38:	430b      	orrs	r3, r1
    3d3a:	b2d9      	uxtb	r1, r3
    3d3c:	2380      	movs	r3, #128	; 0x80
    3d3e:	54d1      	strb	r1, [r2, r3]
    }
    
    
    if(FLAG_CHK(USB_ISTAT_SLEEP_SHIFT,USB0_ISTAT)) 
    3d40:	4a14      	ldr	r2, [pc, #80]	; (3d94 <USB_ISR+0xd4>)
    3d42:	2380      	movs	r3, #128	; 0x80
    3d44:	5cd3      	ldrb	r3, [r2, r3]
    3d46:	b2db      	uxtb	r3, r3
    3d48:	001a      	movs	r2, r3
    3d4a:	2310      	movs	r3, #16
    3d4c:	4013      	ands	r3, r2
    3d4e:	d009      	beq.n	3d64 <USB_ISR+0xa4>
        //INT_STAT = INT_STAT_RESUME_MASK;
          //u8ISRCounter++;  
      //FLAG_SET(USB_ISTAT_RESUME_SHIFT,USB0_ISTAT);
        
        // Clear SLEEP Interrupt 
        FLAG_SET(USB_ISTAT_SLEEP_SHIFT,USB0_ISTAT);
    3d50:	4a10      	ldr	r2, [pc, #64]	; (3d94 <USB_ISR+0xd4>)
    3d52:	4910      	ldr	r1, [pc, #64]	; (3d94 <USB_ISR+0xd4>)
    3d54:	2380      	movs	r3, #128	; 0x80
    3d56:	5ccb      	ldrb	r3, [r1, r3]
    3d58:	b2db      	uxtb	r3, r3
    3d5a:	2110      	movs	r1, #16
    3d5c:	430b      	orrs	r3, r1
    3d5e:	b2d9      	uxtb	r1, r3
    3d60:	2380      	movs	r3, #128	; 0x80
    3d62:	54d1      	strb	r1, [r2, r3]
        //FLAG_SET(USB0_INTEN_RESUME_SHIFT,USB0_ISTAT);
        //INT_ENB_RESUME_EN = 1;
        
    }
    
    if(FLAG_CHK(USB_ISTAT_ERROR_SHIFT,USB0_ISTAT)) 
    3d64:	4a0b      	ldr	r2, [pc, #44]	; (3d94 <USB_ISR+0xd4>)
    3d66:	2380      	movs	r3, #128	; 0x80
    3d68:	5cd3      	ldrb	r3, [r2, r3]
    3d6a:	b2db      	uxtb	r3, r3
    3d6c:	001a      	movs	r2, r3
    3d6e:	2302      	movs	r3, #2
    3d70:	4013      	ands	r3, r2
    3d72:	d00d      	beq.n	3d90 <USB_ISR+0xd0>
    //if(INT_STAT_ERROR && INT_ENB_ERROR_EN )
    {
        FLAG_SET(USB_ISTAT_ERROR_SHIFT,USB0_ISTAT);
    3d74:	4a07      	ldr	r2, [pc, #28]	; (3d94 <USB_ISR+0xd4>)
    3d76:	4907      	ldr	r1, [pc, #28]	; (3d94 <USB_ISR+0xd4>)
    3d78:	2380      	movs	r3, #128	; 0x80
    3d7a:	5ccb      	ldrb	r3, [r1, r3]
    3d7c:	b2db      	uxtb	r3, r3
    3d7e:	2102      	movs	r1, #2
    3d80:	430b      	orrs	r3, r1
    3d82:	b2d9      	uxtb	r1, r3
    3d84:	2380      	movs	r3, #128	; 0x80
    3d86:	54d1      	strb	r1, [r2, r3]
        USB0_ERRSTAT=0xFF;
    3d88:	4a02      	ldr	r2, [pc, #8]	; (3d94 <USB_ISR+0xd4>)
    3d8a:	2388      	movs	r3, #136	; 0x88
    3d8c:	21ff      	movs	r1, #255	; 0xff
    3d8e:	54d1      	strb	r1, [r2, r3]
        //printf("\nUSB Error\n");
        //printf("ERRSTAT = 0x%02X\n", USB0_ERRSTAT);
        //INT_STAT_ERROR=1;

    }
}
    3d90:	46bd      	mov	sp, r7
    3d92:	bd80      	pop	{r7, pc}
    3d94:	40072000 	.word	0x40072000

00003d98 <CDC_Init>:



/**********************************************************/
void CDC_Init(void)
{
    3d98:	b580      	push	{r7, lr}
    3d9a:	af00      	add	r7, sp, #0
    u8CDCState=0;
    3d9c:	4b12      	ldr	r3, [pc, #72]	; (3de8 <CDC_Init+0x50>)
    3d9e:	2200      	movs	r2, #0
    3da0:	701a      	strb	r2, [r3, #0]
    
    /* USB Initialization */
    USB_Init();
    3da2:	f7ff fac5 	bl	3330 <USB_Init>
    
    /** Enable SOF ouput */
    PORTC_PCR7 |= PORT_PCR_MUX(3);
    3da6:	4b11      	ldr	r3, [pc, #68]	; (3dec <CDC_Init+0x54>)
    3da8:	4a10      	ldr	r2, [pc, #64]	; (3dec <CDC_Init+0x54>)
    3daa:	69d2      	ldr	r2, [r2, #28]
    3dac:	21c0      	movs	r1, #192	; 0xc0
    3dae:	0089      	lsls	r1, r1, #2
    3db0:	430a      	orrs	r2, r1
    3db2:	61da      	str	r2, [r3, #28]
    
    /* Line Coding Initialization */
    LineCoding.DTERate=LWordSwap(9600);
    3db4:	2396      	movs	r3, #150	; 0x96
    3db6:	019b      	lsls	r3, r3, #6
    3db8:	0018      	movs	r0, r3
    3dba:	f000 f8b3 	bl	3f24 <LWordSwap>
    3dbe:	0002      	movs	r2, r0
    3dc0:	4b0b      	ldr	r3, [pc, #44]	; (3df0 <CDC_Init+0x58>)
    3dc2:	601a      	str	r2, [r3, #0]
    LineCoding.CharFormat=0;
    3dc4:	4b0a      	ldr	r3, [pc, #40]	; (3df0 <CDC_Init+0x58>)
    3dc6:	2200      	movs	r2, #0
    3dc8:	711a      	strb	r2, [r3, #4]
    LineCoding.ParityType=0;
    3dca:	4b09      	ldr	r3, [pc, #36]	; (3df0 <CDC_Init+0x58>)
    3dcc:	2200      	movs	r2, #0
    3dce:	715a      	strb	r2, [r3, #5]
    LineCoding.Databits=0x08;
    3dd0:	4b07      	ldr	r3, [pc, #28]	; (3df0 <CDC_Init+0x58>)
    3dd2:	2208      	movs	r2, #8
    3dd4:	719a      	strb	r2, [r3, #6]

    /* Initialize Data Buffers */
    Buffer_Init(CDC_OUT_Data,CDC_BUFFER_SIZE);
    3dd6:	4b07      	ldr	r3, [pc, #28]	; (3df4 <CDC_Init+0x5c>)
    3dd8:	2180      	movs	r1, #128	; 0x80
    3dda:	0018      	movs	r0, r3
    3ddc:	f7ff fa7a 	bl	32d4 <Buffer_Init>
    
}
    3de0:	46c0      	nop			; (mov r8, r8)
    3de2:	46bd      	mov	sp, r7
    3de4:	bd80      	pop	{r7, pc}
    3de6:	46c0      	nop			; (mov r8, r8)
    3de8:	1ffff4c0 	.word	0x1ffff4c0
    3dec:	4004b000 	.word	0x4004b000
    3df0:	1ffff908 	.word	0x1ffff908
    3df4:	1ffff910 	.word	0x1ffff910

00003df8 <CDC_Engine>:


/**********************************************************/
void CDC_Engine(void)
{
    3df8:	b580      	push	{r7, lr}
    3dfa:	af00      	add	r7, sp, #0
    //uint16 u8RecData;
    /* control Stage */
    switch(u8CDCState)
    3dfc:	4b1a      	ldr	r3, [pc, #104]	; (3e68 <CDC_Engine+0x70>)
    3dfe:	781b      	ldrb	r3, [r3, #0]
    3e00:	2b20      	cmp	r3, #32
    3e02:	d00c      	beq.n	3e1e <CDC_Engine+0x26>
    3e04:	2b22      	cmp	r3, #34	; 0x22
    3e06:	d022      	beq.n	3e4e <CDC_Engine+0x56>
    3e08:	2b00      	cmp	r3, #0
    3e0a:	d000      	beq.n	3e0e <CDC_Engine+0x16>
            FLAG_CLR(EP_OUT,gu8USB_Flags);
            EP_IN_Transfer(EP2,CDC_OUTPointer,2);
            u8RecData=0;
        }
*/
}
    3e0c:	e028      	b.n	3e60 <CDC_Engine+0x68>
            if (gu8USB_State!=uENUMERATED)   (void)u8CDCState;
    3e0e:	4b17      	ldr	r3, [pc, #92]	; (3e6c <CDC_Engine+0x74>)
    3e10:	781b      	ldrb	r3, [r3, #0]
    3e12:	2b01      	cmp	r3, #1
    3e14:	d121      	bne.n	3e5a <CDC_Engine+0x62>
            else  u8CDCState=WAITING_FOR_ENUMERATION;
    3e16:	4b14      	ldr	r3, [pc, #80]	; (3e68 <CDC_Engine+0x70>)
    3e18:	2200      	movs	r2, #0
    3e1a:	701a      	strb	r2, [r3, #0]
            break;
    3e1c:	e01d      	b.n	3e5a <CDC_Engine+0x62>
            if(FLAG_CHK(EP0,gu8USB_Flags))
    3e1e:	4b14      	ldr	r3, [pc, #80]	; (3e70 <CDC_Engine+0x78>)
    3e20:	781b      	ldrb	r3, [r3, #0]
    3e22:	001a      	movs	r2, r3
    3e24:	2301      	movs	r3, #1
    3e26:	4013      	ands	r3, r2
    3e28:	d019      	beq.n	3e5e <CDC_Engine+0x66>
                FLAG_CLR(EP0,gu8USB_Flags);
    3e2a:	4b11      	ldr	r3, [pc, #68]	; (3e70 <CDC_Engine+0x78>)
    3e2c:	781b      	ldrb	r3, [r3, #0]
    3e2e:	2201      	movs	r2, #1
    3e30:	4393      	bics	r3, r2
    3e32:	b2da      	uxtb	r2, r3
    3e34:	4b0e      	ldr	r3, [pc, #56]	; (3e70 <CDC_Engine+0x78>)
    3e36:	701a      	strb	r2, [r3, #0]
                (void)EP_OUT_Transfer(EP0,(uint8*)&LineCoding);
    3e38:	4b0e      	ldr	r3, [pc, #56]	; (3e74 <CDC_Engine+0x7c>)
    3e3a:	0019      	movs	r1, r3
    3e3c:	2000      	movs	r0, #0
    3e3e:	f7ff fbe9 	bl	3614 <EP_OUT_Transfer>
                EP_IN_Transfer(EP0,0,0);       
    3e42:	2200      	movs	r2, #0
    3e44:	2100      	movs	r1, #0
    3e46:	2000      	movs	r0, #0
    3e48:	f7ff faf4 	bl	3434 <EP_IN_Transfer>
            break;
    3e4c:	e007      	b.n	3e5e <CDC_Engine+0x66>
            EP_IN_Transfer(EP0,0,0);       
    3e4e:	2200      	movs	r2, #0
    3e50:	2100      	movs	r1, #0
    3e52:	2000      	movs	r0, #0
    3e54:	f7ff faee 	bl	3434 <EP_IN_Transfer>
            break;
    3e58:	e002      	b.n	3e60 <CDC_Engine+0x68>
            break;
    3e5a:	46c0      	nop			; (mov r8, r8)
    3e5c:	e000      	b.n	3e60 <CDC_Engine+0x68>
            break;
    3e5e:	46c0      	nop			; (mov r8, r8)
}
    3e60:	46c0      	nop			; (mov r8, r8)
    3e62:	46bd      	mov	sp, r7
    3e64:	bd80      	pop	{r7, pc}
    3e66:	46c0      	nop			; (mov r8, r8)
    3e68:	1ffff4c0 	.word	0x1ffff4c0
    3e6c:	1ffff7e0 	.word	0x1ffff7e0
    3e70:	1ffff778 	.word	0x1ffff778
    3e74:	1ffff908 	.word	0x1ffff908

00003e78 <CDC_InterfaceReq_Handler>:

/**********************************************************/
uint8 CDC_InterfaceReq_Handler(void)
{
    3e78:	b580      	push	{r7, lr}
    3e7a:	b082      	sub	sp, #8
    3e7c:	af00      	add	r7, sp, #0
    uint8 u8State=uSETUP;
    3e7e:	1dfb      	adds	r3, r7, #7
    3e80:	2200      	movs	r2, #0
    3e82:	701a      	strb	r2, [r3, #0]
    
    switch(Setup_Pkt->bRequest)
    3e84:	4b21      	ldr	r3, [pc, #132]	; (3f0c <CDC_InterfaceReq_Handler+0x94>)
    3e86:	681b      	ldr	r3, [r3, #0]
    3e88:	785b      	ldrb	r3, [r3, #1]
    3e8a:	2b21      	cmp	r3, #33	; 0x21
    3e8c:	d011      	beq.n	3eb2 <CDC_InterfaceReq_Handler+0x3a>
    3e8e:	dc04      	bgt.n	3e9a <CDC_InterfaceReq_Handler+0x22>
    3e90:	2b0a      	cmp	r3, #10
    3e92:	d007      	beq.n	3ea4 <CDC_InterfaceReq_Handler+0x2c>
    3e94:	2b20      	cmp	r3, #32
    3e96:	d013      	beq.n	3ec0 <CDC_InterfaceReq_Handler+0x48>
    3e98:	e031      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>
    3e9a:	2b22      	cmp	r3, #34	; 0x22
    3e9c:	d017      	beq.n	3ece <CDC_InterfaceReq_Handler+0x56>
    3e9e:	2baa      	cmp	r3, #170	; 0xaa
    3ea0:	d01c      	beq.n	3edc <CDC_InterfaceReq_Handler+0x64>
    3ea2:	e02c      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>
    {        
        case GET_INTERFACE:
            EP_IN_Transfer(EP0,&gu8Interface,1);
    3ea4:	4b1a      	ldr	r3, [pc, #104]	; (3f10 <CDC_InterfaceReq_Handler+0x98>)
    3ea6:	2201      	movs	r2, #1
    3ea8:	0019      	movs	r1, r3
    3eaa:	2000      	movs	r0, #0
    3eac:	f7ff fac2 	bl	3434 <EP_IN_Transfer>
            break;
    3eb0:	e025      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>

        case GET_LINE_CODING:
            EP_IN_Transfer(EP0,(uint8*)&LineCoding,7);
    3eb2:	4b18      	ldr	r3, [pc, #96]	; (3f14 <CDC_InterfaceReq_Handler+0x9c>)
    3eb4:	2207      	movs	r2, #7
    3eb6:	0019      	movs	r1, r3
    3eb8:	2000      	movs	r0, #0
    3eba:	f7ff fabb 	bl	3434 <EP_IN_Transfer>
            break;
    3ebe:	e01e      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>

        case SET_LINE_CODING:
            u8CDCState=SET_LINE_CODING;
    3ec0:	4b15      	ldr	r3, [pc, #84]	; (3f18 <CDC_InterfaceReq_Handler+0xa0>)
    3ec2:	2220      	movs	r2, #32
    3ec4:	701a      	strb	r2, [r3, #0]
            u8State=uDATA;
    3ec6:	1dfb      	adds	r3, r7, #7
    3ec8:	2201      	movs	r2, #1
    3eca:	701a      	strb	r2, [r3, #0]
            break;
    3ecc:	e017      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>

        case SET_CONTROL_LINE_STATE:
            u8CDCState=SET_CONTROL_LINE_STATE;
    3ece:	4b12      	ldr	r3, [pc, #72]	; (3f18 <CDC_InterfaceReq_Handler+0xa0>)
    3ed0:	2222      	movs	r2, #34	; 0x22
    3ed2:	701a      	strb	r2, [r3, #0]
            u8State=uSETUP;
    3ed4:	1dfb      	adds	r3, r7, #7
    3ed6:	2200      	movs	r2, #0
    3ed8:	701a      	strb	r2, [r3, #0]
            break;
    3eda:	e010      	b.n	3efe <CDC_InterfaceReq_Handler+0x86>


        case LOADER_MODE:
            Buffer_Init(CDC_OUT_Data,CDC_BUFFER_SIZE);
    3edc:	4b0f      	ldr	r3, [pc, #60]	; (3f1c <CDC_InterfaceReq_Handler+0xa4>)
    3ede:	2180      	movs	r1, #128	; 0x80
    3ee0:	0018      	movs	r0, r3
    3ee2:	f7ff f9f7 	bl	32d4 <Buffer_Init>
            FLAG_SET(LOADER,gu8USB_Flags);
    3ee6:	4b0e      	ldr	r3, [pc, #56]	; (3f20 <CDC_InterfaceReq_Handler+0xa8>)
    3ee8:	781b      	ldrb	r3, [r3, #0]
    3eea:	2280      	movs	r2, #128	; 0x80
    3eec:	4252      	negs	r2, r2
    3eee:	4313      	orrs	r3, r2
    3ef0:	b2da      	uxtb	r2, r3
    3ef2:	4b0b      	ldr	r3, [pc, #44]	; (3f20 <CDC_InterfaceReq_Handler+0xa8>)
    3ef4:	701a      	strb	r2, [r3, #0]
            CDC_OUT_Data[0]=0xFF;
    3ef6:	4b09      	ldr	r3, [pc, #36]	; (3f1c <CDC_InterfaceReq_Handler+0xa4>)
    3ef8:	22ff      	movs	r2, #255	; 0xff
    3efa:	701a      	strb	r2, [r3, #0]
            break;
    3efc:	46c0      	nop			; (mov r8, r8)


    }
    return(u8State);
    3efe:	1dfb      	adds	r3, r7, #7
    3f00:	781b      	ldrb	r3, [r3, #0]
}
    3f02:	0018      	movs	r0, r3
    3f04:	46bd      	mov	sp, r7
    3f06:	b002      	add	sp, #8
    3f08:	bd80      	pop	{r7, pc}
    3f0a:	46c0      	nop			; (mov r8, r8)
    3f0c:	1ffff6a8 	.word	0x1ffff6a8
    3f10:	1ffff779 	.word	0x1ffff779
    3f14:	1ffff908 	.word	0x1ffff908
    3f18:	1ffff4c0 	.word	0x1ffff4c0
    3f1c:	1ffff910 	.word	0x1ffff910
    3f20:	1ffff778 	.word	0x1ffff778

00003f24 <LWordSwap>:


/**********************************************************/
uint32 LWordSwap(uint32 u32DataSwap)
{
    3f24:	b580      	push	{r7, lr}
    3f26:	b084      	sub	sp, #16
    3f28:	af00      	add	r7, sp, #0
    3f2a:	6078      	str	r0, [r7, #4]
    uint32 u32Temp;
    u32Temp= (u32DataSwap & 0xFF000000) >> 24;
    3f2c:	687b      	ldr	r3, [r7, #4]
    3f2e:	0e1b      	lsrs	r3, r3, #24
    3f30:	60fb      	str	r3, [r7, #12]
    u32Temp+=(u32DataSwap & 0xFF0000)   >> 8;
    3f32:	687b      	ldr	r3, [r7, #4]
    3f34:	0a1a      	lsrs	r2, r3, #8
    3f36:	23ff      	movs	r3, #255	; 0xff
    3f38:	021b      	lsls	r3, r3, #8
    3f3a:	4013      	ands	r3, r2
    3f3c:	68fa      	ldr	r2, [r7, #12]
    3f3e:	18d3      	adds	r3, r2, r3
    3f40:	60fb      	str	r3, [r7, #12]
    u32Temp+=(u32DataSwap & 0xFF00)     << 8;
    3f42:	687b      	ldr	r3, [r7, #4]
    3f44:	021a      	lsls	r2, r3, #8
    3f46:	23ff      	movs	r3, #255	; 0xff
    3f48:	041b      	lsls	r3, r3, #16
    3f4a:	4013      	ands	r3, r2
    3f4c:	68fa      	ldr	r2, [r7, #12]
    3f4e:	18d3      	adds	r3, r2, r3
    3f50:	60fb      	str	r3, [r7, #12]
    u32Temp+=(u32DataSwap & 0xFF)       << 24;
    3f52:	687b      	ldr	r3, [r7, #4]
    3f54:	061b      	lsls	r3, r3, #24
    3f56:	68fa      	ldr	r2, [r7, #12]
    3f58:	18d3      	adds	r3, r2, r3
    3f5a:	60fb      	str	r3, [r7, #12]
    return(u32Temp);    
    3f5c:	68fb      	ldr	r3, [r7, #12]
}
    3f5e:	0018      	movs	r0, r3
    3f60:	46bd      	mov	sp, r7
    3f62:	b004      	add	sp, #16
    3f64:	bd80      	pop	{r7, pc}
    3f66:	0000      	movs	r0, r0
    3f68:	5252450a 	.word	0x5252450a
    3f6c:	6e492021 	.word	0x6e492021
    3f70:	696c6176 	.word	0x696c6176
    3f74:	52492064 	.word	0x52492064
    3f78:	61762051 	.word	0x61762051
    3f7c:	2065756c 	.word	0x2065756c
    3f80:	73736170 	.word	0x73736170
    3f84:	74206465 	.word	0x74206465
    3f88:	6e65206f 	.word	0x6e65206f
    3f8c:	656c6261 	.word	0x656c6261
    3f90:	71726920 	.word	0x71726920
    3f94:	6e756620 	.word	0x6e756620
    3f98:	6f697463 	.word	0x6f697463
    3f9c:	000a216e 	.word	0x000a216e
    3fa0:	5252450a 	.word	0x5252450a
    3fa4:	6e492021 	.word	0x6e492021
    3fa8:	696c6176 	.word	0x696c6176
    3fac:	52492064 	.word	0x52492064
    3fb0:	61762051 	.word	0x61762051
    3fb4:	2065756c 	.word	0x2065756c
    3fb8:	73736170 	.word	0x73736170
    3fbc:	74206465 	.word	0x74206465
    3fc0:	6964206f 	.word	0x6964206f
    3fc4:	6c626173 	.word	0x6c626173
    3fc8:	72692065 	.word	0x72692065
    3fcc:	75662071 	.word	0x75662071
    3fd0:	6974636e 	.word	0x6974636e
    3fd4:	0a216e6f 	.word	0x0a216e6f
    3fd8:	00000000 	.word	0x00000000
    3fdc:	5252450a 	.word	0x5252450a
    3fe0:	6e492021 	.word	0x6e492021
    3fe4:	696c6176 	.word	0x696c6176
    3fe8:	52492064 	.word	0x52492064
    3fec:	61762051 	.word	0x61762051
    3ff0:	2065756c 	.word	0x2065756c
    3ff4:	73736170 	.word	0x73736170
    3ff8:	74206465 	.word	0x74206465
    3ffc:	7270206f 	.word	0x7270206f
    4000:	69726f69 	.word	0x69726f69
    4004:	69207974 	.word	0x69207974
    4008:	66207172 	.word	0x66207172
    400c:	74636e75 	.word	0x74636e75
    4010:	216e6f69 	.word	0x216e6f69
    4014:	0000000a 	.word	0x0000000a
    4018:	5252450a 	.word	0x5252450a
    401c:	6e492021 	.word	0x6e492021
    4020:	696c6176 	.word	0x696c6176
    4024:	72702064 	.word	0x72702064
    4028:	69726f69 	.word	0x69726f69
    402c:	76207974 	.word	0x76207974
    4030:	65756c61 	.word	0x65756c61
    4034:	73617020 	.word	0x73617020
    4038:	20646573 	.word	0x20646573
    403c:	70206f74 	.word	0x70206f74
    4040:	726f6972 	.word	0x726f6972
    4044:	20797469 	.word	0x20797469
    4048:	20717269 	.word	0x20717269
    404c:	636e7566 	.word	0x636e7566
    4050:	6e6f6974 	.word	0x6e6f6974
    4054:	00000a21 	.word	0x00000a21
    4058:	0d0a0d0a 	.word	0x0d0a0d0a
    405c:	00000000 	.word	0x00000000
    4060:	4c4b0d0a 	.word	0x4c4b0d0a
    4064:	00000030 	.word	0x00000030
    4068:	4c4b0d0a 	.word	0x4c4b0d0a
    406c:	00000031 	.word	0x00000031
    4070:	4c4b0d0a 	.word	0x4c4b0d0a
    4074:	00000032 	.word	0x00000032
    4078:	4c4b0d0a 	.word	0x4c4b0d0a
    407c:	00000033 	.word	0x00000033
    4080:	4c4b0d0a 	.word	0x4c4b0d0a
    4084:	00000034 	.word	0x00000034
    4088:	6e550d0a 	.word	0x6e550d0a
    408c:	6f636572 	.word	0x6f636572
    4090:	7a696e67 	.word	0x7a696e67
    4094:	4b206465 	.word	0x4b206465
    4098:	74656e69 	.word	0x74656e69
    409c:	66207369 	.word	0x66207369
    40a0:	6c696d61 	.word	0x6c696d61
    40a4:	65642079 	.word	0x65642079
    40a8:	65636976 	.word	0x65636976
    40ac:	000d0a2e 	.word	0x000d0a2e
    40b0:	00000034 	.word	0x00000034
    40b4:	00000035 	.word	0x00000035
    40b8:	6e550d0a 	.word	0x6e550d0a
    40bc:	6f636572 	.word	0x6f636572
    40c0:	7a696e67 	.word	0x7a696e67
    40c4:	4b206465 	.word	0x4b206465
    40c8:	74656e69 	.word	0x74656e69
    40cc:	73207369 	.word	0x73207369
    40d0:	662d6275 	.word	0x662d6275
    40d4:	6c696d61 	.word	0x6c696d61
    40d8:	65642079 	.word	0x65642079
    40dc:	65636976 	.word	0x65636976
    40e0:	000d0a2e 	.word	0x000d0a2e
    40e4:	69703631 	.word	0x69703631
    40e8:	2020206e 	.word	0x2020206e
    40ec:	20202020 	.word	0x20202020
    40f0:	00000000 	.word	0x00000000
    40f4:	69703432 	.word	0x69703432
    40f8:	2020206e 	.word	0x2020206e
    40fc:	20202020 	.word	0x20202020
    4100:	00000000 	.word	0x00000000
    4104:	69703233 	.word	0x69703233
    4108:	2020206e 	.word	0x2020206e
    410c:	00202020 	.word	0x00202020
    4110:	69703834 	.word	0x69703834
    4114:	2020206e 	.word	0x2020206e
    4118:	00202020 	.word	0x00202020
    411c:	69703436 	.word	0x69703436
    4120:	2020206e 	.word	0x2020206e
    4124:	00202020 	.word	0x00202020
    4128:	69703038 	.word	0x69703038
    412c:	2020206e 	.word	0x2020206e
    4130:	00202020 	.word	0x00202020
    4134:	70303031 	.word	0x70303031
    4138:	20206e69 	.word	0x20206e69
    413c:	20202020 	.word	0x20202020
    4140:	00000000 	.word	0x00000000
    4144:	6e550d0a 	.word	0x6e550d0a
    4148:	6f636572 	.word	0x6f636572
    414c:	7a696e67 	.word	0x7a696e67
    4150:	4b206465 	.word	0x4b206465
    4154:	74656e69 	.word	0x74656e69
    4158:	70207369 	.word	0x70207369
    415c:	616b6361 	.word	0x616b6361
    4160:	63206567 	.word	0x63206567
    4164:	2e65646f 	.word	0x2e65646f
    4168:	20202020 	.word	0x20202020
    416c:	00002020 	.word	0x00002020
    4170:	6f4c0d0a 	.word	0x6f4c0d0a
    4174:	6f502077 	.word	0x6f502077
    4178:	20726577 	.word	0x20726577
    417c:	656e694c 	.word	0x656e694c
    4180:	74697720 	.word	0x74697720
    4184:	6f432068 	.word	0x6f432068
    4188:	78657472 	.word	0x78657472
    418c:	2b304d20 	.word	0x2b304d20
    4190:	0d0a0d0a 	.word	0x0d0a0d0a
    4194:	00000000 	.word	0x00000000
    4198:	6e550d0a 	.word	0x6e550d0a
    419c:	6f636572 	.word	0x6f636572
    41a0:	7a696e67 	.word	0x7a696e67
    41a4:	4b206465 	.word	0x4b206465
    41a8:	74656e69 	.word	0x74656e69
    41ac:	66207369 	.word	0x66207369
    41b0:	6c696d61 	.word	0x6c696d61
    41b4:	74612079 	.word	0x74612079
    41b8:	62697274 	.word	0x62697274
    41bc:	2e657475 	.word	0x2e657475
    41c0:	00000d0a 	.word	0x00000d0a
    41c4:	4d415253 	.word	0x4d415253
    41c8:	7a695320 	.word	0x7a695320
    41cc:	30203a65 	.word	0x30203a65
    41d0:	4b20352e 	.word	0x4b20352e
    41d4:	000d0a42 	.word	0x000d0a42
    41d8:	4d415253 	.word	0x4d415253
    41dc:	7a695320 	.word	0x7a695320
    41e0:	20203a65 	.word	0x20203a65
    41e4:	424b2031 	.word	0x424b2031
    41e8:	00000d0a 	.word	0x00000d0a
    41ec:	4d415253 	.word	0x4d415253
    41f0:	7a695320 	.word	0x7a695320
    41f4:	20203a65 	.word	0x20203a65
    41f8:	424b2032 	.word	0x424b2032
    41fc:	00000d0a 	.word	0x00000d0a
    4200:	4d415253 	.word	0x4d415253
    4204:	7a695320 	.word	0x7a695320
    4208:	20203a65 	.word	0x20203a65
    420c:	424b2034 	.word	0x424b2034
    4210:	00000d0a 	.word	0x00000d0a
    4214:	4d415253 	.word	0x4d415253
    4218:	7a695320 	.word	0x7a695320
    421c:	20203a65 	.word	0x20203a65
    4220:	424b2038 	.word	0x424b2038
    4224:	00000d0a 	.word	0x00000d0a
    4228:	4d415253 	.word	0x4d415253
    422c:	7a695320 	.word	0x7a695320
    4230:	20203a65 	.word	0x20203a65
    4234:	4b203631 	.word	0x4b203631
    4238:	000d0a42 	.word	0x000d0a42
    423c:	4d415253 	.word	0x4d415253
    4240:	7a695320 	.word	0x7a695320
    4244:	20203a65 	.word	0x20203a65
    4248:	4b203233 	.word	0x4b203233
    424c:	000d0a42 	.word	0x000d0a42
    4250:	4d415253 	.word	0x4d415253
    4254:	7a695320 	.word	0x7a695320
    4258:	20203a65 	.word	0x20203a65
    425c:	4b203436 	.word	0x4b203436
    4260:	000d0a42 	.word	0x000d0a42
    4264:	6e550d0a 	.word	0x6e550d0a
    4268:	6f636572 	.word	0x6f636572
    426c:	7a696e67 	.word	0x7a696e67
    4270:	53206465 	.word	0x53206465
    4274:	204d4152 	.word	0x204d4152
    4278:	657a6953 	.word	0x657a6953
    427c:	000d0a2e 	.word	0x000d0a2e
    4280:	696c6953 	.word	0x696c6953
    4284:	206e6f63 	.word	0x206e6f63
    4288:	20766572 	.word	0x20766572
    428c:	0d0a6425 	.word	0x0d0a6425
    4290:	00000020 	.word	0x00000020
    4294:	73616c46 	.word	0x73616c46
    4298:	69732068 	.word	0x69732068
    429c:	203a657a 	.word	0x203a657a
    42a0:	4b203820 	.word	0x4b203820
    42a4:	72702042 	.word	0x72702042
    42a8:	6172676f 	.word	0x6172676f
    42ac:	6c66206d 	.word	0x6c66206d
    42b0:	2c687361 	.word	0x2c687361
    42b4:	322e3020 	.word	0x322e3020
    42b8:	424b2035 	.word	0x424b2035
    42bc:	6f727020 	.word	0x6f727020
    42c0:	74636574 	.word	0x74636574
    42c4:	206e6f69 	.word	0x206e6f69
    42c8:	69676572 	.word	0x69676572
    42cc:	00006e6f 	.word	0x00006e6f
    42d0:	73616c46 	.word	0x73616c46
    42d4:	69732068 	.word	0x69732068
    42d8:	203a657a 	.word	0x203a657a
    42dc:	20363120 	.word	0x20363120
    42e0:	7020424b 	.word	0x7020424b
    42e4:	72676f72 	.word	0x72676f72
    42e8:	66206d61 	.word	0x66206d61
    42ec:	6873616c 	.word	0x6873616c
    42f0:	2e30202c 	.word	0x2e30202c
    42f4:	424b2035 	.word	0x424b2035
    42f8:	6f727020 	.word	0x6f727020
    42fc:	74636574 	.word	0x74636574
    4300:	206e6f69 	.word	0x206e6f69
    4304:	69676572 	.word	0x69676572
    4308:	00096e6f 	.word	0x00096e6f
    430c:	73616c46 	.word	0x73616c46
    4310:	69732068 	.word	0x69732068
    4314:	203a657a 	.word	0x203a657a
    4318:	20323320 	.word	0x20323320
    431c:	7020424b 	.word	0x7020424b
    4320:	72676f72 	.word	0x72676f72
    4324:	66206d61 	.word	0x66206d61
    4328:	6873616c 	.word	0x6873616c
    432c:	2031202c 	.word	0x2031202c
    4330:	7020424b 	.word	0x7020424b
    4334:	65746f72 	.word	0x65746f72
    4338:	6f697463 	.word	0x6f697463
    433c:	6572206e 	.word	0x6572206e
    4340:	6e6f6967 	.word	0x6e6f6967
    4344:	00000009 	.word	0x00000009
    4348:	73616c46 	.word	0x73616c46
    434c:	69732068 	.word	0x69732068
    4350:	203a657a 	.word	0x203a657a
    4354:	20343620 	.word	0x20343620
    4358:	7020424b 	.word	0x7020424b
    435c:	72676f72 	.word	0x72676f72
    4360:	66206d61 	.word	0x66206d61
    4364:	6873616c 	.word	0x6873616c
    4368:	2032202c 	.word	0x2032202c
    436c:	7020424b 	.word	0x7020424b
    4370:	65746f72 	.word	0x65746f72
    4374:	6f697463 	.word	0x6f697463
    4378:	6572206e 	.word	0x6572206e
    437c:	6e6f6967 	.word	0x6e6f6967
    4380:	00000009 	.word	0x00000009
    4384:	73616c46 	.word	0x73616c46
    4388:	69732068 	.word	0x69732068
    438c:	203a657a 	.word	0x203a657a
    4390:	38323120 	.word	0x38323120
    4394:	20424b20 	.word	0x20424b20
    4398:	676f7270 	.word	0x676f7270
    439c:	206d6172 	.word	0x206d6172
    43a0:	73616c66 	.word	0x73616c66
    43a4:	34202c68 	.word	0x34202c68
    43a8:	20424b20 	.word	0x20424b20
    43ac:	746f7270 	.word	0x746f7270
    43b0:	69746365 	.word	0x69746365
    43b4:	72206e6f 	.word	0x72206e6f
    43b8:	6f696765 	.word	0x6f696765
    43bc:	0000096e 	.word	0x0000096e
    43c0:	73616c46 	.word	0x73616c46
    43c4:	69732068 	.word	0x69732068
    43c8:	203a657a 	.word	0x203a657a
    43cc:	36353220 	.word	0x36353220
    43d0:	20424b20 	.word	0x20424b20
    43d4:	676f7270 	.word	0x676f7270
    43d8:	206d6172 	.word	0x206d6172
    43dc:	73616c66 	.word	0x73616c66
    43e0:	34202c68 	.word	0x34202c68
    43e4:	20424b20 	.word	0x20424b20
    43e8:	746f7270 	.word	0x746f7270
    43ec:	69746365 	.word	0x69746365
    43f0:	72206e6f 	.word	0x72206e6f
    43f4:	6f696765 	.word	0x6f696765
    43f8:	0000096e 	.word	0x0000096e
    43fc:	21525245 	.word	0x21525245
    4400:	6e552021 	.word	0x6e552021
    4404:	69666564 	.word	0x69666564
    4408:	2064656e 	.word	0x2064656e
    440c:	73616c66 	.word	0x73616c66
    4410:	69732068 	.word	0x69732068
    4414:	0d0a657a 	.word	0x0d0a657a
    4418:	00000000 	.word	0x00000000
    441c:	73616c46 	.word	0x73616c46
    4420:	61702068 	.word	0x61702068
    4424:	656d6172 	.word	0x656d6172
    4428:	20726574 	.word	0x20726574
    442c:	73726576 	.word	0x73726576
    4430:	206e6f69 	.word	0x206e6f69
    4434:	00206425 	.word	0x00206425
    4438:	20642520 	.word	0x20642520
    443c:	00000000 	.word	0x00000000
    4440:	0a642520 	.word	0x0a642520
    4444:	0000000d 	.word	0x0000000d
    4448:	73616c46 	.word	0x73616c46
    444c:	65762068 	.word	0x65762068
    4450:	6f697372 	.word	0x6f697372
    4454:	4449206e 	.word	0x4449206e
    4458:	20642520 	.word	0x20642520
    445c:	00000000 	.word	0x00000000
    4460:	00642520 	.word	0x00642520
    4464:	0d0a6425 	.word	0x0d0a6425
    4468:	00000000 	.word	0x00000000
    446c:	2a2a2a0a 	.word	0x2a2a2a0a
    4470:	6665642a 	.word	0x6665642a
    4474:	746c7561 	.word	0x746c7561
    4478:	7273695f 	.word	0x7273695f
    447c:	746e6520 	.word	0x746e6520
    4480:	64657265 	.word	0x64657265
    4484:	206e6f20 	.word	0x206e6f20
    4488:	74636576 	.word	0x74636576
    448c:	2520726f 	.word	0x2520726f
    4490:	2a2a2a64 	.word	0x2a2a2a64
    4494:	0a0d2a2a 	.word	0x0a0d2a2a
    4498:	0000000a 	.word	0x0000000a
    449c:	2a2a2a0a 	.word	0x2a2a2a0a
    44a0:	6f62412a 	.word	0x6f62412a
    44a4:	62207472 	.word	0x62207472
    44a8:	6f747475 	.word	0x6f747475
    44ac:	6e69206e 	.word	0x6e69206e
    44b0:	72726574 	.word	0x72726574
    44b4:	2a747075 	.word	0x2a747075
    44b8:	0a2a2a2a 	.word	0x0a2a2a2a
    44bc:	0000000a 	.word	0x0000000a
    44c0:	7261485b 	.word	0x7261485b
    44c4:	61662064 	.word	0x61662064
    44c8:	20746c75 	.word	0x20746c75
    44cc:	646e6168 	.word	0x646e6168
    44d0:	5d72656c 	.word	0x5d72656c
    44d4:	0000000a 	.word	0x0000000a
    44d8:	3d203052 	.word	0x3d203052
    44dc:	0a782520 	.word	0x0a782520
    44e0:	00000000 	.word	0x00000000
    44e4:	3d203152 	.word	0x3d203152
    44e8:	0a782520 	.word	0x0a782520
    44ec:	00000000 	.word	0x00000000
    44f0:	3d203252 	.word	0x3d203252
    44f4:	0a782520 	.word	0x0a782520
    44f8:	00000000 	.word	0x00000000
    44fc:	3d203352 	.word	0x3d203352
    4500:	0a782520 	.word	0x0a782520
    4504:	00000000 	.word	0x00000000
    4508:	20323152 	.word	0x20323152
    450c:	7825203d 	.word	0x7825203d
    4510:	0000000a 	.word	0x0000000a
    4514:	3d20524c 	.word	0x3d20524c
    4518:	0a782520 	.word	0x0a782520
    451c:	00000000 	.word	0x00000000
    4520:	3d204350 	.word	0x3d204350
    4524:	0a782520 	.word	0x0a782520
    4528:	00000000 	.word	0x00000000
    452c:	20525350 	.word	0x20525350
    4530:	7825203d 	.word	0x7825203d
    4534:	0000000a 	.word	0x0000000a
    4538:	52414642 	.word	0x52414642
    453c:	25203d20 	.word	0x25203d20
    4540:	00000a78 	.word	0x00000a78
    4544:	52534643 	.word	0x52534643
    4548:	25203d20 	.word	0x25203d20
    454c:	00000a78 	.word	0x00000a78
    4550:	52534648 	.word	0x52534648
    4554:	25203d20 	.word	0x25203d20
    4558:	00000a78 	.word	0x00000a78
    455c:	52534644 	.word	0x52534644
    4560:	25203d20 	.word	0x25203d20
    4564:	00000a78 	.word	0x00000a78
    4568:	52534641 	.word	0x52534641
    456c:	25203d20 	.word	0x25203d20
    4570:	00000a78 	.word	0x00000a78
    4574:	43545253 	.word	0x43545253
    4578:	5253495f 	.word	0x5253495f
    457c:	746e6520 	.word	0x746e6520
    4580:	64657265 	.word	0x64657265
    4584:	00000a0d 	.word	0x00000a0d
    4588:	43545253 	.word	0x43545253
    458c:	6d697420 	.word	0x6d697420
    4590:	6e692065 	.word	0x6e692065
    4594:	696c6176 	.word	0x696c6176
    4598:	6e692064 	.word	0x6e692064
    459c:	72726574 	.word	0x72726574
    45a0:	20747075 	.word	0x20747075
    45a4:	65746e65 	.word	0x65746e65
    45a8:	2e646572 	.word	0x2e646572
    45ac:	0a0d2e2e 	.word	0x0a0d2e2e
    45b0:	00000000 	.word	0x00000000
    45b4:	43545253 	.word	0x43545253
    45b8:	6d697420 	.word	0x6d697420
    45bc:	766f2065 	.word	0x766f2065
    45c0:	6c667265 	.word	0x6c667265
    45c4:	6920776f 	.word	0x6920776f
    45c8:	7265746e 	.word	0x7265746e
    45cc:	74707572 	.word	0x74707572
    45d0:	746e6520 	.word	0x746e6520
    45d4:	64657265 	.word	0x64657265
    45d8:	0d2e2e2e 	.word	0x0d2e2e2e
    45dc:	0000000a 	.word	0x0000000a
    45e0:	43545253 	.word	0x43545253
    45e4:	616c6120 	.word	0x616c6120
    45e8:	69206d72 	.word	0x69206d72
    45ec:	7265746e 	.word	0x7265746e
    45f0:	74707572 	.word	0x74707572
    45f4:	746e6520 	.word	0x746e6520
    45f8:	64657265 	.word	0x64657265
    45fc:	0d2e2e2e 	.word	0x0d2e2e2e
    4600:	0000000a 	.word	0x0000000a
    4604:	76206f4e 	.word	0x76206f4e
    4608:	64696c61 	.word	0x64696c61
    460c:	616c4620 	.word	0x616c4620
    4610:	61772067 	.word	0x61772067
    4614:	65732073 	.word	0x65732073
    4618:	000a2174 	.word	0x000a2174
    461c:	74530d0a 	.word	0x74530d0a
    4620:	4d20706f 	.word	0x4d20706f
    4624:	2065646f 	.word	0x2065646f
    4628:	6e6b6341 	.word	0x6e6b6341
    462c:	656c776f 	.word	0x656c776f
    4630:	20656764 	.word	0x20656764
    4634:	6f727245 	.word	0x6f727245
    4638:	65522072 	.word	0x65522072
    463c:	00746573 	.word	0x00746573
    4640:	444d0d0a 	.word	0x444d0d0a
    4644:	50412d4d 	.word	0x50412d4d
    4648:	73655220 	.word	0x73655220
    464c:	00007465 	.word	0x00007465
    4650:	6f530d0a 	.word	0x6f530d0a
    4654:	61777466 	.word	0x61777466
    4658:	52206572 	.word	0x52206572
    465c:	74657365 	.word	0x74657365
    4660:	00000000 	.word	0x00000000
    4664:	6f430d0a 	.word	0x6f430d0a
    4668:	4c206572 	.word	0x4c206572
    466c:	756b636f 	.word	0x756b636f
    4670:	76452070 	.word	0x76452070
    4674:	20746e65 	.word	0x20746e65
    4678:	65736552 	.word	0x65736552
    467c:	00000074 	.word	0x00000074
    4680:	6f500d0a 	.word	0x6f500d0a
    4684:	2d726577 	.word	0x2d726577
    4688:	52206e6f 	.word	0x52206e6f
    468c:	74657365 	.word	0x74657365
    4690:	00000000 	.word	0x00000000
    4694:	78450d0a 	.word	0x78450d0a
    4698:	6e726574 	.word	0x6e726574
    469c:	50206c61 	.word	0x50206c61
    46a0:	52206e69 	.word	0x52206e69
    46a4:	74657365 	.word	0x74657365
    46a8:	00000000 	.word	0x00000000
    46ac:	61570d0a 	.word	0x61570d0a
    46b0:	64686374 	.word	0x64686374
    46b4:	4328676f 	.word	0x4328676f
    46b8:	2029504f 	.word	0x2029504f
    46bc:	65736552 	.word	0x65736552
    46c0:	00000074 	.word	0x00000074
    46c4:	6f4c0d0a 	.word	0x6f4c0d0a
    46c8:	6f207373 	.word	0x6f207373
    46cc:	78452066 	.word	0x78452066
    46d0:	6e726574 	.word	0x6e726574
    46d4:	43206c61 	.word	0x43206c61
    46d8:	6b636f6c 	.word	0x6b636f6c
    46dc:	73655220 	.word	0x73655220
    46e0:	00007465 	.word	0x00007465
    46e4:	6f4c0d0a 	.word	0x6f4c0d0a
    46e8:	6f207373 	.word	0x6f207373
    46ec:	6f4c2066 	.word	0x6f4c2066
    46f0:	69206b63 	.word	0x69206b63
    46f4:	4c50206e 	.word	0x4c50206e
    46f8:	6552204c 	.word	0x6552204c
    46fc:	00746573 	.word	0x00746573
    4700:	6f4c0d0a 	.word	0x6f4c0d0a
    4704:	6f762d77 	.word	0x6f762d77
    4708:	6761746c 	.word	0x6761746c
    470c:	65442065 	.word	0x65442065
    4710:	74636574 	.word	0x74636574
    4714:	73655220 	.word	0x73655220
    4718:	00007465 	.word	0x00007465
    471c:	6f5b0d0a 	.word	0x6f5b0d0a
    4720:	52537475 	.word	0x52537475
    4724:	61575d53 	.word	0x61575d53
    4728:	7075656b 	.word	0x7075656b
    472c:	74696220 	.word	0x74696220
    4730:	74657320 	.word	0x74657320
    4734:	6f726620 	.word	0x6f726620
    4738:	6f6c206d 	.word	0x6f6c206d
    473c:	6f702077 	.word	0x6f702077
    4740:	20726577 	.word	0x20726577
    4744:	65646f6d 	.word	0x65646f6d
    4748:	00000020 	.word	0x00000020
    474c:	20534c4c 	.word	0x20534c4c
    4750:	74697865 	.word	0x74697865
    4754:	00000020 	.word	0x00000020
    4758:	534c4c56 	.word	0x534c4c56
    475c:	78652030 	.word	0x78652030
    4760:	00207469 	.word	0x00207469
    4764:	534c4c56 	.word	0x534c4c56
    4768:	78652031 	.word	0x78652031
    476c:	00207469 	.word	0x00207469
    4770:	534c4c56 	.word	0x534c4c56
    4774:	78652032 	.word	0x78652032
    4778:	00007469 	.word	0x00007469
    477c:	534c4c56 	.word	0x534c4c56
    4780:	78652033 	.word	0x78652033
    4784:	00207469 	.word	0x00207469
    4788:	74756f5b 	.word	0x74756f5b
    478c:	5d535253 	.word	0x5d535253
    4790:	5f4d4352 	.word	0x5f4d4352
    4794:	30535253 	.word	0x30535253
    4798:	20736920 	.word	0x20736920
    479c:	4f52455a 	.word	0x4f52455a
    47a0:	3d202020 	.word	0x3d202020
    47a4:	30232520 	.word	0x30232520
    47a8:	0d205832 	.word	0x0d205832
    47ac:	00000d0a 	.word	0x00000d0a
    47b0:	74756f5b 	.word	0x74756f5b
    47b4:	5d535253 	.word	0x5d535253
    47b8:	5f4d4352 	.word	0x5f4d4352
    47bc:	31535253 	.word	0x31535253
    47c0:	20736920 	.word	0x20736920
    47c4:	4f52455a 	.word	0x4f52455a
    47c8:	3d202020 	.word	0x3d202020
    47cc:	30232520 	.word	0x30232520
    47d0:	0d205832 	.word	0x0d205832
    47d4:	00000d0a 	.word	0x00000d0a
    47d8:	2a2a2a0a 	.word	0x2a2a2a0a
    47dc:	2a2a2a2a 	.word	0x2a2a2a2a
    47e0:	202a2a2a 	.word	0x202a2a2a
    47e4:	20425355 	.word	0x20425355
    47e8:	52564358 	.word	0x52564358
    47ec:	646f4d20 	.word	0x646f4d20
    47f0:	20656c75 	.word	0x20656c75
    47f4:	74736554 	.word	0x74736554
    47f8:	20676e69 	.word	0x20676e69
    47fc:	2a2a2a2a 	.word	0x2a2a2a2a
    4800:	2a2a2a2a 	.word	0x2a2a2a2a
    4804:	000a2a2a 	.word	0x000a2a2a
    4808:	6973740d 	.word	0x6973740d
    480c:	3d252520 	.word	0x3d252520
    4810:	33302520 	.word	0x33302520
    4814:	00002069 	.word	0x00002069
    4818:	000009ac 	.word	0x000009ac
    481c:	000009ca 	.word	0x000009ca
    4820:	000009ca 	.word	0x000009ca
    4824:	000009c0 	.word	0x000009c0
    4828:	000009ca 	.word	0x000009ca
    482c:	000009ca 	.word	0x000009ca
    4830:	000009ca 	.word	0x000009ca
    4834:	000009ca 	.word	0x000009ca
    4838:	000009ca 	.word	0x000009ca
    483c:	000009ca 	.word	0x000009ca
    4840:	000009ca 	.word	0x000009ca
    4844:	000009a2 	.word	0x000009a2
    4848:	000009ca 	.word	0x000009ca
    484c:	00000998 	.word	0x00000998
    4850:	000009ca 	.word	0x000009ca
    4854:	000009ca 	.word	0x000009ca
    4858:	000009b6 	.word	0x000009b6
    485c:	00000b96 	.word	0x00000b96
    4860:	00000e22 	.word	0x00000e22
    4864:	00000e22 	.word	0x00000e22
    4868:	00000e22 	.word	0x00000e22
    486c:	00000e22 	.word	0x00000e22
    4870:	00000e22 	.word	0x00000e22
    4874:	00000e22 	.word	0x00000e22
    4878:	00000e22 	.word	0x00000e22
    487c:	00000e22 	.word	0x00000e22
    4880:	00000e22 	.word	0x00000e22
    4884:	00000ca8 	.word	0x00000ca8
    4888:	00000d8a 	.word	0x00000d8a
    488c:	00000aaa 	.word	0x00000aaa
    4890:	00000e22 	.word	0x00000e22
    4894:	00000e22 	.word	0x00000e22
    4898:	00000e22 	.word	0x00000e22
    489c:	00000e22 	.word	0x00000e22
    48a0:	00000aaa 	.word	0x00000aaa
    48a4:	00000e22 	.word	0x00000e22
    48a8:	00000e22 	.word	0x00000e22
    48ac:	00000e22 	.word	0x00000e22
    48b0:	00000e22 	.word	0x00000e22
    48b4:	00000e10 	.word	0x00000e10
    48b8:	00000c88 	.word	0x00000c88
    48bc:	00000cc8 	.word	0x00000cc8
    48c0:	00000e22 	.word	0x00000e22
    48c4:	00000e22 	.word	0x00000e22
    48c8:	00000da6 	.word	0x00000da6
    48cc:	00000e22 	.word	0x00000e22
    48d0:	00000cf0 	.word	0x00000cf0
    48d4:	00000e22 	.word	0x00000e22
    48d8:	00000e22 	.word	0x00000e22
    48dc:	00000b96 	.word	0x00000b96
    48e0:	000010b8 	.word	0x000010b8
    48e4:	000010c2 	.word	0x000010c2
    48e8:	000010cc 	.word	0x000010cc
    48ec:	000010d6 	.word	0x000010d6
    48f0:	000010e0 	.word	0x000010e0
    48f4:	00001140 	.word	0x00001140
    48f8:	0000114a 	.word	0x0000114a
    48fc:	00001154 	.word	0x00001154
    4900:	00001182 	.word	0x00001182
    4904:	0000115e 	.word	0x0000115e
    4908:	00001168 	.word	0x00001168
    490c:	00001170 	.word	0x00001170
    4910:	00001182 	.word	0x00001182
    4914:	00001178 	.word	0x00001178
    4918:	000011ca 	.word	0x000011ca
    491c:	000011d4 	.word	0x000011d4
    4920:	000011de 	.word	0x000011de
    4924:	000011e8 	.word	0x000011e8
    4928:	000011f2 	.word	0x000011f2
    492c:	000011fc 	.word	0x000011fc
    4930:	00001206 	.word	0x00001206
    4934:	00001210 	.word	0x00001210
    4938:	00001256 	.word	0x00001256
    493c:	00001260 	.word	0x00001260
    4940:	0000129c 	.word	0x0000129c
    4944:	0000126a 	.word	0x0000126a
    4948:	0000129c 	.word	0x0000129c
    494c:	00001274 	.word	0x00001274
    4950:	0000129c 	.word	0x0000129c
    4954:	0000127e 	.word	0x0000127e
    4958:	0000129c 	.word	0x0000129c
    495c:	00001288 	.word	0x00001288
    4960:	0000129c 	.word	0x0000129c
    4964:	0000129c 	.word	0x0000129c
    4968:	0000129c 	.word	0x0000129c
    496c:	0000129c 	.word	0x0000129c
    4970:	0000129c 	.word	0x0000129c
    4974:	00001292 	.word	0x00001292
    4978:	00002504 	.word	0x00002504
    497c:	00002466 	.word	0x00002466
    4980:	0000247c 	.word	0x0000247c
    4984:	00002492 	.word	0x00002492
    4988:	000024a8 	.word	0x000024a8
    498c:	000024c0 	.word	0x000024c0
    4990:	000024d8 	.word	0x000024d8
    4994:	000024f0 	.word	0x000024f0

00004998 <asin>:
    4998:	00000000 00000007 0000000e 00000015     ................
    49a8:	0000001c 00000023 0000002b 00000032     ....#...+...2...
    49b8:	00000039 00000040 00000047 0000004e     9...@...G...N...
    49c8:	00000055 0000005c 00000063 0000006a     U...\...c...j...
    49d8:	00000071 00000078 00000080 00000087     q...x...........
    49e8:	0000008e 00000095 0000009c 000000a3     ................
    49f8:	000000aa 000000b1 000000b8 000000bf     ................
    4a08:	000000c6 000000ce 000000d5 000000dc     ................
    4a18:	000000e3 000000ea 000000f1 000000f8     ................
    4a28:	000000ff 00000106 0000010d 00000114     ................
    4a38:	0000011b 00000123 0000012a 00000131     ....#...*...1...
    4a48:	00000138 0000013f 00000146 0000014d     8...?...F...M...
    4a58:	00000154 0000015b 00000162 00000169     T...[...b...i...
    4a68:	00000171 00000178 0000017f 00000186     q...x...........
    4a78:	0000018d 00000194 0000019b 000001a2     ................
    4a88:	000001a9 000001b0 000001b7 000001be     ................
    4a98:	000001c6 000001cd 000001d4 000001db     ................
    4aa8:	000001e2 000001e9 000001f0 000001f7     ................
    4ab8:	000001fe 00000205 0000020c 00000213     ................
    4ac8:	0000021b 00000222 00000229 00000230     ...."...)...0...
    4ad8:	00000237 0000023e 00000245 0000024c     7...>...E...L...
    4ae8:	00000253 0000025a 00000261 00000269     S...Z...a...i...
    4af8:	00000270 00000277 0000027e 00000285     p...w...~.......
    4b08:	0000028c 00000293 0000029a 000002a1     ................
    4b18:	000002a8 000002af 000002b6 000002be     ................
    4b28:	000002c5 000002cc 000002d3 000002da     ................
    4b38:	000002e1 000002e8 000002ef 000002f6     ................
    4b48:	000002fd 00000304 0000030c 00000313     ................
    4b58:	0000031a 00000321 00000328 0000032f     ....!...(.../...
    4b68:	00000336 0000033d 00000344 0000034b     6...=...D...K...
    4b78:	00000352 00000359 00000361 00000368     R...Y...a...h...
    4b88:	0000036f 00000376 0000037d 00000384     o...v...}.......

00004b98 <Device_Descriptor>:
    4b98:	01100112 20000002 a50f15a2 02010000     ....... ........
    4ba8:	00000103                                ....

00004bac <String_Descriptor0>:
    4bac:	04090304                                ....

00004bb0 <String_Descriptor1>:
    4bb0:	00460314 00650072 00730065 00610063     ..F.r.e.e.s.c.a.
    4bc0:	0065006c                                l.e.

00004bc4 <String_Descriptor2>:
    4bc4:	00550312 00420053 0055002d 00520041     ..U.S.B.-.U.A.R.
    4bd4:	00000054                                T...

00004bd8 <String_Descriptor3>:
    4bd8:	00540312 00530045 005f0054 002e0031     ..T.E.S.T._.1...
    4be8:	00000030                                0...

00004bec <Configuration_Descriptor>:
    4bec:	00430209 c0000102 00040932 02020100     ..C.....2.......
    4bfc:	24050101 05011000 01000124 00022404     ...$....$....$..
    4c0c:	00062405 81050701 02002003 00010409     .$....... ......
    4c1c:	00000a02 82050701 00002002 02030507     ......... ......
    4c2c:	00000020                                 ...

00004c30 <cEP_Size>:
    4c30:	20202020 20202020 20202020 20202020                     
    4c40:	00003848 0000385c 0000385c 0000385c     H8..\8..\8..\8..
    4c50:	0000385c 0000378c 0000379e 0000385c     \8...7...7..\8..
    4c60:	0000383a 000037fc                       :8...7..

00004c68 <_init>:
    4c68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4c6a:	46c0      	nop			; (mov r8, r8)
    4c6c:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4c6e:	bc08      	pop	{r3}
    4c70:	469e      	mov	lr, r3
    4c72:	4770      	bx	lr

00004c74 <_fini>:
    4c74:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4c76:	46c0      	nop			; (mov r8, r8)
    4c78:	bcf8      	pop	{r3, r4, r5, r6, r7}
    4c7a:	bc08      	pop	{r3}
    4c7c:	469e      	mov	lr, r3
    4c7e:	4770      	bx	lr
